{"ast":null,"code":"import _classCallCheck from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { extend, type, findChildren, RangeObject, isNumber } from \"./utils/core\";\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar DOCUMENT_NODE = 9;\n\n/**\n\t* Parsing and creation of EpubCFIs: http://www.idpf.org/epub/linking/cfi/epub-cfi.html\n\n\t* Implements:\n\t* - Character Offset: epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)\n\t* - Simple Ranges : epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)\n\n\t* Does Not Implement:\n\t* - Temporal Offset (~)\n\t* - Spatial Offset (@)\n\t* - Temporal-Spatial Offset (~ + @)\n\t* - Text Location Assertion ([)\n\t* @class\n\t@param {string | Range | Node } [cfiFrom]\n\t@param {string | object} [base]\n\t@param {string} [ignoreClass] class to ignore when parsing DOM\n*/\nvar EpubCFI = /*#__PURE__*/function () {\n  function EpubCFI(cfiFrom, base, ignoreClass) {\n    _classCallCheck(this, EpubCFI);\n    var type;\n    this.str = \"\";\n    this.base = {};\n    this.spinePos = 0; // For compatibility\n\n    this.range = false; // true || false;\n\n    this.path = {};\n    this.start = null;\n    this.end = null;\n\n    // Allow instantiation without the \"new\" keyword\n    if (!(this instanceof EpubCFI)) {\n      return new EpubCFI(cfiFrom, base, ignoreClass);\n    }\n    if (typeof base === \"string\") {\n      this.base = this.parseComponent(base);\n    } else if (typeof base === \"object\" && base.steps) {\n      this.base = base;\n    }\n    type = this.checkType(cfiFrom);\n    if (type === \"string\") {\n      this.str = cfiFrom;\n      return extend(this, this.parse(cfiFrom));\n    } else if (type === \"range\") {\n      return extend(this, this.fromRange(cfiFrom, this.base, ignoreClass));\n    } else if (type === \"node\") {\n      return extend(this, this.fromNode(cfiFrom, this.base, ignoreClass));\n    } else if (type === \"EpubCFI\" && cfiFrom.path) {\n      return cfiFrom;\n    } else if (!cfiFrom) {\n      return this;\n    } else {\n      throw new TypeError(\"not a valid argument for EpubCFI\");\n    }\n  }\n\n  /**\n   * Check the type of constructor input\n   * @private\n   */\n  _createClass(EpubCFI, [{\n    key: \"checkType\",\n    value: function checkType(cfi) {\n      if (this.isCfiString(cfi)) {\n        return \"string\";\n        // Is a range object\n      } else if (cfi && typeof cfi === \"object\" && (type(cfi) === \"Range\" || typeof cfi.startContainer != \"undefined\")) {\n        return \"range\";\n      } else if (cfi && typeof cfi === \"object\" && typeof cfi.nodeType != \"undefined\") {\n        // || typeof cfi === \"function\"\n        return \"node\";\n      } else if (cfi && typeof cfi === \"object\" && cfi instanceof EpubCFI) {\n        return \"EpubCFI\";\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Parse a cfi string to a CFI object representation\n     * @param {string} cfiStr\n     * @returns {object} cfi\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(cfiStr) {\n      var cfi = {\n        spinePos: -1,\n        range: false,\n        base: {},\n        path: {},\n        start: null,\n        end: null\n      };\n      var baseComponent, pathComponent, range;\n      if (typeof cfiStr !== \"string\") {\n        return {\n          spinePos: -1\n        };\n      }\n      if (cfiStr.indexOf(\"epubcfi(\") === 0 && cfiStr[cfiStr.length - 1] === \")\") {\n        // Remove initial epubcfi( and ending )\n        cfiStr = cfiStr.slice(8, cfiStr.length - 1);\n      }\n      baseComponent = this.getChapterComponent(cfiStr);\n\n      // Make sure this is a valid cfi or return\n      if (!baseComponent) {\n        return {\n          spinePos: -1\n        };\n      }\n      cfi.base = this.parseComponent(baseComponent);\n      pathComponent = this.getPathComponent(cfiStr);\n      cfi.path = this.parseComponent(pathComponent);\n      range = this.getRange(cfiStr);\n      if (range) {\n        cfi.range = true;\n        cfi.start = this.parseComponent(range[0]);\n        cfi.end = this.parseComponent(range[1]);\n      }\n\n      // Get spine node position\n      // cfi.spineSegment = cfi.base.steps[1];\n\n      // Chapter segment is always the second step\n      cfi.spinePos = cfi.base.steps[1].index;\n      return cfi;\n    }\n  }, {\n    key: \"parseComponent\",\n    value: function parseComponent(componentStr) {\n      var component = {\n        steps: [],\n        terminal: {\n          offset: null,\n          assertion: null\n        }\n      };\n      var parts = componentStr.split(\":\");\n      var steps = parts[0].split(\"/\");\n      var terminal;\n      if (parts.length > 1) {\n        terminal = parts[1];\n        component.terminal = this.parseTerminal(terminal);\n      }\n      if (steps[0] === \"\") {\n        steps.shift(); // Ignore the first slash\n      }\n\n      component.steps = steps.map(function (step) {\n        return this.parseStep(step);\n      }.bind(this));\n      return component;\n    }\n  }, {\n    key: \"parseStep\",\n    value: function parseStep(stepStr) {\n      var type, num, index, has_brackets, id;\n      has_brackets = stepStr.match(/\\[(.*)\\]/);\n      if (has_brackets && has_brackets[1]) {\n        id = has_brackets[1];\n      }\n\n      //-- Check if step is a text node or element\n      num = parseInt(stepStr);\n      if (isNaN(num)) {\n        return;\n      }\n      if (num % 2 === 0) {\n        // Even = is an element\n        type = \"element\";\n        index = num / 2 - 1;\n      } else {\n        type = \"text\";\n        index = (num - 1) / 2;\n      }\n      return {\n        \"type\": type,\n        \"index\": index,\n        \"id\": id || null\n      };\n    }\n  }, {\n    key: \"parseTerminal\",\n    value: function parseTerminal(termialStr) {\n      var characterOffset, textLocationAssertion;\n      var assertion = termialStr.match(/\\[(.*)\\]/);\n      if (assertion && assertion[1]) {\n        characterOffset = parseInt(termialStr.split(\"[\")[0]);\n        textLocationAssertion = assertion[1];\n      } else {\n        characterOffset = parseInt(termialStr);\n      }\n      if (!isNumber(characterOffset)) {\n        characterOffset = null;\n      }\n      return {\n        \"offset\": characterOffset,\n        \"assertion\": textLocationAssertion\n      };\n    }\n  }, {\n    key: \"getChapterComponent\",\n    value: function getChapterComponent(cfiStr) {\n      var indirection = cfiStr.split(\"!\");\n      return indirection[0];\n    }\n  }, {\n    key: \"getPathComponent\",\n    value: function getPathComponent(cfiStr) {\n      var indirection = cfiStr.split(\"!\");\n      if (indirection[1]) {\n        var ranges = indirection[1].split(\",\");\n        return ranges[0];\n      }\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange(cfiStr) {\n      var ranges = cfiStr.split(\",\");\n      if (ranges.length === 3) {\n        return [ranges[1], ranges[2]];\n      }\n      return false;\n    }\n  }, {\n    key: \"getCharecterOffsetComponent\",\n    value: function getCharecterOffsetComponent(cfiStr) {\n      var splitStr = cfiStr.split(\":\");\n      return splitStr[1] || \"\";\n    }\n  }, {\n    key: \"joinSteps\",\n    value: function joinSteps(steps) {\n      if (!steps) {\n        return \"\";\n      }\n      return steps.map(function (part) {\n        var segment = \"\";\n        if (part.type === \"element\") {\n          segment += (part.index + 1) * 2;\n        }\n        if (part.type === \"text\") {\n          segment += 1 + 2 * part.index; // TODO: double check that this is odd\n        }\n\n        if (part.id) {\n          segment += \"[\" + part.id + \"]\";\n        }\n        return segment;\n      }).join(\"/\");\n    }\n  }, {\n    key: \"segmentString\",\n    value: function segmentString(segment) {\n      var segmentString = \"/\";\n      segmentString += this.joinSteps(segment.steps);\n      if (segment.terminal && segment.terminal.offset != null) {\n        segmentString += \":\" + segment.terminal.offset;\n      }\n      if (segment.terminal && segment.terminal.assertion != null) {\n        segmentString += \"[\" + segment.terminal.assertion + \"]\";\n      }\n      return segmentString;\n    }\n\n    /**\n     * Convert CFI to a epubcfi(...) string\n     * @returns {string} epubcfi\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var cfiString = \"epubcfi(\";\n      cfiString += this.segmentString(this.base);\n      cfiString += \"!\";\n      cfiString += this.segmentString(this.path);\n\n      // Add Range, if present\n      if (this.range && this.start) {\n        cfiString += \",\";\n        cfiString += this.segmentString(this.start);\n      }\n      if (this.range && this.end) {\n        cfiString += \",\";\n        cfiString += this.segmentString(this.end);\n      }\n      cfiString += \")\";\n      return cfiString;\n    }\n\n    /**\n     * Compare which of two CFIs is earlier in the text\n     * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0\n     */\n  }, {\n    key: \"compare\",\n    value: function compare(cfiOne, cfiTwo) {\n      var stepsA, stepsB;\n      var terminalA, terminalB;\n      var rangeAStartSteps, rangeAEndSteps;\n      var rangeBEndSteps, rangeBEndSteps;\n      var rangeAStartTerminal, rangeAEndTerminal;\n      var rangeBStartTerminal, rangeBEndTerminal;\n      if (typeof cfiOne === \"string\") {\n        cfiOne = new EpubCFI(cfiOne);\n      }\n      if (typeof cfiTwo === \"string\") {\n        cfiTwo = new EpubCFI(cfiTwo);\n      }\n      // Compare Spine Positions\n      if (cfiOne.spinePos > cfiTwo.spinePos) {\n        return 1;\n      }\n      if (cfiOne.spinePos < cfiTwo.spinePos) {\n        return -1;\n      }\n      if (cfiOne.range) {\n        stepsA = cfiOne.path.steps.concat(cfiOne.start.steps);\n        terminalA = cfiOne.start.terminal;\n      } else {\n        stepsA = cfiOne.path.steps;\n        terminalA = cfiOne.path.terminal;\n      }\n      if (cfiTwo.range) {\n        stepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);\n        terminalB = cfiTwo.start.terminal;\n      } else {\n        stepsB = cfiTwo.path.steps;\n        terminalB = cfiTwo.path.terminal;\n      }\n\n      // Compare Each Step in the First item\n      for (var i = 0; i < stepsA.length; i++) {\n        if (!stepsA[i]) {\n          return -1;\n        }\n        if (!stepsB[i]) {\n          return 1;\n        }\n        if (stepsA[i].index > stepsB[i].index) {\n          return 1;\n        }\n        if (stepsA[i].index < stepsB[i].index) {\n          return -1;\n        }\n        // Otherwise continue checking\n      }\n\n      // All steps in First equal to Second and First is Less Specific\n      if (stepsA.length < stepsB.length) {\n        return -1;\n      }\n\n      // Compare the character offset of the text node\n      if (terminalA.offset > terminalB.offset) {\n        return 1;\n      }\n      if (terminalA.offset < terminalB.offset) {\n        return -1;\n      }\n\n      // CFI's are equal\n      return 0;\n    }\n  }, {\n    key: \"step\",\n    value: function step(node) {\n      var nodeType = node.nodeType === TEXT_NODE ? \"text\" : \"element\";\n      return {\n        \"id\": node.id,\n        \"tagName\": node.tagName,\n        \"type\": nodeType,\n        \"index\": this.position(node)\n      };\n    }\n  }, {\n    key: \"filteredStep\",\n    value: function filteredStep(node, ignoreClass) {\n      var filteredNode = this.filter(node, ignoreClass);\n      var nodeType;\n\n      // Node filtered, so ignore\n      if (!filteredNode) {\n        return;\n      }\n\n      // Otherwise add the filter node in\n      nodeType = filteredNode.nodeType === TEXT_NODE ? \"text\" : \"element\";\n      return {\n        \"id\": filteredNode.id,\n        \"tagName\": filteredNode.tagName,\n        \"type\": nodeType,\n        \"index\": this.filteredPosition(filteredNode, ignoreClass)\n      };\n    }\n  }, {\n    key: \"pathTo\",\n    value: function pathTo(node, offset, ignoreClass) {\n      var segment = {\n        steps: [],\n        terminal: {\n          offset: null,\n          assertion: null\n        }\n      };\n      var currentNode = node;\n      var step;\n      while (currentNode && currentNode.parentNode && currentNode.parentNode.nodeType != DOCUMENT_NODE) {\n        if (ignoreClass) {\n          step = this.filteredStep(currentNode, ignoreClass);\n        } else {\n          step = this.step(currentNode);\n        }\n        if (step) {\n          segment.steps.unshift(step);\n        }\n        currentNode = currentNode.parentNode;\n      }\n      if (offset != null && offset >= 0) {\n        segment.terminal.offset = offset;\n\n        // Make sure we are getting to a textNode if there is an offset\n        if (segment.steps[segment.steps.length - 1].type != \"text\") {\n          segment.steps.push({\n            \"type\": \"text\",\n            \"index\": 0\n          });\n        }\n      }\n      return segment;\n    }\n  }, {\n    key: \"equalStep\",\n    value: function equalStep(stepA, stepB) {\n      if (!stepA || !stepB) {\n        return false;\n      }\n      if (stepA.index === stepB.index && stepA.id === stepB.id && stepA.type === stepB.type) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Create a CFI object from a Range\n     * @param {Range} range\n     * @param {string | object} base\n     * @param {string} [ignoreClass]\n     * @returns {object} cfi\n     */\n  }, {\n    key: \"fromRange\",\n    value: function fromRange(range, base, ignoreClass) {\n      var cfi = {\n        range: false,\n        base: {},\n        path: {},\n        start: null,\n        end: null\n      };\n      var start = range.startContainer;\n      var end = range.endContainer;\n      var startOffset = range.startOffset;\n      var endOffset = range.endOffset;\n      var needsIgnoring = false;\n      if (ignoreClass) {\n        // Tell pathTo if / what to ignore\n        needsIgnoring = start.ownerDocument.querySelector(\".\" + ignoreClass) != null;\n      }\n      if (typeof base === \"string\") {\n        cfi.base = this.parseComponent(base);\n        cfi.spinePos = cfi.base.steps[1].index;\n      } else if (typeof base === \"object\") {\n        cfi.base = base;\n      }\n      if (range.collapsed) {\n        if (needsIgnoring) {\n          startOffset = this.patchOffset(start, startOffset, ignoreClass);\n        }\n        cfi.path = this.pathTo(start, startOffset, ignoreClass);\n      } else {\n        cfi.range = true;\n        if (needsIgnoring) {\n          startOffset = this.patchOffset(start, startOffset, ignoreClass);\n        }\n        cfi.start = this.pathTo(start, startOffset, ignoreClass);\n        if (needsIgnoring) {\n          endOffset = this.patchOffset(end, endOffset, ignoreClass);\n        }\n        cfi.end = this.pathTo(end, endOffset, ignoreClass);\n\n        // Create a new empty path\n        cfi.path = {\n          steps: [],\n          terminal: null\n        };\n\n        // Push steps that are shared between start and end to the common path\n        var len = cfi.start.steps.length;\n        var i;\n        for (i = 0; i < len; i++) {\n          if (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n            if (i === len - 1) {\n              // Last step is equal, check terminals\n              if (cfi.start.terminal === cfi.end.terminal) {\n                // CFI's are equal\n                cfi.path.steps.push(cfi.start.steps[i]);\n                // Not a range\n                cfi.range = false;\n              }\n            } else {\n              cfi.path.steps.push(cfi.start.steps[i]);\n            }\n          } else {\n            break;\n          }\n        }\n        cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);\n        cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length);\n\n        // TODO: Add Sanity check to make sure that the end if greater than the start\n      }\n\n      return cfi;\n    }\n\n    /**\n     * Create a CFI object from a Node\n     * @param {Node} anchor\n     * @param {string | object} base\n     * @param {string} [ignoreClass]\n     * @returns {object} cfi\n     */\n  }, {\n    key: \"fromNode\",\n    value: function fromNode(anchor, base, ignoreClass) {\n      var cfi = {\n        range: false,\n        base: {},\n        path: {},\n        start: null,\n        end: null\n      };\n      if (typeof base === \"string\") {\n        cfi.base = this.parseComponent(base);\n        cfi.spinePos = cfi.base.steps[1].index;\n      } else if (typeof base === \"object\") {\n        cfi.base = base;\n      }\n      cfi.path = this.pathTo(anchor, null, ignoreClass);\n      return cfi;\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(anchor, ignoreClass) {\n      var needsIgnoring;\n      var sibling; // to join with\n      var parent, previousSibling, nextSibling;\n      var isText = false;\n      if (anchor.nodeType === TEXT_NODE) {\n        isText = true;\n        parent = anchor.parentNode;\n        needsIgnoring = anchor.parentNode.classList.contains(ignoreClass);\n      } else {\n        isText = false;\n        needsIgnoring = anchor.classList.contains(ignoreClass);\n      }\n      if (needsIgnoring && isText) {\n        previousSibling = parent.previousSibling;\n        nextSibling = parent.nextSibling;\n\n        // If the sibling is a text node, join the nodes\n        if (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n          sibling = previousSibling;\n        } else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {\n          sibling = nextSibling;\n        }\n        if (sibling) {\n          return sibling;\n        } else {\n          // Parent will be ignored on next step\n          return anchor;\n        }\n      } else if (needsIgnoring && !isText) {\n        // Otherwise just skip the element node\n        return false;\n      } else {\n        // No need to filter\n        return anchor;\n      }\n    }\n  }, {\n    key: \"patchOffset\",\n    value: function patchOffset(anchor, offset, ignoreClass) {\n      if (anchor.nodeType != TEXT_NODE) {\n        throw new Error(\"Anchor must be a text node\");\n      }\n      var curr = anchor;\n      var totalOffset = offset;\n\n      // If the parent is a ignored node, get offset from it's start\n      if (anchor.parentNode.classList.contains(ignoreClass)) {\n        curr = anchor.parentNode;\n      }\n      while (curr.previousSibling) {\n        if (curr.previousSibling.nodeType === ELEMENT_NODE) {\n          // Originally a text node, so join\n          if (curr.previousSibling.classList.contains(ignoreClass)) {\n            totalOffset += curr.previousSibling.textContent.length;\n          } else {\n            break; // Normal node, dont join\n          }\n        } else {\n          // If the previous sibling is a text node, join the nodes\n          totalOffset += curr.previousSibling.textContent.length;\n        }\n        curr = curr.previousSibling;\n      }\n      return totalOffset;\n    }\n  }, {\n    key: \"normalizedMap\",\n    value: function normalizedMap(children, nodeType, ignoreClass) {\n      var output = {};\n      var prevIndex = -1;\n      var i,\n        len = children.length;\n      var currNodeType;\n      var prevNodeType;\n      for (i = 0; i < len; i++) {\n        currNodeType = children[i].nodeType;\n\n        // Check if needs ignoring\n        if (currNodeType === ELEMENT_NODE && children[i].classList.contains(ignoreClass)) {\n          currNodeType = TEXT_NODE;\n        }\n        if (i > 0 && currNodeType === TEXT_NODE && prevNodeType === TEXT_NODE) {\n          // join text nodes\n          output[i] = prevIndex;\n        } else if (nodeType === currNodeType) {\n          prevIndex = prevIndex + 1;\n          output[i] = prevIndex;\n        }\n        prevNodeType = currNodeType;\n      }\n      return output;\n    }\n  }, {\n    key: \"position\",\n    value: function position(anchor) {\n      var children, index;\n      if (anchor.nodeType === ELEMENT_NODE) {\n        children = anchor.parentNode.children;\n        if (!children) {\n          children = findChildren(anchor.parentNode);\n        }\n        index = Array.prototype.indexOf.call(children, anchor);\n      } else {\n        children = this.textNodes(anchor.parentNode);\n        index = children.indexOf(anchor);\n      }\n      return index;\n    }\n  }, {\n    key: \"filteredPosition\",\n    value: function filteredPosition(anchor, ignoreClass) {\n      var children, index, map;\n      if (anchor.nodeType === ELEMENT_NODE) {\n        children = anchor.parentNode.children;\n        map = this.normalizedMap(children, ELEMENT_NODE, ignoreClass);\n      } else {\n        children = anchor.parentNode.childNodes;\n        // Inside an ignored node\n        if (anchor.parentNode.classList.contains(ignoreClass)) {\n          anchor = anchor.parentNode;\n          children = anchor.parentNode.childNodes;\n        }\n        map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n      }\n      index = Array.prototype.indexOf.call(children, anchor);\n      return map[index];\n    }\n  }, {\n    key: \"stepsToXpath\",\n    value: function stepsToXpath(steps) {\n      var xpath = [\".\", \"*\"];\n      steps.forEach(function (step) {\n        var position = step.index + 1;\n        if (step.id) {\n          xpath.push(\"*[position()=\" + position + \" and @id='\" + step.id + \"']\");\n        } else if (step.type === \"text\") {\n          xpath.push(\"text()[\" + position + \"]\");\n        } else {\n          xpath.push(\"*[\" + position + \"]\");\n        }\n      });\n      return xpath.join(\"/\");\n    }\n\n    /*\n    \tTo get the last step if needed:\n    \t// Get the terminal step\n    lastStep = steps[steps.length-1];\n    // Get the query string\n    query = this.stepsToQuery(steps);\n    // Find the containing element\n    startContainerParent = doc.querySelector(query);\n    // Find the text node within that element\n    if(startContainerParent && lastStep.type == \"text\") {\n    \tcontainer = startContainerParent.childNodes[lastStep.index];\n    }\n    */\n  }, {\n    key: \"stepsToQuerySelector\",\n    value: function stepsToQuerySelector(steps) {\n      var query = [\"html\"];\n      steps.forEach(function (step) {\n        var position = step.index + 1;\n        if (step.id) {\n          query.push(\"#\" + step.id);\n        } else if (step.type === \"text\") {\n          // unsupported in querySelector\n          // query.push(\"text()[\" + position + \"]\");\n        } else {\n          query.push(\"*:nth-child(\" + position + \")\");\n        }\n      });\n      return query.join(\">\");\n    }\n  }, {\n    key: \"textNodes\",\n    value: function textNodes(container, ignoreClass) {\n      return Array.prototype.slice.call(container.childNodes).filter(function (node) {\n        if (node.nodeType === TEXT_NODE) {\n          return true;\n        } else if (ignoreClass && node.classList.contains(ignoreClass)) {\n          return true;\n        }\n        return false;\n      });\n    }\n  }, {\n    key: \"walkToNode\",\n    value: function walkToNode(steps, _doc, ignoreClass) {\n      var doc = _doc || document;\n      var container = doc.documentElement;\n      var children;\n      var step;\n      var len = steps.length;\n      var i;\n      for (i = 0; i < len; i++) {\n        step = steps[i];\n        if (step.type === \"element\") {\n          //better to get a container using id as some times step.index may not be correct\n          //For ex.https://github.com/futurepress/epub.js/issues/561\n          if (step.id) {\n            container = doc.getElementById(step.id);\n          } else {\n            children = container.children || findChildren(container);\n            container = children[step.index];\n          }\n        } else if (step.type === \"text\") {\n          container = this.textNodes(container, ignoreClass)[step.index];\n        }\n        if (!container) {\n          //Break the for loop as due to incorrect index we can get error if\n          //container is undefined so that other functionailties works fine\n          //like navigation\n          break;\n        }\n      }\n      return container;\n    }\n  }, {\n    key: \"findNode\",\n    value: function findNode(steps, _doc, ignoreClass) {\n      var doc = _doc || document;\n      var container;\n      var xpath;\n      if (!ignoreClass && typeof doc.evaluate != \"undefined\") {\n        xpath = this.stepsToXpath(steps);\n        container = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n      } else if (ignoreClass) {\n        container = this.walkToNode(steps, doc, ignoreClass);\n      } else {\n        container = this.walkToNode(steps, doc);\n      }\n      return container;\n    }\n  }, {\n    key: \"fixMiss\",\n    value: function fixMiss(steps, offset, _doc, ignoreClass) {\n      var container = this.findNode(steps.slice(0, -1), _doc, ignoreClass);\n      var children = container.childNodes;\n      var map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n      var child;\n      var len;\n      var lastStepIndex = steps[steps.length - 1].index;\n      for (var childIndex in map) {\n        if (!map.hasOwnProperty(childIndex)) return;\n        if (map[childIndex] === lastStepIndex) {\n          child = children[childIndex];\n          len = child.textContent.length;\n          if (offset > len) {\n            offset = offset - len;\n          } else {\n            if (child.nodeType === ELEMENT_NODE) {\n              container = child.childNodes[0];\n            } else {\n              container = child;\n            }\n            break;\n          }\n        }\n      }\n      return {\n        container: container,\n        offset: offset\n      };\n    }\n\n    /**\n     * Creates a DOM range representing a CFI\n     * @param {document} _doc document referenced in the base\n     * @param {string} [ignoreClass]\n     * @return {Range}\n     */\n  }, {\n    key: \"toRange\",\n    value: function toRange(_doc, ignoreClass) {\n      var doc = _doc || document;\n      var range;\n      var start, end, startContainer, endContainer;\n      var cfi = this;\n      var startSteps, endSteps;\n      var needsIgnoring = ignoreClass ? doc.querySelector(\".\" + ignoreClass) != null : false;\n      var missed;\n      if (typeof doc.createRange !== \"undefined\") {\n        range = doc.createRange();\n      } else {\n        range = new RangeObject();\n      }\n      if (cfi.range) {\n        start = cfi.start;\n        startSteps = cfi.path.steps.concat(start.steps);\n        startContainer = this.findNode(startSteps, doc, needsIgnoring ? ignoreClass : null);\n        end = cfi.end;\n        endSteps = cfi.path.steps.concat(end.steps);\n        endContainer = this.findNode(endSteps, doc, needsIgnoring ? ignoreClass : null);\n      } else {\n        start = cfi.path;\n        startSteps = cfi.path.steps;\n        startContainer = this.findNode(cfi.path.steps, doc, needsIgnoring ? ignoreClass : null);\n      }\n      if (startContainer) {\n        try {\n          if (start.terminal.offset != null) {\n            range.setStart(startContainer, start.terminal.offset);\n          } else {\n            range.setStart(startContainer, 0);\n          }\n        } catch (e) {\n          missed = this.fixMiss(startSteps, start.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n          range.setStart(missed.container, missed.offset);\n        }\n      } else {\n        console.log(\"No startContainer found for\", this.toString());\n        // No start found\n        return null;\n      }\n      if (endContainer) {\n        try {\n          if (end.terminal.offset != null) {\n            range.setEnd(endContainer, end.terminal.offset);\n          } else {\n            range.setEnd(endContainer, 0);\n          }\n        } catch (e) {\n          missed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n          range.setEnd(missed.container, missed.offset);\n        }\n      }\n\n      // doc.defaultView.getSelection().addRange(range);\n      return range;\n    }\n\n    /**\n     * Check if a string is wrapped with \"epubcfi()\"\n     * @param {string} str\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isCfiString\",\n    value: function isCfiString(str) {\n      if (typeof str === \"string\" && str.indexOf(\"epubcfi(\") === 0 && str[str.length - 1] === \")\") {\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"generateChapterComponent\",\n    value: function generateChapterComponent(_spineNodeIndex, _pos, id) {\n      var pos = parseInt(_pos),\n        spineNodeIndex = (_spineNodeIndex + 1) * 2,\n        cfi = \"/\" + spineNodeIndex + \"/\";\n      cfi += (pos + 1) * 2;\n      if (id) {\n        cfi += \"[\" + id + \"]\";\n      }\n      return cfi;\n    }\n\n    /**\n     * Collapse a CFI Range to a single CFI Position\n     * @param {boolean} [toStart=false]\n     */\n  }, {\n    key: \"collapse\",\n    value: function collapse(toStart) {\n      if (!this.range) {\n        return;\n      }\n      this.range = false;\n      if (toStart) {\n        this.path.steps = this.path.steps.concat(this.start.steps);\n        this.path.terminal = this.start.terminal;\n      } else {\n        this.path.steps = this.path.steps.concat(this.end.steps);\n        this.path.terminal = this.end.terminal;\n      }\n    }\n  }]);\n  return EpubCFI;\n}();\nexport default EpubCFI;","map":{"version":3,"names":["extend","type","findChildren","RangeObject","isNumber","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_NODE","EpubCFI","cfiFrom","base","ignoreClass","str","spinePos","range","path","start","end","parseComponent","steps","checkType","parse","fromRange","fromNode","TypeError","cfi","isCfiString","startContainer","nodeType","cfiStr","baseComponent","pathComponent","indexOf","length","slice","getChapterComponent","getPathComponent","getRange","index","componentStr","component","terminal","offset","assertion","parts","split","parseTerminal","shift","map","step","parseStep","bind","stepStr","num","has_brackets","id","match","parseInt","isNaN","termialStr","characterOffset","textLocationAssertion","indirection","ranges","splitStr","part","segment","join","segmentString","joinSteps","cfiString","cfiOne","cfiTwo","stepsA","stepsB","terminalA","terminalB","rangeAStartSteps","rangeAEndSteps","rangeBEndSteps","rangeAStartTerminal","rangeAEndTerminal","rangeBStartTerminal","rangeBEndTerminal","concat","i","node","tagName","position","filteredNode","filter","filteredPosition","currentNode","parentNode","filteredStep","unshift","push","stepA","stepB","endContainer","startOffset","endOffset","needsIgnoring","ownerDocument","querySelector","collapsed","patchOffset","pathTo","len","equalStep","anchor","sibling","parent","previousSibling","nextSibling","isText","classList","contains","Error","curr","totalOffset","textContent","children","output","prevIndex","currNodeType","prevNodeType","Array","prototype","call","textNodes","normalizedMap","childNodes","xpath","forEach","query","container","_doc","doc","document","documentElement","getElementById","evaluate","stepsToXpath","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","walkToNode","findNode","child","lastStepIndex","childIndex","hasOwnProperty","startSteps","endSteps","missed","createRange","setStart","e","fixMiss","console","log","toString","setEnd","_spineNodeIndex","_pos","pos","spineNodeIndex","toStart"],"sources":["/home/parallels/Downloads/read/node_modules/epubjs/src/epubcfi.js"],"sourcesContent":["import {extend, type, findChildren, RangeObject, isNumber} from \"./utils/core\";\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst DOCUMENT_NODE = 9;\n\n/**\n\t* Parsing and creation of EpubCFIs: http://www.idpf.org/epub/linking/cfi/epub-cfi.html\n\n\t* Implements:\n\t* - Character Offset: epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)\n\t* - Simple Ranges : epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)\n\n\t* Does Not Implement:\n\t* - Temporal Offset (~)\n\t* - Spatial Offset (@)\n\t* - Temporal-Spatial Offset (~ + @)\n\t* - Text Location Assertion ([)\n\t* @class\n\t@param {string | Range | Node } [cfiFrom]\n\t@param {string | object} [base]\n\t@param {string} [ignoreClass] class to ignore when parsing DOM\n*/\nclass EpubCFI {\n\tconstructor(cfiFrom, base, ignoreClass){\n\t\tvar type;\n\n\t\tthis.str = \"\";\n\n\t\tthis.base = {};\n\t\tthis.spinePos = 0; // For compatibility\n\n\t\tthis.range = false; // true || false;\n\n\t\tthis.path = {};\n\t\tthis.start = null;\n\t\tthis.end = null;\n\n\t\t// Allow instantiation without the \"new\" keyword\n\t\tif (!(this instanceof EpubCFI)) {\n\t\t\treturn new EpubCFI(cfiFrom, base, ignoreClass);\n\t\t}\n\n\t\tif(typeof base === \"string\") {\n\t\t\tthis.base = this.parseComponent(base);\n\t\t} else if(typeof base === \"object\" && base.steps) {\n\t\t\tthis.base = base;\n\t\t}\n\n\t\ttype = this.checkType(cfiFrom);\n\n\n\t\tif(type === \"string\") {\n\t\t\tthis.str = cfiFrom;\n\t\t\treturn extend(this, this.parse(cfiFrom));\n\t\t} else if (type === \"range\") {\n\t\t\treturn extend(this, this.fromRange(cfiFrom, this.base, ignoreClass));\n\t\t} else if (type === \"node\") {\n\t\t\treturn extend(this, this.fromNode(cfiFrom, this.base, ignoreClass));\n\t\t} else if (type === \"EpubCFI\" && cfiFrom.path) {\n\t\t\treturn cfiFrom;\n\t\t} else if (!cfiFrom) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\tthrow new TypeError(\"not a valid argument for EpubCFI\");\n\t\t}\n\n\t}\n\n\t/**\n\t * Check the type of constructor input\n\t * @private\n\t */\n\tcheckType(cfi) {\n\n\t\tif (this.isCfiString(cfi)) {\n\t\t\treturn \"string\";\n\t\t// Is a range object\n\t\t} else if (cfi && typeof cfi === \"object\" && (type(cfi) === \"Range\" || typeof(cfi.startContainer) != \"undefined\")){\n\t\t\treturn \"range\";\n\t\t} else if (cfi && typeof cfi === \"object\" && typeof(cfi.nodeType) != \"undefined\" ){ // || typeof cfi === \"function\"\n\t\t\treturn \"node\";\n\t\t} else if (cfi && typeof cfi === \"object\" && cfi instanceof EpubCFI){\n\t\t\treturn \"EpubCFI\";\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Parse a cfi string to a CFI object representation\n\t * @param {string} cfiStr\n\t * @returns {object} cfi\n\t */\n\tparse(cfiStr) {\n\t\tvar cfi = {\n\t\t\tspinePos: -1,\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\t\tvar baseComponent, pathComponent, range;\n\n\t\tif(typeof cfiStr !== \"string\") {\n\t\t\treturn {spinePos: -1};\n\t\t}\n\n\t\tif(cfiStr.indexOf(\"epubcfi(\") === 0 && cfiStr[cfiStr.length-1] === \")\") {\n\t\t\t// Remove initial epubcfi( and ending )\n\t\t\tcfiStr = cfiStr.slice(8, cfiStr.length-1);\n\t\t}\n\n\t\tbaseComponent = this.getChapterComponent(cfiStr);\n\n\t\t// Make sure this is a valid cfi or return\n\t\tif(!baseComponent) {\n\t\t\treturn {spinePos: -1};\n\t\t}\n\n\t\tcfi.base = this.parseComponent(baseComponent);\n\n\t\tpathComponent = this.getPathComponent(cfiStr);\n\t\tcfi.path = this.parseComponent(pathComponent);\n\n\t\trange = this.getRange(cfiStr);\n\n\t\tif(range) {\n\t\t\tcfi.range = true;\n\t\t\tcfi.start = this.parseComponent(range[0]);\n\t\t\tcfi.end = this.parseComponent(range[1]);\n\t\t}\n\n\t\t// Get spine node position\n\t\t// cfi.spineSegment = cfi.base.steps[1];\n\n\t\t// Chapter segment is always the second step\n\t\tcfi.spinePos = cfi.base.steps[1].index;\n\n\t\treturn cfi;\n\t}\n\n\tparseComponent(componentStr){\n\t\tvar component = {\n\t\t\tsteps: [],\n\t\t\tterminal: {\n\t\t\t\toffset: null,\n\t\t\t\tassertion: null\n\t\t\t}\n\t\t};\n\t\tvar parts = componentStr.split(\":\");\n\t\tvar steps = parts[0].split(\"/\");\n\t\tvar terminal;\n\n\t\tif(parts.length > 1) {\n\t\t\tterminal = parts[1];\n\t\t\tcomponent.terminal = this.parseTerminal(terminal);\n\t\t}\n\n\t\tif (steps[0] === \"\") {\n\t\t\tsteps.shift(); // Ignore the first slash\n\t\t}\n\n\t\tcomponent.steps = steps.map(function(step){\n\t\t\treturn this.parseStep(step);\n\t\t}.bind(this));\n\n\t\treturn component;\n\t}\n\n\tparseStep(stepStr){\n\t\tvar type, num, index, has_brackets, id;\n\n\t\thas_brackets = stepStr.match(/\\[(.*)\\]/);\n\t\tif(has_brackets && has_brackets[1]){\n\t\t\tid = has_brackets[1];\n\t\t}\n\n\t\t//-- Check if step is a text node or element\n\t\tnum = parseInt(stepStr);\n\n\t\tif(isNaN(num)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(num % 2 === 0) { // Even = is an element\n\t\t\ttype = \"element\";\n\t\t\tindex = num / 2 - 1;\n\t\t} else {\n\t\t\ttype = \"text\";\n\t\t\tindex = (num - 1 ) / 2;\n\t\t}\n\n\t\treturn {\n\t\t\t\"type\" : type,\n\t\t\t\"index\" : index,\n\t\t\t\"id\" : id || null\n\t\t};\n\t}\n\n\tparseTerminal(termialStr){\n\t\tvar characterOffset, textLocationAssertion;\n\t\tvar assertion = termialStr.match(/\\[(.*)\\]/);\n\n\t\tif(assertion && assertion[1]){\n\t\t\tcharacterOffset = parseInt(termialStr.split(\"[\")[0]);\n\t\t\ttextLocationAssertion = assertion[1];\n\t\t} else {\n\t\t\tcharacterOffset = parseInt(termialStr);\n\t\t}\n\n\t\tif (!isNumber(characterOffset)) {\n\t\t\tcharacterOffset = null;\n\t\t}\n\n\t\treturn {\n\t\t\t\"offset\": characterOffset,\n\t\t\t\"assertion\": textLocationAssertion\n\t\t};\n\n\t}\n\n\tgetChapterComponent(cfiStr) {\n\n\t\tvar indirection = cfiStr.split(\"!\");\n\n\t\treturn indirection[0];\n\t}\n\n\tgetPathComponent(cfiStr) {\n\n\t\tvar indirection = cfiStr.split(\"!\");\n\n\t\tif(indirection[1]) {\n\t\t\tlet ranges = indirection[1].split(\",\");\n\t\t\treturn ranges[0];\n\t\t}\n\n\t}\n\n\tgetRange(cfiStr) {\n\n\t\tvar ranges = cfiStr.split(\",\");\n\n\t\tif(ranges.length === 3){\n\t\t\treturn [\n\t\t\t\tranges[1],\n\t\t\t\tranges[2]\n\t\t\t];\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetCharecterOffsetComponent(cfiStr) {\n\t\tvar splitStr = cfiStr.split(\":\");\n\t\treturn splitStr[1] || \"\";\n\t}\n\n\tjoinSteps(steps) {\n\t\tif(!steps) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn steps.map(function(part){\n\t\t\tvar segment = \"\";\n\n\t\t\tif(part.type === \"element\") {\n\t\t\t\tsegment += (part.index + 1) * 2;\n\t\t\t}\n\n\t\t\tif(part.type === \"text\") {\n\t\t\t\tsegment += 1 + (2 * part.index); // TODO: double check that this is odd\n\t\t\t}\n\n\t\t\tif(part.id) {\n\t\t\t\tsegment += \"[\" + part.id + \"]\";\n\t\t\t}\n\n\t\t\treturn segment;\n\n\t\t}).join(\"/\");\n\n\t}\n\n\tsegmentString(segment) {\n\t\tvar segmentString = \"/\";\n\n\t\tsegmentString += this.joinSteps(segment.steps);\n\n\t\tif(segment.terminal && segment.terminal.offset != null){\n\t\t\tsegmentString += \":\" + segment.terminal.offset;\n\t\t}\n\n\t\tif(segment.terminal && segment.terminal.assertion != null){\n\t\t\tsegmentString += \"[\" + segment.terminal.assertion + \"]\";\n\t\t}\n\n\t\treturn segmentString;\n\t}\n\n\t/**\n\t * Convert CFI to a epubcfi(...) string\n\t * @returns {string} epubcfi\n\t */\n\ttoString() {\n\t\tvar cfiString = \"epubcfi(\";\n\n\t\tcfiString += this.segmentString(this.base);\n\n\t\tcfiString += \"!\";\n\t\tcfiString += this.segmentString(this.path);\n\n\t\t// Add Range, if present\n\t\tif(this.range && this.start) {\n\t\t\tcfiString += \",\";\n\t\t\tcfiString += this.segmentString(this.start);\n\t\t}\n\n\t\tif(this.range && this.end) {\n\t\t\tcfiString += \",\";\n\t\t\tcfiString += this.segmentString(this.end);\n\t\t}\n\n\t\tcfiString += \")\";\n\n\t\treturn cfiString;\n\t}\n\n\n\t/**\n\t * Compare which of two CFIs is earlier in the text\n\t * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0\n\t */\n\tcompare(cfiOne, cfiTwo) {\n\t\tvar stepsA, stepsB;\n\t\tvar terminalA, terminalB;\n\n\t\tvar rangeAStartSteps, rangeAEndSteps;\n\t\tvar rangeBEndSteps, rangeBEndSteps;\n\t\tvar rangeAStartTerminal, rangeAEndTerminal;\n\t\tvar rangeBStartTerminal, rangeBEndTerminal;\n\n\t\tif(typeof cfiOne === \"string\") {\n\t\t\tcfiOne = new EpubCFI(cfiOne);\n\t\t}\n\t\tif(typeof cfiTwo === \"string\") {\n\t\t\tcfiTwo = new EpubCFI(cfiTwo);\n\t\t}\n\t\t// Compare Spine Positions\n\t\tif(cfiOne.spinePos > cfiTwo.spinePos) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(cfiOne.spinePos < cfiTwo.spinePos) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (cfiOne.range) {\n\t\t\tstepsA = cfiOne.path.steps.concat(cfiOne.start.steps);\n\t\t\tterminalA = cfiOne.start.terminal;\n\t\t} else {\n\t\t\tstepsA = cfiOne.path.steps;\n\t\t\tterminalA = cfiOne.path.terminal;\n\t\t}\n\n\t\tif (cfiTwo.range) {\n\t\t\tstepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);\n\t\t\tterminalB = cfiTwo.start.terminal;\n\t\t} else {\n\t\t\tstepsB = cfiTwo.path.steps;\n\t\t\tterminalB = cfiTwo.path.terminal;\n\t\t}\n\n\t\t// Compare Each Step in the First item\n\t\tfor (var i = 0; i < stepsA.length; i++) {\n\t\t\tif(!stepsA[i]) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(!stepsB[i]) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(stepsA[i].index > stepsB[i].index) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(stepsA[i].index < stepsB[i].index) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// Otherwise continue checking\n\t\t}\n\n\t\t// All steps in First equal to Second and First is Less Specific\n\t\tif(stepsA.length < stepsB.length) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Compare the character offset of the text node\n\t\tif(terminalA.offset > terminalB.offset) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(terminalA.offset < terminalB.offset) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// CFI's are equal\n\t\treturn 0;\n\t}\n\n\tstep(node) {\n\t\tvar nodeType = (node.nodeType === TEXT_NODE) ? \"text\" : \"element\";\n\n\t\treturn {\n\t\t\t\"id\" : node.id,\n\t\t\t\"tagName\" : node.tagName,\n\t\t\t\"type\" : nodeType,\n\t\t\t\"index\" : this.position(node)\n\t\t};\n\t}\n\n\tfilteredStep(node, ignoreClass) {\n\t\tvar filteredNode = this.filter(node, ignoreClass);\n\t\tvar nodeType;\n\n\t\t// Node filtered, so ignore\n\t\tif (!filteredNode) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise add the filter node in\n\t\tnodeType = (filteredNode.nodeType === TEXT_NODE) ? \"text\" : \"element\";\n\n\t\treturn {\n\t\t\t\"id\" : filteredNode.id,\n\t\t\t\"tagName\" : filteredNode.tagName,\n\t\t\t\"type\" : nodeType,\n\t\t\t\"index\" : this.filteredPosition(filteredNode, ignoreClass)\n\t\t};\n\t}\n\n\tpathTo(node, offset, ignoreClass) {\n\t\tvar segment = {\n\t\t\tsteps: [],\n\t\t\tterminal: {\n\t\t\t\toffset: null,\n\t\t\t\tassertion: null\n\t\t\t}\n\t\t};\n\t\tvar currentNode = node;\n\t\tvar step;\n\n\t\twhile(currentNode && currentNode.parentNode &&\n\t\t\t\t\tcurrentNode.parentNode.nodeType != DOCUMENT_NODE) {\n\n\t\t\tif (ignoreClass) {\n\t\t\t\tstep = this.filteredStep(currentNode, ignoreClass);\n\t\t\t} else {\n\t\t\t\tstep = this.step(currentNode);\n\t\t\t}\n\n\t\t\tif (step) {\n\t\t\t\tsegment.steps.unshift(step);\n\t\t\t}\n\n\t\t\tcurrentNode = currentNode.parentNode;\n\n\t\t}\n\n\t\tif (offset != null && offset >= 0) {\n\n\t\t\tsegment.terminal.offset = offset;\n\n\t\t\t// Make sure we are getting to a textNode if there is an offset\n\t\t\tif(segment.steps[segment.steps.length-1].type != \"text\") {\n\t\t\t\tsegment.steps.push({\n\t\t\t\t\t\"type\" : \"text\",\n\t\t\t\t\t\"index\" : 0\n\t\t\t\t});\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn segment;\n\t}\n\n\tequalStep(stepA, stepB) {\n\t\tif (!stepA || !stepB) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif(stepA.index === stepB.index &&\n\t\t\t stepA.id === stepB.id &&\n\t\t\t stepA.type === stepB.type) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create a CFI object from a Range\n\t * @param {Range} range\n\t * @param {string | object} base\n\t * @param {string} [ignoreClass]\n\t * @returns {object} cfi\n\t */\n\tfromRange(range, base, ignoreClass) {\n\t\tvar cfi = {\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\n\t\tvar start = range.startContainer;\n\t\tvar end = range.endContainer;\n\n\t\tvar startOffset = range.startOffset;\n\t\tvar endOffset = range.endOffset;\n\n\t\tvar needsIgnoring = false;\n\n\t\tif (ignoreClass) {\n\t\t\t// Tell pathTo if / what to ignore\n\t\t\tneedsIgnoring = (start.ownerDocument.querySelector(\".\" + ignoreClass) != null);\n\t\t}\n\n\n\t\tif (typeof base === \"string\") {\n\t\t\tcfi.base = this.parseComponent(base);\n\t\t\tcfi.spinePos = cfi.base.steps[1].index;\n\t\t} else if (typeof base === \"object\") {\n\t\t\tcfi.base = base;\n\t\t}\n\n\t\tif (range.collapsed) {\n\t\t\tif (needsIgnoring) {\n\t\t\t\tstartOffset = this.patchOffset(start, startOffset, ignoreClass);\n\t\t\t}\n\t\t\tcfi.path = this.pathTo(start, startOffset, ignoreClass);\n\t\t} else {\n\t\t\tcfi.range = true;\n\n\t\t\tif (needsIgnoring) {\n\t\t\t\tstartOffset = this.patchOffset(start, startOffset, ignoreClass);\n\t\t\t}\n\n\t\t\tcfi.start = this.pathTo(start, startOffset, ignoreClass);\n\t\t\tif (needsIgnoring) {\n\t\t\t\tendOffset = this.patchOffset(end, endOffset, ignoreClass);\n\t\t\t}\n\n\t\t\tcfi.end = this.pathTo(end, endOffset, ignoreClass);\n\n\t\t\t// Create a new empty path\n\t\t\tcfi.path = {\n\t\t\t\tsteps: [],\n\t\t\t\tterminal: null\n\t\t\t};\n\n\t\t\t// Push steps that are shared between start and end to the common path\n\t\t\tvar len = cfi.start.steps.length;\n\t\t\tvar i;\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n\t\t\t\t\tif(i === len-1) {\n\t\t\t\t\t\t// Last step is equal, check terminals\n\t\t\t\t\t\tif(cfi.start.terminal === cfi.end.terminal) {\n\t\t\t\t\t\t\t// CFI's are equal\n\t\t\t\t\t\t\tcfi.path.steps.push(cfi.start.steps[i]);\n\t\t\t\t\t\t\t// Not a range\n\t\t\t\t\t\t\tcfi.range = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcfi.path.steps.push(cfi.start.steps[i]);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);\n\t\t\tcfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length);\n\n\t\t\t// TODO: Add Sanity check to make sure that the end if greater than the start\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Create a CFI object from a Node\n\t * @param {Node} anchor\n\t * @param {string | object} base\n\t * @param {string} [ignoreClass]\n\t * @returns {object} cfi\n\t */\n\tfromNode(anchor, base, ignoreClass) {\n\t\tvar cfi = {\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\n\t\tif (typeof base === \"string\") {\n\t\t\tcfi.base = this.parseComponent(base);\n\t\t\tcfi.spinePos = cfi.base.steps[1].index;\n\t\t} else if (typeof base === \"object\") {\n\t\t\tcfi.base = base;\n\t\t}\n\n\t\tcfi.path = this.pathTo(anchor, null, ignoreClass);\n\n\t\treturn cfi;\n\t}\n\n\tfilter(anchor, ignoreClass) {\n\t\tvar needsIgnoring;\n\t\tvar sibling; // to join with\n\t\tvar parent, previousSibling, nextSibling;\n\t\tvar isText = false;\n\n\t\tif (anchor.nodeType === TEXT_NODE) {\n\t\t\tisText = true;\n\t\t\tparent = anchor.parentNode;\n\t\t\tneedsIgnoring = anchor.parentNode.classList.contains(ignoreClass);\n\t\t} else {\n\t\t\tisText = false;\n\t\t\tneedsIgnoring = anchor.classList.contains(ignoreClass);\n\t\t}\n\n\t\tif (needsIgnoring && isText) {\n\t\t\tpreviousSibling = parent.previousSibling;\n\t\t\tnextSibling = parent.nextSibling;\n\n\t\t\t// If the sibling is a text node, join the nodes\n\t\t\tif (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n\t\t\t\tsibling = previousSibling;\n\t\t\t} else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {\n\t\t\t\tsibling = nextSibling;\n\t\t\t}\n\n\t\t\tif (sibling) {\n\t\t\t\treturn sibling;\n\t\t\t} else {\n\t\t\t\t// Parent will be ignored on next step\n\t\t\t\treturn anchor;\n\t\t\t}\n\n\t\t} else if (needsIgnoring && !isText) {\n\t\t\t// Otherwise just skip the element node\n\t\t\treturn false;\n\t\t} else {\n\t\t\t// No need to filter\n\t\t\treturn anchor;\n\t\t}\n\n\t}\n\n\tpatchOffset(anchor, offset, ignoreClass) {\n\t\tif (anchor.nodeType != TEXT_NODE) {\n\t\t\tthrow new Error(\"Anchor must be a text node\");\n\t\t}\n\n\t\tvar curr = anchor;\n\t\tvar totalOffset = offset;\n\n\t\t// If the parent is a ignored node, get offset from it's start\n\t\tif (anchor.parentNode.classList.contains(ignoreClass)) {\n\t\t\tcurr = anchor.parentNode;\n\t\t}\n\n\t\twhile (curr.previousSibling) {\n\t\t\tif(curr.previousSibling.nodeType === ELEMENT_NODE) {\n\t\t\t\t// Originally a text node, so join\n\t\t\t\tif(curr.previousSibling.classList.contains(ignoreClass)){\n\t\t\t\t\ttotalOffset += curr.previousSibling.textContent.length;\n\t\t\t\t} else {\n\t\t\t\t\tbreak; // Normal node, dont join\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If the previous sibling is a text node, join the nodes\n\t\t\t\ttotalOffset += curr.previousSibling.textContent.length;\n\t\t\t}\n\n\t\t\tcurr = curr.previousSibling;\n\t\t}\n\n\t\treturn totalOffset;\n\n\t}\n\n\tnormalizedMap(children, nodeType, ignoreClass) {\n\t\tvar output = {};\n\t\tvar prevIndex = -1;\n\t\tvar i, len = children.length;\n\t\tvar currNodeType;\n\t\tvar prevNodeType;\n\n\t\tfor (i = 0; i < len; i++) {\n\n\t\t\tcurrNodeType = children[i].nodeType;\n\n\t\t\t// Check if needs ignoring\n\t\t\tif (currNodeType === ELEMENT_NODE &&\n\t\t\t\t\tchildren[i].classList.contains(ignoreClass)) {\n\t\t\t\tcurrNodeType = TEXT_NODE;\n\t\t\t}\n\n\t\t\tif (i > 0 &&\n\t\t\t\t\tcurrNodeType === TEXT_NODE &&\n\t\t\t\t\tprevNodeType === TEXT_NODE) {\n\t\t\t\t// join text nodes\n\t\t\t\toutput[i] = prevIndex;\n\t\t\t} else if (nodeType === currNodeType){\n\t\t\t\tprevIndex = prevIndex + 1;\n\t\t\t\toutput[i] = prevIndex;\n\t\t\t}\n\n\t\t\tprevNodeType = currNodeType;\n\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tposition(anchor) {\n\t\tvar children, index;\n\t\tif (anchor.nodeType === ELEMENT_NODE) {\n\t\t\tchildren = anchor.parentNode.children;\n\t\t\tif (!children) {\n\t\t\t\tchildren = findChildren(anchor.parentNode);\n\t\t\t}\n\t\t\tindex = Array.prototype.indexOf.call(children, anchor);\n\t\t} else {\n\t\t\tchildren = this.textNodes(anchor.parentNode);\n\t\t\tindex = children.indexOf(anchor);\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tfilteredPosition(anchor, ignoreClass) {\n\t\tvar children, index, map;\n\n\t\tif (anchor.nodeType === ELEMENT_NODE) {\n\t\t\tchildren = anchor.parentNode.children;\n\t\t\tmap = this.normalizedMap(children, ELEMENT_NODE, ignoreClass);\n\t\t} else {\n\t\t\tchildren = anchor.parentNode.childNodes;\n\t\t\t// Inside an ignored node\n\t\t\tif(anchor.parentNode.classList.contains(ignoreClass)) {\n\t\t\t\tanchor = anchor.parentNode;\n\t\t\t\tchildren = anchor.parentNode.childNodes;\n\t\t\t}\n\t\t\tmap = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n\t\t}\n\n\n\t\tindex = Array.prototype.indexOf.call(children, anchor);\n\n\t\treturn map[index];\n\t}\n\n\tstepsToXpath(steps) {\n\t\tvar xpath = [\".\", \"*\"];\n\n\t\tsteps.forEach(function(step){\n\t\t\tvar position = step.index + 1;\n\n\t\t\tif(step.id){\n\t\t\t\txpath.push(\"*[position()=\" + position + \" and @id='\" + step.id + \"']\");\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\txpath.push(\"text()[\" + position + \"]\");\n\t\t\t} else {\n\t\t\t\txpath.push(\"*[\" + position + \"]\");\n\t\t\t}\n\t\t});\n\n\t\treturn xpath.join(\"/\");\n\t}\n\n\n\t/*\n\n\tTo get the last step if needed:\n\n\t// Get the terminal step\n\tlastStep = steps[steps.length-1];\n\t// Get the query string\n\tquery = this.stepsToQuery(steps);\n\t// Find the containing element\n\tstartContainerParent = doc.querySelector(query);\n\t// Find the text node within that element\n\tif(startContainerParent && lastStep.type == \"text\") {\n\t\tcontainer = startContainerParent.childNodes[lastStep.index];\n\t}\n\t*/\n\tstepsToQuerySelector(steps) {\n\t\tvar query = [\"html\"];\n\n\t\tsteps.forEach(function(step){\n\t\t\tvar position = step.index + 1;\n\n\t\t\tif(step.id){\n\t\t\t\tquery.push(\"#\" + step.id);\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\t// unsupported in querySelector\n\t\t\t\t// query.push(\"text()[\" + position + \"]\");\n\t\t\t} else {\n\t\t\t\tquery.push(\"*:nth-child(\" + position + \")\");\n\t\t\t}\n\t\t});\n\n\t\treturn query.join(\">\");\n\n\t}\n\n\ttextNodes(container, ignoreClass) {\n\t\treturn Array.prototype.slice.call(container.childNodes).\n\t\t\tfilter(function (node) {\n\t\t\t\tif (node.nodeType === TEXT_NODE) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (ignoreClass && node.classList.contains(ignoreClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t}\n\n\twalkToNode(steps, _doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar container = doc.documentElement;\n\t\tvar children;\n\t\tvar step;\n\t\tvar len = steps.length;\n\t\tvar i;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tstep = steps[i];\n\n\t\t\tif(step.type === \"element\") {\n\t\t\t\t//better to get a container using id as some times step.index may not be correct\n\t\t\t\t//For ex.https://github.com/futurepress/epub.js/issues/561\n\t\t\t\tif(step.id) {\n\t\t\t\t\tcontainer = doc.getElementById(step.id);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchildren = container.children || findChildren(container);\n\t\t\t\t\tcontainer = children[step.index];\n\t\t\t\t}\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\tcontainer = this.textNodes(container, ignoreClass)[step.index];\n\t\t\t}\n\t\t\tif(!container) {\n\t\t\t\t//Break the for loop as due to incorrect index we can get error if\n\t\t\t\t//container is undefined so that other functionailties works fine\n\t\t\t\t//like navigation\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\treturn container;\n\t}\n\n\tfindNode(steps, _doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar container;\n\t\tvar xpath;\n\n\t\tif(!ignoreClass && typeof doc.evaluate != \"undefined\") {\n\t\t\txpath = this.stepsToXpath(steps);\n\t\t\tcontainer = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n\t\t} else if(ignoreClass) {\n\t\t\tcontainer = this.walkToNode(steps, doc, ignoreClass);\n\t\t} else {\n\t\t\tcontainer = this.walkToNode(steps, doc);\n\t\t}\n\n\t\treturn container;\n\t}\n\n\tfixMiss(steps, offset, _doc, ignoreClass) {\n\t\tvar container = this.findNode(steps.slice(0,-1), _doc, ignoreClass);\n\t\tvar children = container.childNodes;\n\t\tvar map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n\t\tvar child;\n\t\tvar len;\n\t\tvar lastStepIndex = steps[steps.length-1].index;\n\n\t\tfor (let childIndex in map) {\n\t\t\tif (!map.hasOwnProperty(childIndex)) return;\n\n\t\t\tif(map[childIndex] === lastStepIndex) {\n\t\t\t\tchild = children[childIndex];\n\t\t\t\tlen = child.textContent.length;\n\t\t\t\tif(offset > len) {\n\t\t\t\t\toffset = offset - len;\n\t\t\t\t} else {\n\t\t\t\t\tif (child.nodeType === ELEMENT_NODE) {\n\t\t\t\t\t\tcontainer = child.childNodes[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontainer = child;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tcontainer: container,\n\t\t\toffset: offset\n\t\t};\n\n\t}\n\n\t/**\n\t * Creates a DOM range representing a CFI\n\t * @param {document} _doc document referenced in the base\n\t * @param {string} [ignoreClass]\n\t * @return {Range}\n\t */\n\ttoRange(_doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar range;\n\t\tvar start, end, startContainer, endContainer;\n\t\tvar cfi = this;\n\t\tvar startSteps, endSteps;\n\t\tvar needsIgnoring = ignoreClass ? (doc.querySelector(\".\" + ignoreClass) != null) : false;\n\t\tvar missed;\n\n\t\tif (typeof(doc.createRange) !== \"undefined\") {\n\t\t\trange = doc.createRange();\n\t\t} else {\n\t\t\trange = new RangeObject();\n\t\t}\n\n\t\tif (cfi.range) {\n\t\t\tstart = cfi.start;\n\t\t\tstartSteps = cfi.path.steps.concat(start.steps);\n\t\t\tstartContainer = this.findNode(startSteps, doc, needsIgnoring ? ignoreClass : null);\n\t\t\tend = cfi.end;\n\t\t\tendSteps = cfi.path.steps.concat(end.steps);\n\t\t\tendContainer = this.findNode(endSteps, doc, needsIgnoring ? ignoreClass : null);\n\t\t} else {\n\t\t\tstart = cfi.path;\n\t\t\tstartSteps = cfi.path.steps;\n\t\t\tstartContainer = this.findNode(cfi.path.steps, doc, needsIgnoring ? ignoreClass : null);\n\t\t}\n\n\t\tif(startContainer) {\n\t\t\ttry {\n\n\t\t\t\tif(start.terminal.offset != null) {\n\t\t\t\t\trange.setStart(startContainer, start.terminal.offset);\n\t\t\t\t} else {\n\t\t\t\t\trange.setStart(startContainer, 0);\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\t\t\t\tmissed = this.fixMiss(startSteps, start.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n\t\t\t\trange.setStart(missed.container, missed.offset);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log(\"No startContainer found for\", this.toString());\n\t\t\t// No start found\n\t\t\treturn null;\n\t\t}\n\n\t\tif (endContainer) {\n\t\t\ttry {\n\n\t\t\t\tif(end.terminal.offset != null) {\n\t\t\t\t\trange.setEnd(endContainer, end.terminal.offset);\n\t\t\t\t} else {\n\t\t\t\t\trange.setEnd(endContainer, 0);\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\t\t\t\tmissed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n\t\t\t\trange.setEnd(missed.container, missed.offset);\n\t\t\t}\n\t\t}\n\n\n\t\t// doc.defaultView.getSelection().addRange(range);\n\t\treturn range;\n\t}\n\n\t/**\n\t * Check if a string is wrapped with \"epubcfi()\"\n\t * @param {string} str\n\t * @returns {boolean}\n\t */\n\tisCfiString(str) {\n\t\tif(typeof str === \"string\" &&\n\t\t\tstr.indexOf(\"epubcfi(\") === 0 &&\n\t\t\tstr[str.length-1] === \")\") {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgenerateChapterComponent(_spineNodeIndex, _pos, id) {\n\t\tvar pos = parseInt(_pos),\n\t\t\t\tspineNodeIndex = (_spineNodeIndex + 1) * 2,\n\t\t\t\tcfi = \"/\"+spineNodeIndex+\"/\";\n\n\t\tcfi += (pos + 1) * 2;\n\n\t\tif(id) {\n\t\t\tcfi += \"[\" + id + \"]\";\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Collapse a CFI Range to a single CFI Position\n\t * @param {boolean} [toStart=false]\n\t */\n\tcollapse(toStart) {\n\t\tif (!this.range) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.range = false;\n\n\t\tif (toStart) {\n\t\t\tthis.path.steps = this.path.steps.concat(this.start.steps);\n\t\t\tthis.path.terminal = this.start.terminal;\n\t\t} else {\n\t\t\tthis.path.steps = this.path.steps.concat(this.end.steps);\n\t\t\tthis.path.terminal = this.end.terminal;\n\t\t}\n\n\t}\n}\n\nexport default EpubCFI;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}