{"ast":null,"code":"import { defer, requestAnimationFrame } from \"./core\";\n\n/**\n * Queue for handling tasks one at a time\n * @class\n * @param {scope} context what this will resolve to in the tasks\n */\nclass Queue {\n  constructor(context) {\n    this._q = [];\n    this.context = context;\n    this.tick = requestAnimationFrame;\n    this.running = false;\n    this.paused = false;\n  }\n\n  /**\n   * Add an item to the queue\n   * @return {Promise}\n   */\n  enqueue() {\n    var deferred, promise;\n    var queued;\n    var task = [].shift.call(arguments);\n    var args = arguments;\n\n    // Handle single args without context\n    // if(args && !Array.isArray(args)) {\n    //   args = [args];\n    // }\n    if (!task) {\n      throw new Error(\"No Task Provided\");\n    }\n    if (typeof task === \"function\") {\n      deferred = new defer();\n      promise = deferred.promise;\n      queued = {\n        \"task\": task,\n        \"args\": args,\n        //\"context\"  : context,\n        \"deferred\": deferred,\n        \"promise\": promise\n      };\n    } else {\n      // Task is a promise\n      queued = {\n        \"promise\": task\n      };\n    }\n    this._q.push(queued);\n\n    // Wait to start queue flush\n    if (this.paused == false && !this.running) {\n      // setTimeout(this.flush.bind(this), 0);\n      // this.tick.call(window, this.run.bind(this));\n      this.run();\n    }\n    return queued.promise;\n  }\n\n  /**\n   * Run one item\n   * @return {Promise}\n   */\n  dequeue() {\n    var inwait, task, result;\n    if (this._q.length && !this.paused) {\n      inwait = this._q.shift();\n      task = inwait.task;\n      if (task) {\n        // console.log(task)\n\n        result = task.apply(this.context, inwait.args);\n        if (result && typeof result[\"then\"] === \"function\") {\n          // Task is a function that returns a promise\n          return result.then(function () {\n            inwait.deferred.resolve.apply(this.context, arguments);\n          }.bind(this), function () {\n            inwait.deferred.reject.apply(this.context, arguments);\n          }.bind(this));\n        } else {\n          // Task resolves immediately\n          inwait.deferred.resolve.apply(this.context, result);\n          return inwait.promise;\n        }\n      } else if (inwait.promise) {\n        // Task is a promise\n        return inwait.promise;\n      }\n    } else {\n      inwait = new defer();\n      inwait.deferred.resolve();\n      return inwait.promise;\n    }\n  }\n\n  // Run All Immediately\n  dump() {\n    while (this._q.length) {\n      this.dequeue();\n    }\n  }\n\n  /**\n   * Run all tasks sequentially, at convince\n   * @return {Promise}\n   */\n  run() {\n    if (!this.running) {\n      this.running = true;\n      this.defered = new defer();\n    }\n    this.tick.call(window, () => {\n      if (this._q.length) {\n        this.dequeue().then(function () {\n          this.run();\n        }.bind(this));\n      } else {\n        this.defered.resolve();\n        this.running = undefined;\n      }\n    });\n\n    // Unpause\n    if (this.paused == true) {\n      this.paused = false;\n    }\n    return this.defered.promise;\n  }\n\n  /**\n   * Flush all, as quickly as possible\n   * @return {Promise}\n   */\n  flush() {\n    if (this.running) {\n      return this.running;\n    }\n    if (this._q.length) {\n      this.running = this.dequeue().then(function () {\n        this.running = undefined;\n        return this.flush();\n      }.bind(this));\n      return this.running;\n    }\n  }\n\n  /**\n   * Clear all items in wait\n   */\n  clear() {\n    this._q = [];\n  }\n\n  /**\n   * Get the number of tasks in the queue\n   * @return {number} tasks\n   */\n  length() {\n    return this._q.length;\n  }\n\n  /**\n   * Pause a running queue\n   */\n  pause() {\n    this.paused = true;\n  }\n\n  /**\n   * End the queue\n   */\n  stop() {\n    this._q = [];\n    this.running = false;\n    this.paused = true;\n  }\n}\n\n/**\n * Create a new task from a callback\n * @class\n * @private\n * @param {function} task\n * @param {array} args\n * @param {scope} context\n * @return {function} task\n */\nclass Task {\n  constructor(task, args, context) {\n    return function () {\n      var toApply = arguments || [];\n      return new Promise((resolve, reject) => {\n        var callback = function (value, err) {\n          if (!value && err) {\n            reject(err);\n          } else {\n            resolve(value);\n          }\n        };\n        // Add the callback to the arguments list\n        toApply.push(callback);\n\n        // Apply all arguments to the functions\n        task.apply(context || this, toApply);\n      });\n    };\n  }\n}\nexport default Queue;\nexport { Task };","map":{"version":3,"names":["defer","requestAnimationFrame","Queue","constructor","context","_q","tick","running","paused","enqueue","deferred","promise","queued","task","shift","call","arguments","args","Error","push","run","dequeue","inwait","result","length","apply","then","resolve","bind","reject","dump","defered","window","undefined","flush","clear","pause","stop","Task","toApply","Promise","callback","value","err"],"sources":["/home/parallels/Downloads/react-epub-viewer-demo/node_modules/epubjs/src/utils/queue.js"],"sourcesContent":["import {defer, requestAnimationFrame} from \"./core\";\n\n/**\n * Queue for handling tasks one at a time\n * @class\n * @param {scope} context what this will resolve to in the tasks\n */\nclass Queue {\n\tconstructor(context){\n\t\tthis._q = [];\n\t\tthis.context = context;\n\t\tthis.tick = requestAnimationFrame;\n\t\tthis.running = false;\n\t\tthis.paused = false;\n\t}\n\n\t/**\n\t * Add an item to the queue\n\t * @return {Promise}\n\t */\n\tenqueue() {\n\t\tvar deferred, promise;\n\t\tvar queued;\n\t\tvar task = [].shift.call(arguments);\n\t\tvar args = arguments;\n\n\t\t// Handle single args without context\n\t\t// if(args && !Array.isArray(args)) {\n\t\t//   args = [args];\n\t\t// }\n\t\tif(!task) {\n\t\t\tthrow new Error(\"No Task Provided\");\n\t\t}\n\n\t\tif(typeof task === \"function\"){\n\n\t\t\tdeferred = new defer();\n\t\t\tpromise = deferred.promise;\n\n\t\t\tqueued = {\n\t\t\t\t\"task\" : task,\n\t\t\t\t\"args\"     : args,\n\t\t\t\t//\"context\"  : context,\n\t\t\t\t\"deferred\" : deferred,\n\t\t\t\t\"promise\" : promise\n\t\t\t};\n\n\t\t} else {\n\t\t\t// Task is a promise\n\t\t\tqueued = {\n\t\t\t\t\"promise\" : task\n\t\t\t};\n\n\t\t}\n\n\t\tthis._q.push(queued);\n\n\t\t// Wait to start queue flush\n\t\tif (this.paused == false && !this.running) {\n\t\t\t// setTimeout(this.flush.bind(this), 0);\n\t\t\t// this.tick.call(window, this.run.bind(this));\n\t\t\tthis.run();\n\t\t}\n\n\t\treturn queued.promise;\n\t}\n\n\t/**\n\t * Run one item\n\t * @return {Promise}\n\t */\n\tdequeue(){\n\t\tvar inwait, task, result;\n\n\t\tif(this._q.length && !this.paused) {\n\t\t\tinwait = this._q.shift();\n\t\t\ttask = inwait.task;\n\t\t\tif(task){\n\t\t\t\t// console.log(task)\n\n\t\t\t\tresult = task.apply(this.context, inwait.args);\n\n\t\t\t\tif(result && typeof result[\"then\"] === \"function\") {\n\t\t\t\t\t// Task is a function that returns a promise\n\t\t\t\t\treturn result.then(function(){\n\t\t\t\t\t\tinwait.deferred.resolve.apply(this.context, arguments);\n\t\t\t\t\t}.bind(this), function() {\n\t\t\t\t\t\tinwait.deferred.reject.apply(this.context, arguments);\n\t\t\t\t\t}.bind(this));\n\t\t\t\t} else {\n\t\t\t\t\t// Task resolves immediately\n\t\t\t\t\tinwait.deferred.resolve.apply(this.context, result);\n\t\t\t\t\treturn inwait.promise;\n\t\t\t\t}\n\n\n\n\t\t\t} else if(inwait.promise) {\n\t\t\t\t// Task is a promise\n\t\t\t\treturn inwait.promise;\n\t\t\t}\n\n\t\t} else {\n\t\t\tinwait = new defer();\n\t\t\tinwait.deferred.resolve();\n\t\t\treturn inwait.promise;\n\t\t}\n\n\t}\n\n\t// Run All Immediately\n\tdump(){\n\t\twhile(this._q.length) {\n\t\t\tthis.dequeue();\n\t\t}\n\t}\n\n\t/**\n\t * Run all tasks sequentially, at convince\n\t * @return {Promise}\n\t */\n\trun(){\n\n\t\tif(!this.running){\n\t\t\tthis.running = true;\n\t\t\tthis.defered = new defer();\n\t\t}\n\n\t\tthis.tick.call(window, () => {\n\n\t\t\tif(this._q.length) {\n\n\t\t\t\tthis.dequeue()\n\t\t\t\t\t.then(function(){\n\t\t\t\t\t\tthis.run();\n\t\t\t\t\t}.bind(this));\n\n\t\t\t} else {\n\t\t\t\tthis.defered.resolve();\n\t\t\t\tthis.running = undefined;\n\t\t\t}\n\n\t\t});\n\n\t\t// Unpause\n\t\tif(this.paused == true) {\n\t\t\tthis.paused = false;\n\t\t}\n\n\t\treturn this.defered.promise;\n\t}\n\n\t/**\n\t * Flush all, as quickly as possible\n\t * @return {Promise}\n\t */\n\tflush(){\n\n\t\tif(this.running){\n\t\t\treturn this.running;\n\t\t}\n\n\t\tif(this._q.length) {\n\t\t\tthis.running = this.dequeue()\n\t\t\t\t.then(function(){\n\t\t\t\t\tthis.running = undefined;\n\t\t\t\t\treturn this.flush();\n\t\t\t\t}.bind(this));\n\n\t\t\treturn this.running;\n\t\t}\n\n\t}\n\n\t/**\n\t * Clear all items in wait\n\t */\n\tclear(){\n\t\tthis._q = [];\n\t}\n\n\t/**\n\t * Get the number of tasks in the queue\n\t * @return {number} tasks\n\t */\n\tlength(){\n\t\treturn this._q.length;\n\t}\n\n\t/**\n\t * Pause a running queue\n\t */\n\tpause(){\n\t\tthis.paused = true;\n\t}\n\n\t/**\n\t * End the queue\n\t */\n\tstop(){\n\t\tthis._q = [];\n\t\tthis.running = false;\n\t\tthis.paused = true;\n\t}\n}\n\n\n/**\n * Create a new task from a callback\n * @class\n * @private\n * @param {function} task\n * @param {array} args\n * @param {scope} context\n * @return {function} task\n */\nclass Task {\n\tconstructor(task, args, context){\n\n\t\treturn function(){\n\t\t\tvar toApply = arguments || [];\n\n\t\t\treturn new Promise( (resolve, reject) => {\n\t\t\t\tvar callback = function(value, err){\n\t\t\t\t\tif (!value && err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t// Add the callback to the arguments list\n\t\t\t\ttoApply.push(callback);\n\n\t\t\t\t// Apply all arguments to the functions\n\t\t\t\ttask.apply(context || this, toApply);\n\n\t\t\t});\n\n\t\t};\n\n\t}\n}\n\n\nexport default Queue;\nexport { Task };\n"],"mappings":"AAAA,SAAQA,KAAK,EAAEC,qBAAqB,QAAO,QAAQ;;AAEnD;AACA;AACA;AACA;AACA;AACA,MAAMC,KAAK,CAAC;EACXC,WAAW,CAACC,OAAO,EAAC;IACnB,IAAI,CAACC,EAAE,GAAG,EAAE;IACZ,IAAI,CAACD,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACE,IAAI,GAAGL,qBAAqB;IACjC,IAAI,CAACM,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,MAAM,GAAG,KAAK;EACpB;;EAEA;AACD;AACA;AACA;EACCC,OAAO,GAAG;IACT,IAAIC,QAAQ,EAAEC,OAAO;IACrB,IAAIC,MAAM;IACV,IAAIC,IAAI,GAAG,EAAE,CAACC,KAAK,CAACC,IAAI,CAACC,SAAS,CAAC;IACnC,IAAIC,IAAI,GAAGD,SAAS;;IAEpB;IACA;IACA;IACA;IACA,IAAG,CAACH,IAAI,EAAE;MACT,MAAM,IAAIK,KAAK,CAAC,kBAAkB,CAAC;IACpC;IAEA,IAAG,OAAOL,IAAI,KAAK,UAAU,EAAC;MAE7BH,QAAQ,GAAG,IAAIV,KAAK,EAAE;MACtBW,OAAO,GAAGD,QAAQ,CAACC,OAAO;MAE1BC,MAAM,GAAG;QACR,MAAM,EAAGC,IAAI;QACb,MAAM,EAAOI,IAAI;QACjB;QACA,UAAU,EAAGP,QAAQ;QACrB,SAAS,EAAGC;MACb,CAAC;IAEF,CAAC,MAAM;MACN;MACAC,MAAM,GAAG;QACR,SAAS,EAAGC;MACb,CAAC;IAEF;IAEA,IAAI,CAACR,EAAE,CAACc,IAAI,CAACP,MAAM,CAAC;;IAEpB;IACA,IAAI,IAAI,CAACJ,MAAM,IAAI,KAAK,IAAI,CAAC,IAAI,CAACD,OAAO,EAAE;MAC1C;MACA;MACA,IAAI,CAACa,GAAG,EAAE;IACX;IAEA,OAAOR,MAAM,CAACD,OAAO;EACtB;;EAEA;AACD;AACA;AACA;EACCU,OAAO,GAAE;IACR,IAAIC,MAAM,EAAET,IAAI,EAAEU,MAAM;IAExB,IAAG,IAAI,CAAClB,EAAE,CAACmB,MAAM,IAAI,CAAC,IAAI,CAAChB,MAAM,EAAE;MAClCc,MAAM,GAAG,IAAI,CAACjB,EAAE,CAACS,KAAK,EAAE;MACxBD,IAAI,GAAGS,MAAM,CAACT,IAAI;MAClB,IAAGA,IAAI,EAAC;QACP;;QAEAU,MAAM,GAAGV,IAAI,CAACY,KAAK,CAAC,IAAI,CAACrB,OAAO,EAAEkB,MAAM,CAACL,IAAI,CAAC;QAE9C,IAAGM,MAAM,IAAI,OAAOA,MAAM,CAAC,MAAM,CAAC,KAAK,UAAU,EAAE;UAClD;UACA,OAAOA,MAAM,CAACG,IAAI,CAAC,YAAU;YAC5BJ,MAAM,CAACZ,QAAQ,CAACiB,OAAO,CAACF,KAAK,CAAC,IAAI,CAACrB,OAAO,EAAEY,SAAS,CAAC;UACvD,CAAC,CAACY,IAAI,CAAC,IAAI,CAAC,EAAE,YAAW;YACxBN,MAAM,CAACZ,QAAQ,CAACmB,MAAM,CAACJ,KAAK,CAAC,IAAI,CAACrB,OAAO,EAAEY,SAAS,CAAC;UACtD,CAAC,CAACY,IAAI,CAAC,IAAI,CAAC,CAAC;QACd,CAAC,MAAM;UACN;UACAN,MAAM,CAACZ,QAAQ,CAACiB,OAAO,CAACF,KAAK,CAAC,IAAI,CAACrB,OAAO,EAAEmB,MAAM,CAAC;UACnD,OAAOD,MAAM,CAACX,OAAO;QACtB;MAID,CAAC,MAAM,IAAGW,MAAM,CAACX,OAAO,EAAE;QACzB;QACA,OAAOW,MAAM,CAACX,OAAO;MACtB;IAED,CAAC,MAAM;MACNW,MAAM,GAAG,IAAItB,KAAK,EAAE;MACpBsB,MAAM,CAACZ,QAAQ,CAACiB,OAAO,EAAE;MACzB,OAAOL,MAAM,CAACX,OAAO;IACtB;EAED;;EAEA;EACAmB,IAAI,GAAE;IACL,OAAM,IAAI,CAACzB,EAAE,CAACmB,MAAM,EAAE;MACrB,IAAI,CAACH,OAAO,EAAE;IACf;EACD;;EAEA;AACD;AACA;AACA;EACCD,GAAG,GAAE;IAEJ,IAAG,CAAC,IAAI,CAACb,OAAO,EAAC;MAChB,IAAI,CAACA,OAAO,GAAG,IAAI;MACnB,IAAI,CAACwB,OAAO,GAAG,IAAI/B,KAAK,EAAE;IAC3B;IAEA,IAAI,CAACM,IAAI,CAACS,IAAI,CAACiB,MAAM,EAAE,MAAM;MAE5B,IAAG,IAAI,CAAC3B,EAAE,CAACmB,MAAM,EAAE;QAElB,IAAI,CAACH,OAAO,EAAE,CACZK,IAAI,CAAC,YAAU;UACf,IAAI,CAACN,GAAG,EAAE;QACX,CAAC,CAACQ,IAAI,CAAC,IAAI,CAAC,CAAC;MAEf,CAAC,MAAM;QACN,IAAI,CAACG,OAAO,CAACJ,OAAO,EAAE;QACtB,IAAI,CAACpB,OAAO,GAAG0B,SAAS;MACzB;IAED,CAAC,CAAC;;IAEF;IACA,IAAG,IAAI,CAACzB,MAAM,IAAI,IAAI,EAAE;MACvB,IAAI,CAACA,MAAM,GAAG,KAAK;IACpB;IAEA,OAAO,IAAI,CAACuB,OAAO,CAACpB,OAAO;EAC5B;;EAEA;AACD;AACA;AACA;EACCuB,KAAK,GAAE;IAEN,IAAG,IAAI,CAAC3B,OAAO,EAAC;MACf,OAAO,IAAI,CAACA,OAAO;IACpB;IAEA,IAAG,IAAI,CAACF,EAAE,CAACmB,MAAM,EAAE;MAClB,IAAI,CAACjB,OAAO,GAAG,IAAI,CAACc,OAAO,EAAE,CAC3BK,IAAI,CAAC,YAAU;QACf,IAAI,CAACnB,OAAO,GAAG0B,SAAS;QACxB,OAAO,IAAI,CAACC,KAAK,EAAE;MACpB,CAAC,CAACN,IAAI,CAAC,IAAI,CAAC,CAAC;MAEd,OAAO,IAAI,CAACrB,OAAO;IACpB;EAED;;EAEA;AACD;AACA;EACC4B,KAAK,GAAE;IACN,IAAI,CAAC9B,EAAE,GAAG,EAAE;EACb;;EAEA;AACD;AACA;AACA;EACCmB,MAAM,GAAE;IACP,OAAO,IAAI,CAACnB,EAAE,CAACmB,MAAM;EACtB;;EAEA;AACD;AACA;EACCY,KAAK,GAAE;IACN,IAAI,CAAC5B,MAAM,GAAG,IAAI;EACnB;;EAEA;AACD;AACA;EACC6B,IAAI,GAAE;IACL,IAAI,CAAChC,EAAE,GAAG,EAAE;IACZ,IAAI,CAACE,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,MAAM,GAAG,IAAI;EACnB;AACD;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM8B,IAAI,CAAC;EACVnC,WAAW,CAACU,IAAI,EAAEI,IAAI,EAAEb,OAAO,EAAC;IAE/B,OAAO,YAAU;MAChB,IAAImC,OAAO,GAAGvB,SAAS,IAAI,EAAE;MAE7B,OAAO,IAAIwB,OAAO,CAAE,CAACb,OAAO,EAAEE,MAAM,KAAK;QACxC,IAAIY,QAAQ,GAAG,UAASC,KAAK,EAAEC,GAAG,EAAC;UAClC,IAAI,CAACD,KAAK,IAAIC,GAAG,EAAE;YAClBd,MAAM,CAACc,GAAG,CAAC;UACZ,CAAC,MAAM;YACNhB,OAAO,CAACe,KAAK,CAAC;UACf;QACD,CAAC;QACD;QACAH,OAAO,CAACpB,IAAI,CAACsB,QAAQ,CAAC;;QAEtB;QACA5B,IAAI,CAACY,KAAK,CAACrB,OAAO,IAAI,IAAI,EAAEmC,OAAO,CAAC;MAErC,CAAC,CAAC;IAEH,CAAC;EAEF;AACD;AAGA,eAAerC,KAAK;AACpB,SAASoC,IAAI"},"metadata":{},"sourceType":"module"}