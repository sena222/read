{"ast":null,"code":"import _classCallCheck from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { defer, isXml, parse } from \"./utils/core\";\nimport request from \"./utils/request\";\nimport mime from \"./utils/mime\";\nimport Path from \"./utils/path\";\nimport JSZip from \"jszip/dist/jszip\";\n\n/**\n * Handles Unzipping a requesting files from an Epub Archive\n * @class\n */\nvar Archive = /*#__PURE__*/function () {\n  function Archive() {\n    _classCallCheck(this, Archive);\n    this.zip = undefined;\n    this.urlCache = {};\n    this.checkRequirements();\n  }\n\n  /**\n   * Checks to see if JSZip exists in global namspace,\n   * Requires JSZip if it isn't there\n   * @private\n   */\n  _createClass(Archive, [{\n    key: \"checkRequirements\",\n    value: function checkRequirements() {\n      try {\n        this.zip = new JSZip();\n      } catch (e) {\n        throw new Error(\"JSZip lib not loaded\");\n      }\n    }\n\n    /**\n     * Open an archive\n     * @param  {binary} input\n     * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded\n     * @return {Promise} zipfile\n     */\n  }, {\n    key: \"open\",\n    value: function open(input, isBase64) {\n      return this.zip.loadAsync(input, {\n        \"base64\": isBase64\n      });\n    }\n\n    /**\n     * Load and Open an archive\n     * @param  {string} zipUrl\n     * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded\n     * @return {Promise} zipfile\n     */\n  }, {\n    key: \"openUrl\",\n    value: function openUrl(zipUrl, isBase64) {\n      return request(zipUrl, \"binary\").then(function (data) {\n        return this.zip.loadAsync(data, {\n          \"base64\": isBase64\n        });\n      }.bind(this));\n    }\n\n    /**\n     * Request a url from the archive\n     * @param  {string} url  a url to request from the archive\n     * @param  {string} [type] specify the type of the returned result\n     * @return {Promise<Blob | string | JSON | Document | XMLDocument>}\n     */\n  }, {\n    key: \"request\",\n    value: function request(url, type) {\n      var deferred = new defer();\n      var response;\n      var path = new Path(url);\n\n      // If type isn't set, determine it from the file extension\n      if (!type) {\n        type = path.extension;\n      }\n      if (type == \"blob\") {\n        response = this.getBlob(url);\n      } else {\n        response = this.getText(url);\n      }\n      if (response) {\n        response.then(function (r) {\n          var result = this.handleResponse(r, type);\n          deferred.resolve(result);\n        }.bind(this));\n      } else {\n        deferred.reject({\n          message: \"File not found in the epub: \" + url,\n          stack: new Error().stack\n        });\n      }\n      return deferred.promise;\n    }\n\n    /**\n     * Handle the response from request\n     * @private\n     * @param  {any} response\n     * @param  {string} [type]\n     * @return {any} the parsed result\n     */\n  }, {\n    key: \"handleResponse\",\n    value: function handleResponse(response, type) {\n      var r;\n      if (type == \"json\") {\n        r = JSON.parse(response);\n      } else if (isXml(type)) {\n        r = parse(response, \"text/xml\");\n      } else if (type == \"xhtml\") {\n        r = parse(response, \"application/xhtml+xml\");\n      } else if (type == \"html\" || type == \"htm\") {\n        r = parse(response, \"text/html\");\n      } else {\n        r = response;\n      }\n      return r;\n    }\n\n    /**\n     * Get a Blob from Archive by Url\n     * @param  {string} url\n     * @param  {string} [mimeType]\n     * @return {Blob}\n     */\n  }, {\n    key: \"getBlob\",\n    value: function getBlob(url, mimeType) {\n      var decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n      var entry = this.zip.file(decodededUrl);\n      if (entry) {\n        mimeType = mimeType || mime.lookup(entry.name);\n        return entry.async(\"uint8array\").then(function (uint8array) {\n          return new Blob([uint8array], {\n            type: mimeType\n          });\n        });\n      }\n    }\n\n    /**\n     * Get Text from Archive by Url\n     * @param  {string} url\n     * @param  {string} [encoding]\n     * @return {string}\n     */\n  }, {\n    key: \"getText\",\n    value: function getText(url, encoding) {\n      var decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n      var entry = this.zip.file(decodededUrl);\n      if (entry) {\n        return entry.async(\"string\").then(function (text) {\n          return text;\n        });\n      }\n    }\n\n    /**\n     * Get a base64 encoded result from Archive by Url\n     * @param  {string} url\n     * @param  {string} [mimeType]\n     * @return {string} base64 encoded\n     */\n  }, {\n    key: \"getBase64\",\n    value: function getBase64(url, mimeType) {\n      var decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n      var entry = this.zip.file(decodededUrl);\n      if (entry) {\n        mimeType = mimeType || mime.lookup(entry.name);\n        return entry.async(\"base64\").then(function (data) {\n          return \"data:\" + mimeType + \";base64,\" + data;\n        });\n      }\n    }\n\n    /**\n     * Create a Url from an unarchived item\n     * @param  {string} url\n     * @param  {object} [options.base64] use base64 encoding or blob url\n     * @return {Promise} url promise with Url string\n     */\n  }, {\n    key: \"createUrl\",\n    value: function createUrl(url, options) {\n      var deferred = new defer();\n      var _URL = window.URL || window.webkitURL || window.mozURL;\n      var tempUrl;\n      var response;\n      var useBase64 = options && options.base64;\n      if (url in this.urlCache) {\n        deferred.resolve(this.urlCache[url]);\n        return deferred.promise;\n      }\n      if (useBase64) {\n        response = this.getBase64(url);\n        if (response) {\n          response.then(function (tempUrl) {\n            this.urlCache[url] = tempUrl;\n            deferred.resolve(tempUrl);\n          }.bind(this));\n        }\n      } else {\n        response = this.getBlob(url);\n        if (response) {\n          response.then(function (blob) {\n            tempUrl = _URL.createObjectURL(blob);\n            this.urlCache[url] = tempUrl;\n            deferred.resolve(tempUrl);\n          }.bind(this));\n        }\n      }\n      if (!response) {\n        deferred.reject({\n          message: \"File not found in the epub: \" + url,\n          stack: new Error().stack\n        });\n      }\n      return deferred.promise;\n    }\n\n    /**\n     * Revoke Temp Url for a archive item\n     * @param  {string} url url of the item in the archive\n     */\n  }, {\n    key: \"revokeUrl\",\n    value: function revokeUrl(url) {\n      var _URL = window.URL || window.webkitURL || window.mozURL;\n      var fromCache = this.urlCache[url];\n      if (fromCache) _URL.revokeObjectURL(fromCache);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _URL = window.URL || window.webkitURL || window.mozURL;\n      for (var fromCache in this.urlCache) {\n        _URL.revokeObjectURL(fromCache);\n      }\n      this.zip = undefined;\n      this.urlCache = {};\n    }\n  }]);\n  return Archive;\n}();\nexport default Archive;","map":{"version":3,"names":["defer","isXml","parse","request","mime","Path","JSZip","Archive","zip","undefined","urlCache","checkRequirements","e","Error","input","isBase64","loadAsync","zipUrl","then","data","bind","url","type","deferred","response","path","extension","getBlob","getText","r","result","handleResponse","resolve","reject","message","stack","promise","JSON","mimeType","decodededUrl","window","decodeURIComponent","substr","entry","file","lookup","name","async","uint8array","Blob","encoding","text","options","_URL","URL","webkitURL","mozURL","tempUrl","useBase64","base64","getBase64","blob","createObjectURL","fromCache","revokeObjectURL"],"sources":["/home/parallels/Downloads/read/node_modules/epubjs/src/archive.js"],"sourcesContent":["import {defer, isXml, parse} from \"./utils/core\";\nimport request from \"./utils/request\";\nimport mime from \"./utils/mime\";\nimport Path from \"./utils/path\";\nimport JSZip from \"jszip/dist/jszip\";\n\n/**\n * Handles Unzipping a requesting files from an Epub Archive\n * @class\n */\nclass Archive {\n\n\tconstructor() {\n\t\tthis.zip = undefined;\n\t\tthis.urlCache = {};\n\n\t\tthis.checkRequirements();\n\n\t}\n\n\t/**\n\t * Checks to see if JSZip exists in global namspace,\n\t * Requires JSZip if it isn't there\n\t * @private\n\t */\n\tcheckRequirements(){\n\t\ttry {\n\t\t\tthis.zip = new JSZip();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"JSZip lib not loaded\");\n\t\t}\n\t}\n\n\t/**\n\t * Open an archive\n\t * @param  {binary} input\n\t * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded\n\t * @return {Promise} zipfile\n\t */\n\topen(input, isBase64){\n\t\treturn this.zip.loadAsync(input, {\"base64\": isBase64});\n\t}\n\n\t/**\n\t * Load and Open an archive\n\t * @param  {string} zipUrl\n\t * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded\n\t * @return {Promise} zipfile\n\t */\n\topenUrl(zipUrl, isBase64){\n\t\treturn request(zipUrl, \"binary\")\n\t\t\t.then(function(data){\n\t\t\t\treturn this.zip.loadAsync(data, {\"base64\": isBase64});\n\t\t\t}.bind(this));\n\t}\n\n\t/**\n\t * Request a url from the archive\n\t * @param  {string} url  a url to request from the archive\n\t * @param  {string} [type] specify the type of the returned result\n\t * @return {Promise<Blob | string | JSON | Document | XMLDocument>}\n\t */\n\trequest(url, type){\n\t\tvar deferred = new defer();\n\t\tvar response;\n\t\tvar path = new Path(url);\n\n\t\t// If type isn't set, determine it from the file extension\n\t\tif(!type) {\n\t\t\ttype = path.extension;\n\t\t}\n\n\t\tif(type == \"blob\"){\n\t\t\tresponse = this.getBlob(url);\n\t\t} else {\n\t\t\tresponse = this.getText(url);\n\t\t}\n\n\t\tif (response) {\n\t\t\tresponse.then(function (r) {\n\t\t\t\tlet result = this.handleResponse(r, type);\n\t\t\t\tdeferred.resolve(result);\n\t\t\t}.bind(this));\n\t\t} else {\n\t\t\tdeferred.reject({\n\t\t\t\tmessage : \"File not found in the epub: \" + url,\n\t\t\t\tstack : new Error().stack\n\t\t\t});\n\t\t}\n\t\treturn deferred.promise;\n\t}\n\n\t/**\n\t * Handle the response from request\n\t * @private\n\t * @param  {any} response\n\t * @param  {string} [type]\n\t * @return {any} the parsed result\n\t */\n\thandleResponse(response, type){\n\t\tvar r;\n\n\t\tif(type == \"json\") {\n\t\t\tr = JSON.parse(response);\n\t\t}\n\t\telse\n\t\tif(isXml(type)) {\n\t\t\tr = parse(response, \"text/xml\");\n\t\t}\n\t\telse\n\t\tif(type == \"xhtml\") {\n\t\t\tr = parse(response, \"application/xhtml+xml\");\n\t\t}\n\t\telse\n\t\tif(type == \"html\" || type == \"htm\") {\n\t\t\tr = parse(response, \"text/html\");\n\t\t } else {\n\t\t\t r = response;\n\t\t }\n\n\t\treturn r;\n\t}\n\n\t/**\n\t * Get a Blob from Archive by Url\n\t * @param  {string} url\n\t * @param  {string} [mimeType]\n\t * @return {Blob}\n\t */\n\tgetBlob(url, mimeType){\n\t\tvar decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n\t\tvar entry = this.zip.file(decodededUrl);\n\n\t\tif(entry) {\n\t\t\tmimeType = mimeType || mime.lookup(entry.name);\n\t\t\treturn entry.async(\"uint8array\").then(function(uint8array) {\n\t\t\t\treturn new Blob([uint8array], {type : mimeType});\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get Text from Archive by Url\n\t * @param  {string} url\n\t * @param  {string} [encoding]\n\t * @return {string}\n\t */\n\tgetText(url, encoding){\n\t\tvar decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n\t\tvar entry = this.zip.file(decodededUrl);\n\n\t\tif(entry) {\n\t\t\treturn entry.async(\"string\").then(function(text) {\n\t\t\t\treturn text;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get a base64 encoded result from Archive by Url\n\t * @param  {string} url\n\t * @param  {string} [mimeType]\n\t * @return {string} base64 encoded\n\t */\n\tgetBase64(url, mimeType){\n\t\tvar decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n\t\tvar entry = this.zip.file(decodededUrl);\n\n\t\tif(entry) {\n\t\t\tmimeType = mimeType || mime.lookup(entry.name);\n\t\t\treturn entry.async(\"base64\").then(function(data) {\n\t\t\t\treturn \"data:\" + mimeType + \";base64,\" + data;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create a Url from an unarchived item\n\t * @param  {string} url\n\t * @param  {object} [options.base64] use base64 encoding or blob url\n\t * @return {Promise} url promise with Url string\n\t */\n\tcreateUrl(url, options){\n\t\tvar deferred = new defer();\n\t\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\t\tvar tempUrl;\n\t\tvar response;\n\t\tvar useBase64 = options && options.base64;\n\n\t\tif(url in this.urlCache) {\n\t\t\tdeferred.resolve(this.urlCache[url]);\n\t\t\treturn deferred.promise;\n\t\t}\n\n\t\tif (useBase64) {\n\t\t\tresponse = this.getBase64(url);\n\n\t\t\tif (response) {\n\t\t\t\tresponse.then(function(tempUrl) {\n\n\t\t\t\t\tthis.urlCache[url] = tempUrl;\n\t\t\t\t\tdeferred.resolve(tempUrl);\n\n\t\t\t\t}.bind(this));\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tresponse = this.getBlob(url);\n\n\t\t\tif (response) {\n\t\t\t\tresponse.then(function(blob) {\n\n\t\t\t\t\ttempUrl = _URL.createObjectURL(blob);\n\t\t\t\t\tthis.urlCache[url] = tempUrl;\n\t\t\t\t\tdeferred.resolve(tempUrl);\n\n\t\t\t\t}.bind(this));\n\n\t\t\t}\n\t\t}\n\n\n\t\tif (!response) {\n\t\t\tdeferred.reject({\n\t\t\t\tmessage : \"File not found in the epub: \" + url,\n\t\t\t\tstack : new Error().stack\n\t\t\t});\n\t\t}\n\n\t\treturn deferred.promise;\n\t}\n\n\t/**\n\t * Revoke Temp Url for a archive item\n\t * @param  {string} url url of the item in the archive\n\t */\n\trevokeUrl(url){\n\t\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\t\tvar fromCache = this.urlCache[url];\n\t\tif(fromCache) _URL.revokeObjectURL(fromCache);\n\t}\n\n\tdestroy() {\n\t\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\t\tfor (let fromCache in this.urlCache) {\n\t\t\t_URL.revokeObjectURL(fromCache);\n\t\t}\n\t\tthis.zip = undefined;\n\t\tthis.urlCache = {};\n\t}\n}\n\nexport default Archive;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}