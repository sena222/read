{"ast":null,"code":"/**\n * Hooks allow for injecting functions that must all complete in order before finishing\n * They will execute in parallel but all must finish before continuing\n * Functions may return a promise if they are async.\n * @param {any} context scope of this\n * @example this.content = new EPUBJS.Hook(this);\n */\nclass Hook {\n  constructor(context) {\n    this.context = context || this;\n    this.hooks = [];\n  }\n\n  /**\n   * Adds a function to be run before a hook completes\n   * @example this.content.register(function(){...});\n   */\n  register() {\n    for (var i = 0; i < arguments.length; ++i) {\n      if (typeof arguments[i] === \"function\") {\n        this.hooks.push(arguments[i]);\n      } else {\n        // unpack array\n        for (var j = 0; j < arguments[i].length; ++j) {\n          this.hooks.push(arguments[i][j]);\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes a function\n   * @example this.content.deregister(function(){...});\n   */\n  deregister(func) {\n    let hook;\n    for (let i = 0; i < this.hooks.length; i++) {\n      hook = this.hooks[i];\n      if (hook === func) {\n        this.hooks.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Triggers a hook to run all functions\n   * @example this.content.trigger(args).then(function(){...});\n   */\n  trigger() {\n    var args = arguments;\n    var context = this.context;\n    var promises = [];\n    this.hooks.forEach(function (task) {\n      try {\n        var executing = task.apply(context, args);\n      } catch (err) {\n        console.log(err);\n      }\n      if (executing && typeof executing[\"then\"] === \"function\") {\n        // Task is a function that returns a promise\n        promises.push(executing);\n      }\n      // Otherwise Task resolves immediately, continue\n    });\n\n    return Promise.all(promises);\n  }\n\n  // Adds a function to be run before a hook completes\n  list() {\n    return this.hooks;\n  }\n  clear() {\n    return this.hooks = [];\n  }\n}\nexport default Hook;","map":{"version":3,"names":["Hook","constructor","context","hooks","register","i","arguments","length","push","j","deregister","func","hook","splice","trigger","args","promises","forEach","task","executing","apply","err","console","log","Promise","all","list","clear"],"sources":["/home/parallels/Downloads/react-epub-viewer-demo/node_modules/epubjs/src/utils/hook.js"],"sourcesContent":["/**\n * Hooks allow for injecting functions that must all complete in order before finishing\n * They will execute in parallel but all must finish before continuing\n * Functions may return a promise if they are async.\n * @param {any} context scope of this\n * @example this.content = new EPUBJS.Hook(this);\n */\nclass Hook {\n\tconstructor(context){\n\t\tthis.context = context || this;\n\t\tthis.hooks = [];\n\t}\n\n\t/**\n\t * Adds a function to be run before a hook completes\n\t * @example this.content.register(function(){...});\n\t */\n\tregister(){\n\t\tfor(var i = 0; i < arguments.length; ++i) {\n\t\t\tif (typeof arguments[i]  === \"function\") {\n\t\t\t\tthis.hooks.push(arguments[i]);\n\t\t\t} else {\n\t\t\t\t// unpack array\n\t\t\t\tfor(var j = 0; j < arguments[i].length; ++j) {\n\t\t\t\t\tthis.hooks.push(arguments[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes a function\n\t * @example this.content.deregister(function(){...});\n\t */\n\tderegister(func){\n\t\tlet hook;\n\t\tfor (let i = 0; i < this.hooks.length; i++) {\n\t\t\thook = this.hooks[i];\n\t\t\tif (hook === func) {\n\t\t\t\tthis.hooks.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Triggers a hook to run all functions\n\t * @example this.content.trigger(args).then(function(){...});\n\t */\n\ttrigger(){\n\t\tvar args = arguments;\n\t\tvar context = this.context;\n\t\tvar promises = [];\n\n\t\tthis.hooks.forEach(function(task) {\n\t\t\ttry {\n\t\t\t\tvar executing = task.apply(context, args);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\n\t\t\tif(executing && typeof executing[\"then\"] === \"function\") {\n\t\t\t\t// Task is a function that returns a promise\n\t\t\t\tpromises.push(executing);\n\t\t\t}\n\t\t\t// Otherwise Task resolves immediately, continue\n\t\t});\n\n\n\t\treturn Promise.all(promises);\n\t}\n\n\t// Adds a function to be run before a hook completes\n\tlist(){\n\t\treturn this.hooks;\n\t}\n\n\tclear(){\n\t\treturn this.hooks = [];\n\t}\n}\nexport default Hook;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,IAAI,CAAC;EACVC,WAAW,CAACC,OAAO,EAAC;IACnB,IAAI,CAACA,OAAO,GAAGA,OAAO,IAAI,IAAI;IAC9B,IAAI,CAACC,KAAK,GAAG,EAAE;EAChB;;EAEA;AACD;AACA;AACA;EACCC,QAAQ,GAAE;IACT,KAAI,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAE,EAAEF,CAAC,EAAE;MACzC,IAAI,OAAOC,SAAS,CAACD,CAAC,CAAC,KAAM,UAAU,EAAE;QACxC,IAAI,CAACF,KAAK,CAACK,IAAI,CAACF,SAAS,CAACD,CAAC,CAAC,CAAC;MAC9B,CAAC,MAAM;QACN;QACA,KAAI,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,CAACD,CAAC,CAAC,CAACE,MAAM,EAAE,EAAEE,CAAC,EAAE;UAC5C,IAAI,CAACN,KAAK,CAACK,IAAI,CAACF,SAAS,CAACD,CAAC,CAAC,CAACI,CAAC,CAAC,CAAC;QACjC;MACD;IACD;EACD;;EAEA;AACD;AACA;AACA;EACCC,UAAU,CAACC,IAAI,EAAC;IACf,IAAIC,IAAI;IACR,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACF,KAAK,CAACI,MAAM,EAAEF,CAAC,EAAE,EAAE;MAC3CO,IAAI,GAAG,IAAI,CAACT,KAAK,CAACE,CAAC,CAAC;MACpB,IAAIO,IAAI,KAAKD,IAAI,EAAE;QAClB,IAAI,CAACR,KAAK,CAACU,MAAM,CAACR,CAAC,EAAE,CAAC,CAAC;QACvB;MACD;IACD;EACD;;EAEA;AACD;AACA;AACA;EACCS,OAAO,GAAE;IACR,IAAIC,IAAI,GAAGT,SAAS;IACpB,IAAIJ,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B,IAAIc,QAAQ,GAAG,EAAE;IAEjB,IAAI,CAACb,KAAK,CAACc,OAAO,CAAC,UAASC,IAAI,EAAE;MACjC,IAAI;QACH,IAAIC,SAAS,GAAGD,IAAI,CAACE,KAAK,CAAClB,OAAO,EAAEa,IAAI,CAAC;MAC1C,CAAC,CAAC,OAAOM,GAAG,EAAE;QACbC,OAAO,CAACC,GAAG,CAACF,GAAG,CAAC;MACjB;MAEA,IAAGF,SAAS,IAAI,OAAOA,SAAS,CAAC,MAAM,CAAC,KAAK,UAAU,EAAE;QACxD;QACAH,QAAQ,CAACR,IAAI,CAACW,SAAS,CAAC;MACzB;MACA;IACD,CAAC,CAAC;;IAGF,OAAOK,OAAO,CAACC,GAAG,CAACT,QAAQ,CAAC;EAC7B;;EAEA;EACAU,IAAI,GAAE;IACL,OAAO,IAAI,CAACvB,KAAK;EAClB;EAEAwB,KAAK,GAAE;IACN,OAAO,IAAI,CAACxB,KAAK,GAAG,EAAE;EACvB;AACD;AACA,eAAeH,IAAI"},"metadata":{},"sourceType":"module"}