{"ast":null,"code":"'use strict';\n\nif (!process) {\n  var process = {\n    \"cwd\": function cwd() {\n      return '/';\n    }\n  };\n}\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + path);\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length) code = path.charCodeAt(i);else if (code === 47 /*/*/) break;else code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var start = res.length - 1;\n            var j = start;\n            for (; j >= 0; --j) {\n              if (res.charCodeAt(j) === 47 /*/*/) break;\n            }\n            if (j !== start) {\n              if (j === -1) res = '';else res = res.slice(0, j);\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) res += '/..';else res = '..';\n        }\n      } else {\n        if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);else res = path.slice(lastSlash + 1, i);\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0) path = arguments[i];else {\n        if (cwd === undefined) cwd = process.cwd();\n        path = cwd;\n      }\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0) return '/' + resolvedPath;else return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n  normalize: function normalize(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0) return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined) joined = arg;else joined += '/' + arg;\n      }\n    }\n    if (joined === undefined) return '.';\n    return posix.normalize(joined);\n  },\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n    if (from === to) return '';\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/) break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/) break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode) break;else if (fromCode === 47 /*/*/) lastCommonSep = i;\n    }\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0) out += '..';else out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/) ++toStart;\n      return to.slice(toStart);\n    }\n  },\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('Parameter \"pathObject\" must be an object, not ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n  parse: function parse(path) {\n    assertPath(path);\n    var ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n    return ret;\n  },\n  sep: '/',\n  delimiter: ':',\n  posix: null\n};\nmodule.exports = posix;","map":{"version":3,"names":["process","assertPath","path","TypeError","normalizeStringPosix","allowAboveRoot","res","lastSlash","dots","code","i","length","charCodeAt","start","j","slice","_format","sep","pathObject","dir","root","base","name","ext","posix","resolve","resolvedPath","resolvedAbsolute","cwd","arguments","undefined","normalize","isAbsolute","trailingSeparator","join","joined","arg","relative","from","to","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","toCode","out","_makeLong","dirname","hasRoot","end","matchedSlash","basename","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","parse","ret","delimiter","module","exports"],"sources":["/home/parallels/Downloads/read/node_modules/path-webpack/path.js"],"sourcesContent":["'use strict';\n\nif (!process) {\n  var process = {\n    \"cwd\" : function () { return '/' }\n  };\n}\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + path);\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47/*/*/)\n      break;\n    else\n      code = 47/*/*/;\n    if (code === 47/*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 ||\n            res.charCodeAt(res.length - 1) !== 46/*.*/ ||\n            res.charCodeAt(res.length - 2) !== 46/*.*/) {\n          if (res.length > 2) {\n            var start = res.length - 1;\n            var j = start;\n            for (; j >= 0; --j) {\n              if (res.charCodeAt(j) === 47/*/*/)\n                break;\n            }\n            if (j !== start) {\n              if (j === -1)\n                res = '';\n              else\n                res = res.slice(0, j);\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46/*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base ||\n    ((pathObject.name || '') + (pathObject.ext || ''));\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47/*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0)\n      return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47/*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47/*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute)\n      path = '.';\n    if (path.length > 0 && trailingSeparator)\n      path += '/';\n\n    if (isAbsolute)\n      return '/' + path;\n    return path;\n  },\n\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47/*/*/;\n  },\n\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to)\n      return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47/*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = (fromEnd - fromStart);\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47/*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = (toEnd - toStart);\n\n    // Compare paths to find the longest common path from root\n    var length = (fromLen < toLen ? fromLen : toLen);\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47/*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47/*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47/*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47/*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47/*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0)\n      return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = (code === 47/*/*/);\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return path.slice(0, end);\n  },\n\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string')\n      throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path)\n        return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47/*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47/*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1)\n        return '';\n      return path.slice(start, end);\n    }\n  },\n\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47/*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError(\n        'Parameter \"pathObject\" must be an object, not ' + typeof(pathObject)\n      );\n    }\n    return _format('/', pathObject);\n  },\n\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = (code === 47/*/*/);\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path.slice(1, end);\n        else\n          ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0)\n      ret.dir = path.slice(0, startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  },\n\n\n  sep: '/',\n  delimiter: ':',\n  posix: null\n};\n\n\nmodule.exports = posix;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}