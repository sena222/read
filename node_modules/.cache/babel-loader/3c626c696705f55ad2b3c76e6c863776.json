{"ast":null,"code":"import { qs, sprint, locationOf, defer } from \"./utils/core\";\nimport Queue from \"./utils/queue\";\nimport EpubCFI from \"./epubcfi\";\nimport { EVENTS } from \"./utils/constants\";\nimport EventEmitter from \"event-emitter\";\n\n/**\n * Find Locations for a Book\n * @param {Spine} spine\n * @param {request} request\n * @param {number} [pause=100]\n */\nclass Locations {\n  constructor(spine, request, pause) {\n    this.spine = spine;\n    this.request = request;\n    this.pause = pause || 100;\n    this.q = new Queue(this);\n    this.epubcfi = new EpubCFI();\n    this._locations = [];\n    this._locationsWords = [];\n    this.total = 0;\n    this.break = 150;\n    this._current = 0;\n    this._wordCounter = 0;\n    this.currentLocation = '';\n    this._currentCfi = '';\n    this.processingTimeout = undefined;\n  }\n\n  /**\n   * Load all of sections in the book to generate locations\n   * @param  {int} chars how many chars to split on\n   * @return {Promise<Array<string>>} locations\n   */\n  generate(chars) {\n    if (chars) {\n      this.break = chars;\n    }\n    this.q.pause();\n    this.spine.each(function (section) {\n      if (section.linear) {\n        this.q.enqueue(this.process.bind(this), section);\n      }\n    }.bind(this));\n    return this.q.run().then(function () {\n      this.total = this._locations.length - 1;\n      if (this._currentCfi) {\n        this.currentLocation = this._currentCfi;\n      }\n      return this._locations;\n      // console.log(this.percentage(this.book.rendition.location.start), this.percentage(this.book.rendition.location.end));\n    }.bind(this));\n  }\n  createRange() {\n    return {\n      startContainer: undefined,\n      startOffset: undefined,\n      endContainer: undefined,\n      endOffset: undefined\n    };\n  }\n  process(section) {\n    return section.load(this.request).then(function (contents) {\n      var completed = new defer();\n      var locations = this.parse(contents, section.cfiBase);\n      this._locations = this._locations.concat(locations);\n      section.unload();\n      this.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);\n      return completed.promise;\n    }.bind(this));\n  }\n  parse(contents, cfiBase, chars) {\n    var locations = [];\n    var range;\n    var doc = contents.ownerDocument;\n    var body = qs(doc, \"body\");\n    var counter = 0;\n    var prev;\n    var _break = chars || this.break;\n    var parser = function (node) {\n      var len = node.length;\n      var dist;\n      var pos = 0;\n      if (node.textContent.trim().length === 0) {\n        return false; // continue\n      }\n\n      // Start range\n      if (counter == 0) {\n        range = this.createRange();\n        range.startContainer = node;\n        range.startOffset = 0;\n      }\n      dist = _break - counter;\n\n      // Node is smaller than a break,\n      // skip over it\n      if (dist > len) {\n        counter += len;\n        pos = len;\n      }\n      while (pos < len) {\n        dist = _break - counter;\n        if (counter === 0) {\n          // Start new range\n          pos += 1;\n          range = this.createRange();\n          range.startContainer = node;\n          range.startOffset = pos;\n        }\n\n        // pos += dist;\n\n        // Gone over\n        if (pos + dist >= len) {\n          // Continue counter for next node\n          counter += len - pos;\n          // break\n          pos = len;\n          // At End\n        } else {\n          // Advance pos\n          pos += dist;\n\n          // End the previous range\n          range.endContainer = node;\n          range.endOffset = pos;\n          // cfi = section.cfiFromRange(range);\n          let cfi = new EpubCFI(range, cfiBase).toString();\n          locations.push(cfi);\n          counter = 0;\n        }\n      }\n      prev = node;\n    };\n    sprint(body, parser.bind(this));\n\n    // Close remaining\n    if (range && range.startContainer && prev) {\n      range.endContainer = prev;\n      range.endOffset = prev.length;\n      let cfi = new EpubCFI(range, cfiBase).toString();\n      locations.push(cfi);\n      counter = 0;\n    }\n    return locations;\n  }\n\n  /**\n   * Load all of sections in the book to generate locations\n   * @param  {string} startCfi start position\n   * @param  {int} wordCount how many words to split on\n   * @param  {int} count result count\n   * @return {object} locations\n   */\n  generateFromWords(startCfi, wordCount, count) {\n    var start = startCfi ? new EpubCFI(startCfi) : undefined;\n    this.q.pause();\n    this._locationsWords = [];\n    this._wordCounter = 0;\n    this.spine.each(function (section) {\n      if (section.linear) {\n        if (start) {\n          if (section.index >= start.spinePos) {\n            this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n          }\n        } else {\n          this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n        }\n      }\n    }.bind(this));\n    return this.q.run().then(function () {\n      if (this._currentCfi) {\n        this.currentLocation = this._currentCfi;\n      }\n      return this._locationsWords;\n    }.bind(this));\n  }\n  processWords(section, wordCount, startCfi, count) {\n    if (count && this._locationsWords.length >= count) {\n      return Promise.resolve();\n    }\n    return section.load(this.request).then(function (contents) {\n      var completed = new defer();\n      var locations = this.parseWords(contents, section, wordCount, startCfi);\n      var remainingCount = count - this._locationsWords.length;\n      this._locationsWords = this._locationsWords.concat(locations.length >= count ? locations.slice(0, remainingCount) : locations);\n      section.unload();\n      this.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);\n      return completed.promise;\n    }.bind(this));\n  }\n\n  //http://stackoverflow.com/questions/18679576/counting-words-in-string\n  countWords(s) {\n    s = s.replace(/(^\\s*)|(\\s*$)/gi, \"\"); //exclude  start and end white-space\n    s = s.replace(/[ ]{2,}/gi, \" \"); //2 or more space to 1\n    s = s.replace(/\\n /, \"\\n\"); // exclude newline with a start spacing\n    return s.split(\" \").length;\n  }\n  parseWords(contents, section, wordCount, startCfi) {\n    var cfiBase = section.cfiBase;\n    var locations = [];\n    var doc = contents.ownerDocument;\n    var body = qs(doc, \"body\");\n    var prev;\n    var _break = wordCount;\n    var foundStartNode = startCfi ? startCfi.spinePos !== section.index : true;\n    var startNode;\n    if (startCfi && section.index === startCfi.spinePos) {\n      startNode = startCfi.findNode(startCfi.range ? startCfi.path.steps.concat(startCfi.start.steps) : startCfi.path.steps, contents.ownerDocument);\n    }\n    var parser = function (node) {\n      if (!foundStartNode) {\n        if (node === startNode) {\n          foundStartNode = true;\n        } else {\n          return false;\n        }\n      }\n      if (node.textContent.length < 10) {\n        if (node.textContent.trim().length === 0) {\n          return false;\n        }\n      }\n      var len = this.countWords(node.textContent);\n      var dist;\n      var pos = 0;\n      if (len === 0) {\n        return false; // continue\n      }\n\n      dist = _break - this._wordCounter;\n\n      // Node is smaller than a break,\n      // skip over it\n      if (dist > len) {\n        this._wordCounter += len;\n        pos = len;\n      }\n      while (pos < len) {\n        dist = _break - this._wordCounter;\n\n        // Gone over\n        if (pos + dist >= len) {\n          // Continue counter for next node\n          this._wordCounter += len - pos;\n          // break\n          pos = len;\n          // At End\n        } else {\n          // Advance pos\n          pos += dist;\n          let cfi = new EpubCFI(node, cfiBase);\n          locations.push({\n            cfi: cfi.toString(),\n            wordCount: this._wordCounter\n          });\n          this._wordCounter = 0;\n        }\n      }\n      prev = node;\n    };\n    sprint(body, parser.bind(this));\n    return locations;\n  }\n\n  /**\n   * Get a location from an EpubCFI\n   * @param {EpubCFI} cfi\n   * @return {number}\n   */\n  locationFromCfi(cfi) {\n    let loc;\n    if (EpubCFI.prototype.isCfiString(cfi)) {\n      cfi = new EpubCFI(cfi);\n    }\n    // Check if the location has not been set yet\n    if (this._locations.length === 0) {\n      return -1;\n    }\n    loc = locationOf(cfi, this._locations, this.epubcfi.compare);\n    if (loc > this.total) {\n      return this.total;\n    }\n    return loc;\n  }\n\n  /**\n   * Get a percentage position in locations from an EpubCFI\n   * @param {EpubCFI} cfi\n   * @return {number}\n   */\n  percentageFromCfi(cfi) {\n    if (this._locations.length === 0) {\n      return null;\n    }\n    // Find closest cfi\n    var loc = this.locationFromCfi(cfi);\n    // Get percentage in total\n    return this.percentageFromLocation(loc);\n  }\n\n  /**\n   * Get a percentage position from a location index\n   * @param {number} location\n   * @return {number}\n   */\n  percentageFromLocation(loc) {\n    if (!loc || !this.total) {\n      return 0;\n    }\n    return loc / this.total;\n  }\n\n  /**\n   * Get an EpubCFI from location index\n   * @param {number} loc\n   * @return {EpubCFI} cfi\n   */\n  cfiFromLocation(loc) {\n    var cfi = -1;\n    // check that pg is an int\n    if (typeof loc != \"number\") {\n      loc = parseInt(loc);\n    }\n    if (loc >= 0 && loc < this._locations.length) {\n      cfi = this._locations[loc];\n    }\n    return cfi;\n  }\n\n  /**\n   * Get an EpubCFI from location percentage\n   * @param {number} percentage\n   * @return {EpubCFI} cfi\n   */\n  cfiFromPercentage(percentage) {\n    let loc;\n    if (percentage > 1) {\n      console.warn(\"Normalize cfiFromPercentage value to between 0 - 1\");\n    }\n\n    // Make sure 1 goes to very end\n    if (percentage >= 1) {\n      let cfi = new EpubCFI(this._locations[this.total]);\n      cfi.collapse();\n      return cfi.toString();\n    }\n    loc = Math.ceil(this.total * percentage);\n    return this.cfiFromLocation(loc);\n  }\n\n  /**\n   * Load locations from JSON\n   * @param {json} locations\n   */\n  load(locations) {\n    if (typeof locations === \"string\") {\n      this._locations = JSON.parse(locations);\n    } else {\n      this._locations = locations;\n    }\n    this.total = this._locations.length - 1;\n    return this._locations;\n  }\n\n  /**\n   * Save locations to JSON\n   * @return {json}\n   */\n  save() {\n    return JSON.stringify(this._locations);\n  }\n  getCurrent() {\n    return this._current;\n  }\n  setCurrent(curr) {\n    var loc;\n    if (typeof curr == \"string\") {\n      this._currentCfi = curr;\n    } else if (typeof curr == \"number\") {\n      this._current = curr;\n    } else {\n      return;\n    }\n    if (this._locations.length === 0) {\n      return;\n    }\n    if (typeof curr == \"string\") {\n      loc = this.locationFromCfi(curr);\n      this._current = loc;\n    } else {\n      loc = curr;\n    }\n    this.emit(EVENTS.LOCATIONS.CHANGED, {\n      percentage: this.percentageFromLocation(loc)\n    });\n  }\n\n  /**\n   * Get the current location\n   */\n  get currentLocation() {\n    return this._current;\n  }\n\n  /**\n   * Set the current location\n   */\n  set currentLocation(curr) {\n    this.setCurrent(curr);\n  }\n\n  /**\n   * Locations length\n   */\n  length() {\n    return this._locations.length;\n  }\n  destroy() {\n    this.spine = undefined;\n    this.request = undefined;\n    this.pause = undefined;\n    this.q.stop();\n    this.q = undefined;\n    this.epubcfi = undefined;\n    this._locations = undefined;\n    this.total = undefined;\n    this.break = undefined;\n    this._current = undefined;\n    this.currentLocation = undefined;\n    this._currentCfi = undefined;\n    clearTimeout(this.processingTimeout);\n  }\n}\nEventEmitter(Locations.prototype);\nexport default Locations;","map":{"version":3,"names":["qs","sprint","locationOf","defer","Queue","EpubCFI","EVENTS","EventEmitter","Locations","constructor","spine","request","pause","q","epubcfi","_locations","_locationsWords","total","break","_current","_wordCounter","currentLocation","_currentCfi","processingTimeout","undefined","generate","chars","each","section","linear","enqueue","process","bind","run","then","length","createRange","startContainer","startOffset","endContainer","endOffset","load","contents","completed","locations","parse","cfiBase","concat","unload","setTimeout","resolve","promise","range","doc","ownerDocument","body","counter","prev","_break","parser","node","len","dist","pos","textContent","trim","cfi","toString","push","generateFromWords","startCfi","wordCount","count","start","index","spinePos","processWords","Promise","parseWords","remainingCount","slice","countWords","s","replace","split","foundStartNode","startNode","findNode","path","steps","locationFromCfi","loc","prototype","isCfiString","compare","percentageFromCfi","percentageFromLocation","cfiFromLocation","parseInt","cfiFromPercentage","percentage","console","warn","collapse","Math","ceil","JSON","save","stringify","getCurrent","setCurrent","curr","emit","LOCATIONS","CHANGED","destroy","stop","clearTimeout"],"sources":["/home/parallels/Downloads/react-epub-viewer-demo/node_modules/epubjs/src/locations.js"],"sourcesContent":["import {qs, sprint, locationOf, defer} from \"./utils/core\";\nimport Queue from \"./utils/queue\";\nimport EpubCFI from \"./epubcfi\";\nimport { EVENTS } from \"./utils/constants\";\nimport EventEmitter from \"event-emitter\";\n\n/**\n * Find Locations for a Book\n * @param {Spine} spine\n * @param {request} request\n * @param {number} [pause=100]\n */\nclass Locations {\n\tconstructor(spine, request, pause) {\n\t\tthis.spine = spine;\n\t\tthis.request = request;\n\t\tthis.pause = pause || 100;\n\n\t\tthis.q = new Queue(this);\n\t\tthis.epubcfi = new EpubCFI();\n\n\t\tthis._locations = [];\n\t\tthis._locationsWords = [];\n\t\tthis.total = 0;\n\n\t\tthis.break = 150;\n\n\t\tthis._current = 0;\n\n\t\tthis._wordCounter = 0;\n\n\t\tthis.currentLocation = '';\n\t\tthis._currentCfi ='';\n\t\tthis.processingTimeout = undefined;\n\t}\n\n\t/**\n\t * Load all of sections in the book to generate locations\n\t * @param  {int} chars how many chars to split on\n\t * @return {Promise<Array<string>>} locations\n\t */\n\tgenerate(chars) {\n\n\t\tif (chars) {\n\t\t\tthis.break = chars;\n\t\t}\n\n\t\tthis.q.pause();\n\n\t\tthis.spine.each(function(section) {\n\t\t\tif (section.linear) {\n\t\t\t\tthis.q.enqueue(this.process.bind(this), section);\n\t\t\t}\n\t\t}.bind(this));\n\n\t\treturn this.q.run().then(function() {\n\t\t\tthis.total = this._locations.length - 1;\n\n\t\t\tif (this._currentCfi) {\n\t\t\t\tthis.currentLocation = this._currentCfi;\n\t\t\t}\n\n\t\t\treturn this._locations;\n\t\t\t// console.log(this.percentage(this.book.rendition.location.start), this.percentage(this.book.rendition.location.end));\n\t\t}.bind(this));\n\n\t}\n\n\tcreateRange () {\n\t\treturn {\n\t\t\tstartContainer: undefined,\n\t\t\tstartOffset: undefined,\n\t\t\tendContainer: undefined,\n\t\t\tendOffset: undefined\n\t\t};\n\t}\n\n\tprocess(section) {\n\n\t\treturn section.load(this.request)\n\t\t\t.then(function(contents) {\n\t\t\t\tvar completed = new defer();\n\t\t\t\tvar locations = this.parse(contents, section.cfiBase);\n\t\t\t\tthis._locations = this._locations.concat(locations);\n\n\t\t\t\tsection.unload();\n\n\t\t\t\tthis.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);\n\t\t\t\treturn completed.promise;\n\t\t\t}.bind(this));\n\n\t}\n\n\tparse(contents, cfiBase, chars) {\n\t\tvar locations = [];\n\t\tvar range;\n\t\tvar doc = contents.ownerDocument;\n\t\tvar body = qs(doc, \"body\");\n\t\tvar counter = 0;\n\t\tvar prev;\n\t\tvar _break = chars || this.break;\n\t\tvar parser = function(node) {\n\t\t\tvar len = node.length;\n\t\t\tvar dist;\n\t\t\tvar pos = 0;\n\n\t\t\tif (node.textContent.trim().length === 0) {\n\t\t\t\treturn false; // continue\n\t\t\t}\n\n\t\t\t// Start range\n\t\t\tif (counter == 0) {\n\t\t\t\trange = this.createRange();\n\t\t\t\trange.startContainer = node;\n\t\t\t\trange.startOffset = 0;\n\t\t\t}\n\n\t\t\tdist = _break - counter;\n\n\t\t\t// Node is smaller than a break,\n\t\t\t// skip over it\n\t\t\tif(dist > len){\n\t\t\t\tcounter += len;\n\t\t\t\tpos = len;\n\t\t\t}\n\n\n\t\t\twhile (pos < len) {\n\t\t\t\tdist = _break - counter;\n\n\t\t\t\tif (counter === 0) {\n\t\t\t\t\t// Start new range\n\t\t\t\t\tpos += 1;\n\t\t\t\t\trange = this.createRange();\n\t\t\t\t\trange.startContainer = node;\n\t\t\t\t\trange.startOffset = pos;\n\t\t\t\t}\n\n\t\t\t\t// pos += dist;\n\n\t\t\t\t// Gone over\n\t\t\t\tif(pos + dist >= len){\n\t\t\t\t\t// Continue counter for next node\n\t\t\t\t\tcounter += len - pos;\n\t\t\t\t\t// break\n\t\t\t\t\tpos = len;\n\t\t\t\t// At End\n\t\t\t\t} else {\n\t\t\t\t\t// Advance pos\n\t\t\t\t\tpos += dist;\n\n\t\t\t\t\t// End the previous range\n\t\t\t\t\trange.endContainer = node;\n\t\t\t\t\trange.endOffset = pos;\n\t\t\t\t\t// cfi = section.cfiFromRange(range);\n\t\t\t\t\tlet cfi = new EpubCFI(range, cfiBase).toString();\n\t\t\t\t\tlocations.push(cfi);\n\t\t\t\t\tcounter = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = node;\n\t\t};\n\n\t\tsprint(body, parser.bind(this));\n\n\t\t// Close remaining\n\t\tif (range && range.startContainer && prev) {\n\t\t\trange.endContainer = prev;\n\t\t\trange.endOffset = prev.length;\n\t\t\tlet cfi = new EpubCFI(range, cfiBase).toString();\n\t\t\tlocations.push(cfi);\n\t\t\tcounter = 0;\n\t\t}\n\n\t\treturn locations;\n\t}\n\n\n\t/**\n\t * Load all of sections in the book to generate locations\n\t * @param  {string} startCfi start position\n\t * @param  {int} wordCount how many words to split on\n\t * @param  {int} count result count\n\t * @return {object} locations\n\t */\n\tgenerateFromWords(startCfi, wordCount, count) {\n\t\tvar start = startCfi ? new EpubCFI(startCfi) : undefined;\n\t\tthis.q.pause();\n\t\tthis._locationsWords = [];\n\t\tthis._wordCounter = 0;\n\n\t\tthis.spine.each(function(section) {\n\t\t\tif (section.linear) {\n\t\t\t\tif (start) {\n\t\t\t\t\tif (section.index >= start.spinePos) {\n\t\t\t\t\t\tthis.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this));\n\n\t\treturn this.q.run().then(function() {\n\t\t\tif (this._currentCfi) {\n\t\t\t\tthis.currentLocation = this._currentCfi;\n\t\t\t}\n\n\t\t\treturn this._locationsWords;\n\t\t}.bind(this));\n\n\t}\n\n\tprocessWords(section, wordCount, startCfi, count) {\n\t\tif (count && this._locationsWords.length >= count) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn section.load(this.request)\n\t\t\t.then(function(contents) {\n\t\t\t\tvar completed = new defer();\n\t\t\t\tvar locations = this.parseWords(contents, section, wordCount, startCfi);\n\t\t\t\tvar remainingCount = count - this._locationsWords.length;\n\t\t\t\tthis._locationsWords = this._locationsWords.concat(locations.length >= count ? locations.slice(0, remainingCount) : locations);\n\n\t\t\t\tsection.unload();\n\n\t\t\t\tthis.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);\n\t\t\t\treturn completed.promise;\n\t\t\t}.bind(this));\n\t}\n\n\t//http://stackoverflow.com/questions/18679576/counting-words-in-string\n\tcountWords(s) {\n\t\ts = s.replace(/(^\\s*)|(\\s*$)/gi, \"\");//exclude  start and end white-space\n\t\ts = s.replace(/[ ]{2,}/gi, \" \");//2 or more space to 1\n\t\ts = s.replace(/\\n /, \"\\n\"); // exclude newline with a start spacing\n\t\treturn s.split(\" \").length;\n\t}\n\n\tparseWords(contents, section, wordCount, startCfi) {\n\t\tvar cfiBase = section.cfiBase;\n\t\tvar locations = [];\n\t\tvar doc = contents.ownerDocument;\n\t\tvar body = qs(doc, \"body\");\n\t\tvar prev;\n\t\tvar _break = wordCount;\n\t\tvar foundStartNode = startCfi ? startCfi.spinePos !== section.index : true;\n\t\tvar startNode;\n\t\tif (startCfi && section.index === startCfi.spinePos) {\n\t\t\tstartNode = startCfi.findNode(startCfi.range ? startCfi.path.steps.concat(startCfi.start.steps) : startCfi.path.steps, contents.ownerDocument);\n\t\t}\n\t\tvar parser = function(node) {\n\t\t\tif (!foundStartNode) {\n\t\t\t\tif (node === startNode) {\n\t\t\t\t\tfoundStartNode = true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.textContent.length < 10) {\n\t\t\t\tif (node.textContent.trim().length === 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar len  = this.countWords(node.textContent);\n\t\t\tvar dist;\n\t\t\tvar pos = 0;\n\n\t\t\tif (len === 0) {\n\t\t\t\treturn false; // continue\n\t\t\t}\n\n\t\t\tdist = _break - this._wordCounter;\n\n\t\t\t// Node is smaller than a break,\n\t\t\t// skip over it\n\t\t\tif (dist > len) {\n\t\t\t\tthis._wordCounter += len;\n\t\t\t\tpos = len;\n\t\t\t}\n\n\n\t\t\twhile (pos < len) {\n\t\t\t\tdist = _break - this._wordCounter;\n\n\t\t\t\t// Gone over\n\t\t\t\tif (pos + dist >= len) {\n\t\t\t\t\t// Continue counter for next node\n\t\t\t\t\tthis._wordCounter += len - pos;\n\t\t\t\t\t// break\n\t\t\t\t\tpos = len;\n\t\t\t\t\t// At End\n\t\t\t\t} else {\n\t\t\t\t\t// Advance pos\n\t\t\t\t\tpos += dist;\n\n\t\t\t\t\tlet cfi = new EpubCFI(node, cfiBase);\n\t\t\t\t\tlocations.push({ cfi: cfi.toString(), wordCount: this._wordCounter });\n\t\t\t\t\tthis._wordCounter = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = node;\n\t\t};\n\n\t\tsprint(body, parser.bind(this));\n\n\t\treturn locations;\n\t}\n\n\t/**\n\t * Get a location from an EpubCFI\n\t * @param {EpubCFI} cfi\n\t * @return {number}\n\t */\n\tlocationFromCfi(cfi){\n\t\tlet loc;\n\t\tif (EpubCFI.prototype.isCfiString(cfi)) {\n\t\t\tcfi = new EpubCFI(cfi);\n\t\t}\n\t\t// Check if the location has not been set yet\n\t\tif(this._locations.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tloc = locationOf(cfi, this._locations, this.epubcfi.compare);\n\n\t\tif (loc > this.total) {\n\t\t\treturn this.total;\n\t\t}\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * Get a percentage position in locations from an EpubCFI\n\t * @param {EpubCFI} cfi\n\t * @return {number}\n\t */\n\tpercentageFromCfi(cfi) {\n\t\tif(this._locations.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\t// Find closest cfi\n\t\tvar loc = this.locationFromCfi(cfi);\n\t\t// Get percentage in total\n\t\treturn this.percentageFromLocation(loc);\n\t}\n\n\t/**\n\t * Get a percentage position from a location index\n\t * @param {number} location\n\t * @return {number}\n\t */\n\tpercentageFromLocation(loc) {\n\t\tif (!loc || !this.total) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (loc / this.total);\n\t}\n\n\t/**\n\t * Get an EpubCFI from location index\n\t * @param {number} loc\n\t * @return {EpubCFI} cfi\n\t */\n\tcfiFromLocation(loc){\n\t\tvar cfi = -1;\n\t\t// check that pg is an int\n\t\tif(typeof loc != \"number\"){\n\t\t\tloc = parseInt(loc);\n\t\t}\n\n\t\tif(loc >= 0 && loc < this._locations.length) {\n\t\t\tcfi = this._locations[loc];\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Get an EpubCFI from location percentage\n\t * @param {number} percentage\n\t * @return {EpubCFI} cfi\n\t */\n\tcfiFromPercentage(percentage){\n\t\tlet loc;\n\t\tif (percentage > 1) {\n\t\t\tconsole.warn(\"Normalize cfiFromPercentage value to between 0 - 1\");\n\t\t}\n\n\t\t// Make sure 1 goes to very end\n\t\tif (percentage >= 1) {\n\t\t\tlet cfi = new EpubCFI(this._locations[this.total]);\n\t\t\tcfi.collapse();\n\t\t\treturn cfi.toString();\n\t\t}\n\n\t\tloc = Math.ceil(this.total * percentage);\n\t\treturn this.cfiFromLocation(loc);\n\t}\n\n\t/**\n\t * Load locations from JSON\n\t * @param {json} locations\n\t */\n\tload(locations){\n\t\tif (typeof locations === \"string\") {\n\t\t\tthis._locations = JSON.parse(locations);\n\t\t} else {\n\t\t\tthis._locations = locations;\n\t\t}\n\t\tthis.total = this._locations.length - 1;\n\t\treturn this._locations;\n\t}\n\n\t/**\n\t * Save locations to JSON\n\t * @return {json}\n\t */\n\tsave(){\n\t\treturn JSON.stringify(this._locations);\n\t}\n\n\tgetCurrent(){\n\t\treturn this._current;\n\t}\n\n\tsetCurrent(curr){\n\t\tvar loc;\n\n\t\tif(typeof curr == \"string\"){\n\t\t\tthis._currentCfi = curr;\n\t\t} else if (typeof curr == \"number\") {\n\t\t\tthis._current = curr;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tif(this._locations.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(typeof curr == \"string\"){\n\t\t\tloc = this.locationFromCfi(curr);\n\t\t\tthis._current = loc;\n\t\t} else {\n\t\t\tloc = curr;\n\t\t}\n\n\t\tthis.emit(EVENTS.LOCATIONS.CHANGED, {\n\t\t\tpercentage: this.percentageFromLocation(loc)\n\t\t});\n\t}\n\n\t/**\n\t * Get the current location\n\t */\n\tget currentLocation() {\n\t\treturn this._current;\n\t}\n\n\t/**\n\t * Set the current location\n\t */\n\tset currentLocation(curr) {\n\t\tthis.setCurrent(curr);\n\t}\n\n\t/**\n\t * Locations length\n\t */\n\tlength () {\n\t\treturn this._locations.length;\n\t}\n\n\tdestroy () {\n\t\tthis.spine = undefined;\n\t\tthis.request = undefined;\n\t\tthis.pause = undefined;\n\n\t\tthis.q.stop();\n\t\tthis.q = undefined;\n\t\tthis.epubcfi = undefined;\n\n\t\tthis._locations = undefined\n\t\tthis.total = undefined;\n\n\t\tthis.break = undefined;\n\t\tthis._current = undefined;\n\n\t\tthis.currentLocation = undefined;\n\t\tthis._currentCfi = undefined;\n\t\tclearTimeout(this.processingTimeout);\n\t}\n}\n\nEventEmitter(Locations.prototype);\n\nexport default Locations;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}