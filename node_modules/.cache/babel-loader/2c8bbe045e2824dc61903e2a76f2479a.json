{"ast":null,"code":"import EpubCFI from \"./epubcfi\";\nimport { nodeBounds } from \"./utils/core\";\n\n/**\n * Map text locations to CFI ranges\n * @class\n * @param {Layout} layout Layout to apply\n * @param {string} [direction=\"ltr\"] Text direction\n * @param {string} [axis=\"horizontal\"] vertical or horizontal axis\n * @param {boolean} [dev] toggle developer highlighting\n */\nclass Mapping {\n  constructor(layout, direction, axis) {\n    let dev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    this.layout = layout;\n    this.horizontal = axis === \"horizontal\" ? true : false;\n    this.direction = direction || \"ltr\";\n    this._dev = dev;\n  }\n\n  /**\n   * Find CFI pairs for entire section at once\n   */\n  section(view) {\n    var ranges = this.findRanges(view);\n    var map = this.rangeListToCfiList(view.section.cfiBase, ranges);\n    return map;\n  }\n\n  /**\n   * Find CFI pairs for a page\n   * @param {Contents} contents Contents from view\n   * @param {string} cfiBase string of the base for a cfi\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   */\n  page(contents, cfiBase, start, end) {\n    var root = contents && contents.document ? contents.document.body : false;\n    var result;\n    if (!root) {\n      return;\n    }\n    result = this.rangePairToCfiPair(cfiBase, {\n      start: this.findStart(root, start, end),\n      end: this.findEnd(root, start, end)\n    });\n    if (this._dev === true) {\n      let doc = contents.document;\n      let startRange = new EpubCFI(result.start).toRange(doc);\n      let endRange = new EpubCFI(result.end).toRange(doc);\n      let selection = doc.defaultView.getSelection();\n      let r = doc.createRange();\n      selection.removeAllRanges();\n      r.setStart(startRange.startContainer, startRange.startOffset);\n      r.setEnd(endRange.endContainer, endRange.endOffset);\n      selection.addRange(r);\n    }\n    return result;\n  }\n\n  /**\n   * Walk a node, preforming a function on each node it finds\n   * @private\n   * @param {Node} root Node to walkToNode\n   * @param {function} func walk function\n   * @return {*} returns the result of the walk function\n   */\n  walk(root, func) {\n    // IE11 has strange issue, if root is text node IE throws exception on\n    // calling treeWalker.nextNode(), saying\n    // Unexpected call to method or property access instead of returning null value\n    if (root && root.nodeType === Node.TEXT_NODE) {\n      return;\n    }\n    // safeFilter is required so that it can work in IE as filter is a function for IE\n    // and for other browser filter is an object.\n    var filter = {\n      acceptNode: function (node) {\n        if (node.data.trim().length > 0) {\n          return NodeFilter.FILTER_ACCEPT;\n        } else {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n    };\n    var safeFilter = filter.acceptNode;\n    safeFilter.acceptNode = filter.acceptNode;\n    var treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, safeFilter, false);\n    var node;\n    var result;\n    while (node = treeWalker.nextNode()) {\n      result = func(node);\n      if (result) break;\n    }\n    return result;\n  }\n  findRanges(view) {\n    var columns = [];\n    var scrollWidth = view.contents.scrollWidth();\n    var spreads = Math.ceil(scrollWidth / this.layout.spreadWidth);\n    var count = spreads * this.layout.divisor;\n    var columnWidth = this.layout.columnWidth;\n    var gap = this.layout.gap;\n    var start, end;\n    for (var i = 0; i < count.pages; i++) {\n      start = (columnWidth + gap) * i;\n      end = columnWidth * (i + 1) + gap * i;\n      columns.push({\n        start: this.findStart(view.document.body, start, end),\n        end: this.findEnd(view.document.body, start, end)\n      });\n    }\n    return columns;\n  }\n\n  /**\n   * Find Start Range\n   * @private\n   * @param {Node} root root node\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   * @return {Range}\n   */\n  findStart(root, start, end) {\n    var stack = [root];\n    var $el;\n    var found;\n    var $prev = root;\n    while (stack.length) {\n      $el = stack.shift();\n      found = this.walk($el, node => {\n        var left, right, top, bottom;\n        var elPos;\n        var elRange;\n        elPos = nodeBounds(node);\n        if (this.horizontal && this.direction === \"ltr\") {\n          left = this.horizontal ? elPos.left : elPos.top;\n          right = this.horizontal ? elPos.right : elPos.bottom;\n          if (left >= start && left <= end) {\n            return node;\n          } else if (right > start) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        } else if (this.horizontal && this.direction === \"rtl\") {\n          left = elPos.left;\n          right = elPos.right;\n          if (right <= end && right >= start) {\n            return node;\n          } else if (left < end) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        } else {\n          top = elPos.top;\n          bottom = elPos.bottom;\n          if (top >= start && top <= end) {\n            return node;\n          } else if (bottom > start) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        }\n      });\n      if (found) {\n        return this.findTextStartRange(found, start, end);\n      }\n    }\n\n    // Return last element\n    return this.findTextStartRange($prev, start, end);\n  }\n\n  /**\n   * Find End Range\n   * @private\n   * @param {Node} root root node\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   * @return {Range}\n   */\n  findEnd(root, start, end) {\n    var stack = [root];\n    var $el;\n    var $prev = root;\n    var found;\n    while (stack.length) {\n      $el = stack.shift();\n      found = this.walk($el, node => {\n        var left, right, top, bottom;\n        var elPos;\n        var elRange;\n        elPos = nodeBounds(node);\n        if (this.horizontal && this.direction === \"ltr\") {\n          left = Math.round(elPos.left);\n          right = Math.round(elPos.right);\n          if (left > end && $prev) {\n            return $prev;\n          } else if (right > end) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        } else if (this.horizontal && this.direction === \"rtl\") {\n          left = Math.round(this.horizontal ? elPos.left : elPos.top);\n          right = Math.round(this.horizontal ? elPos.right : elPos.bottom);\n          if (right < start && $prev) {\n            return $prev;\n          } else if (left < start) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        } else {\n          top = Math.round(elPos.top);\n          bottom = Math.round(elPos.bottom);\n          if (top > end && $prev) {\n            return $prev;\n          } else if (bottom > end) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        }\n      });\n      if (found) {\n        return this.findTextEndRange(found, start, end);\n      }\n    }\n\n    // end of chapter\n    return this.findTextEndRange($prev, start, end);\n  }\n\n  /**\n   * Find Text Start Range\n   * @private\n   * @param {Node} root root node\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   * @return {Range}\n   */\n  findTextStartRange(node, start, end) {\n    var ranges = this.splitTextNodeIntoRanges(node);\n    var range;\n    var pos;\n    var left, top, right;\n    for (var i = 0; i < ranges.length; i++) {\n      range = ranges[i];\n      pos = range.getBoundingClientRect();\n      if (this.horizontal && this.direction === \"ltr\") {\n        left = pos.left;\n        if (left >= start) {\n          return range;\n        }\n      } else if (this.horizontal && this.direction === \"rtl\") {\n        right = pos.right;\n        if (right <= end) {\n          return range;\n        }\n      } else {\n        top = pos.top;\n        if (top >= start) {\n          return range;\n        }\n      }\n\n      // prev = range;\n    }\n\n    return ranges[0];\n  }\n\n  /**\n   * Find Text End Range\n   * @private\n   * @param {Node} root root node\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   * @return {Range}\n   */\n  findTextEndRange(node, start, end) {\n    var ranges = this.splitTextNodeIntoRanges(node);\n    var prev;\n    var range;\n    var pos;\n    var left, right, top, bottom;\n    for (var i = 0; i < ranges.length; i++) {\n      range = ranges[i];\n      pos = range.getBoundingClientRect();\n      if (this.horizontal && this.direction === \"ltr\") {\n        left = pos.left;\n        right = pos.right;\n        if (left > end && prev) {\n          return prev;\n        } else if (right > end) {\n          return range;\n        }\n      } else if (this.horizontal && this.direction === \"rtl\") {\n        left = pos.left;\n        right = pos.right;\n        if (right < start && prev) {\n          return prev;\n        } else if (left < start) {\n          return range;\n        }\n      } else {\n        top = pos.top;\n        bottom = pos.bottom;\n        if (top > end && prev) {\n          return prev;\n        } else if (bottom > end) {\n          return range;\n        }\n      }\n      prev = range;\n    }\n\n    // Ends before limit\n    return ranges[ranges.length - 1];\n  }\n\n  /**\n   * Split up a text node into ranges for each word\n   * @private\n   * @param {Node} root root node\n   * @param {string} [_splitter] what to split on\n   * @return {Range[]}\n   */\n  splitTextNodeIntoRanges(node, _splitter) {\n    var ranges = [];\n    var textContent = node.textContent || \"\";\n    var text = textContent.trim();\n    var range;\n    var doc = node.ownerDocument;\n    var splitter = _splitter || \" \";\n    var pos = text.indexOf(splitter);\n    if (pos === -1 || node.nodeType != Node.TEXT_NODE) {\n      range = doc.createRange();\n      range.selectNodeContents(node);\n      return [range];\n    }\n    range = doc.createRange();\n    range.setStart(node, 0);\n    range.setEnd(node, pos);\n    ranges.push(range);\n    range = false;\n    while (pos != -1) {\n      pos = text.indexOf(splitter, pos + 1);\n      if (pos > 0) {\n        if (range) {\n          range.setEnd(node, pos);\n          ranges.push(range);\n        }\n        range = doc.createRange();\n        range.setStart(node, pos + 1);\n      }\n    }\n    if (range) {\n      range.setEnd(node, text.length);\n      ranges.push(range);\n    }\n    return ranges;\n  }\n\n  /**\n   * Turn a pair of ranges into a pair of CFIs\n   * @private\n   * @param {string} cfiBase base string for an EpubCFI\n   * @param {object} rangePair { start: Range, end: Range }\n   * @return {object} { start: \"epubcfi(...)\", end: \"epubcfi(...)\" }\n   */\n  rangePairToCfiPair(cfiBase, rangePair) {\n    var startRange = rangePair.start;\n    var endRange = rangePair.end;\n    startRange.collapse(true);\n    endRange.collapse(false);\n    let startCfi = new EpubCFI(startRange, cfiBase).toString();\n    let endCfi = new EpubCFI(endRange, cfiBase).toString();\n    return {\n      start: startCfi,\n      end: endCfi\n    };\n  }\n  rangeListToCfiList(cfiBase, columns) {\n    var map = [];\n    var cifPair;\n    for (var i = 0; i < columns.length; i++) {\n      cifPair = this.rangePairToCfiPair(cfiBase, columns[i]);\n      map.push(cifPair);\n    }\n    return map;\n  }\n\n  /**\n   * Set the axis for mapping\n   * @param {string} axis horizontal | vertical\n   * @return {boolean} is it horizontal?\n   */\n  axis(axis) {\n    if (axis) {\n      this.horizontal = axis === \"horizontal\" ? true : false;\n    }\n    return this.horizontal;\n  }\n}\nexport default Mapping;","map":{"version":3,"names":["EpubCFI","nodeBounds","Mapping","constructor","layout","direction","axis","dev","horizontal","_dev","section","view","ranges","findRanges","map","rangeListToCfiList","cfiBase","page","contents","start","end","root","document","body","result","rangePairToCfiPair","findStart","findEnd","doc","startRange","toRange","endRange","selection","defaultView","getSelection","r","createRange","removeAllRanges","setStart","startContainer","startOffset","setEnd","endContainer","endOffset","addRange","walk","func","nodeType","Node","TEXT_NODE","filter","acceptNode","node","data","trim","length","NodeFilter","FILTER_ACCEPT","FILTER_REJECT","safeFilter","treeWalker","createTreeWalker","SHOW_TEXT","nextNode","columns","scrollWidth","spreads","Math","ceil","spreadWidth","count","divisor","columnWidth","gap","i","pages","push","stack","$el","found","$prev","shift","left","right","top","bottom","elPos","elRange","findTextStartRange","round","findTextEndRange","splitTextNodeIntoRanges","range","pos","getBoundingClientRect","prev","_splitter","textContent","text","ownerDocument","splitter","indexOf","selectNodeContents","rangePair","collapse","startCfi","toString","endCfi","cifPair"],"sources":["/home/parallels/Downloads/react-epub-viewer-demo/node_modules/epubjs/src/mapping.js"],"sourcesContent":["import EpubCFI from \"./epubcfi\";\nimport { nodeBounds } from \"./utils/core\";\n\n/**\n * Map text locations to CFI ranges\n * @class\n * @param {Layout} layout Layout to apply\n * @param {string} [direction=\"ltr\"] Text direction\n * @param {string} [axis=\"horizontal\"] vertical or horizontal axis\n * @param {boolean} [dev] toggle developer highlighting\n */\nclass Mapping {\n\tconstructor(layout, direction, axis, dev=false) {\n\t\tthis.layout = layout;\n\t\tthis.horizontal = (axis === \"horizontal\") ? true : false;\n\t\tthis.direction = direction || \"ltr\";\n\t\tthis._dev = dev;\n\t}\n\n\t/**\n\t * Find CFI pairs for entire section at once\n\t */\n\tsection(view) {\n\t\tvar ranges = this.findRanges(view);\n\t\tvar map = this.rangeListToCfiList(view.section.cfiBase, ranges);\n\n\t\treturn map;\n\t}\n\n\t/**\n\t * Find CFI pairs for a page\n\t * @param {Contents} contents Contents from view\n\t * @param {string} cfiBase string of the base for a cfi\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t */\n\tpage(contents, cfiBase, start, end) {\n\t\tvar root = contents && contents.document ? contents.document.body : false;\n\t\tvar result;\n\n\t\tif (!root) {\n\t\t\treturn;\n\t\t}\n\n\t\tresult = this.rangePairToCfiPair(cfiBase, {\n\t\t\tstart: this.findStart(root, start, end),\n\t\t\tend: this.findEnd(root, start, end)\n\t\t});\n\n\t\tif (this._dev === true) {\n\t\t\tlet doc = contents.document;\n\t\t\tlet startRange = new EpubCFI(result.start).toRange(doc);\n\t\t\tlet endRange = new EpubCFI(result.end).toRange(doc);\n\n\t\t\tlet selection = doc.defaultView.getSelection();\n\t\t\tlet r = doc.createRange();\n\t\t\tselection.removeAllRanges();\n\t\t\tr.setStart(startRange.startContainer, startRange.startOffset);\n\t\t\tr.setEnd(endRange.endContainer, endRange.endOffset);\n\t\t\tselection.addRange(r);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Walk a node, preforming a function on each node it finds\n\t * @private\n\t * @param {Node} root Node to walkToNode\n\t * @param {function} func walk function\n\t * @return {*} returns the result of the walk function\n\t */\n\twalk(root, func) {\n\t\t// IE11 has strange issue, if root is text node IE throws exception on\n\t\t// calling treeWalker.nextNode(), saying\n\t\t// Unexpected call to method or property access instead of returning null value\n\t\tif(root && root.nodeType === Node.TEXT_NODE) {\n\t\t\treturn;\n\t\t}\n\t\t// safeFilter is required so that it can work in IE as filter is a function for IE\n\t\t// and for other browser filter is an object.\n\t\tvar filter = {\n\t\t\tacceptNode: function(node) {\n\t\t\t\tif (node.data.trim().length > 0) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t} else {\n\t\t\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tvar safeFilter = filter.acceptNode;\n\t\tsafeFilter.acceptNode = filter.acceptNode;\n\n\t\tvar treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, safeFilter, false);\n\t\tvar node;\n\t\tvar result;\n\t\twhile ((node = treeWalker.nextNode())) {\n\t\t\tresult = func(node);\n\t\t\tif(result) break;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfindRanges(view){\n\t\tvar columns = [];\n\t\tvar scrollWidth = view.contents.scrollWidth();\n\t\tvar spreads = Math.ceil( scrollWidth / this.layout.spreadWidth);\n\t\tvar count = spreads * this.layout.divisor;\n\t\tvar columnWidth = this.layout.columnWidth;\n\t\tvar gap = this.layout.gap;\n\t\tvar start, end;\n\n\t\tfor (var i = 0; i < count.pages; i++) {\n\t\t\tstart = (columnWidth + gap) * i;\n\t\t\tend = (columnWidth * (i+1)) + (gap * i);\n\t\t\tcolumns.push({\n\t\t\t\tstart: this.findStart(view.document.body, start, end),\n\t\t\t\tend: this.findEnd(view.document.body, start, end)\n\t\t\t});\n\t\t}\n\n\t\treturn columns;\n\t}\n\n\t/**\n\t * Find Start Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindStart(root, start, end){\n\t\tvar stack = [root];\n\t\tvar $el;\n\t\tvar found;\n\t\tvar $prev = root;\n\n\t\twhile (stack.length) {\n\n\t\t\t$el = stack.shift();\n\n\t\t\tfound = this.walk($el, (node) => {\n\t\t\t\tvar left, right, top, bottom;\n\t\t\t\tvar elPos;\n\t\t\t\tvar elRange;\n\n\n\t\t\t\telPos = nodeBounds(node);\n\n\t\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\t\tleft = this.horizontal ? elPos.left : elPos.top;\n\t\t\t\t\tright = this.horizontal ? elPos.right : elPos.bottom;\n\n\t\t\t\t\tif( left >= start && left <= end ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else if (right > start) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\t\tleft = elPos.left;\n\t\t\t\t\tright = elPos.right;\n\n\t\t\t\t\tif( right <= end && right >= start ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else if (left < end) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttop = elPos.top;\n\t\t\t\t\tbottom = elPos.bottom;\n\n\t\t\t\t\tif( top >= start && top <= end ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else if (bottom > start) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t});\n\n\t\t\tif(found) {\n\t\t\t\treturn this.findTextStartRange(found, start, end);\n\t\t\t}\n\n\t\t}\n\n\t\t// Return last element\n\t\treturn this.findTextStartRange($prev, start, end);\n\t}\n\n\t/**\n\t * Find End Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindEnd(root, start, end){\n\t\tvar stack = [root];\n\t\tvar $el;\n\t\tvar $prev = root;\n\t\tvar found;\n\n\t\twhile (stack.length) {\n\n\t\t\t$el = stack.shift();\n\n\t\t\tfound = this.walk($el, (node) => {\n\n\t\t\t\tvar left, right, top, bottom;\n\t\t\t\tvar elPos;\n\t\t\t\tvar elRange;\n\n\t\t\t\telPos = nodeBounds(node);\n\n\t\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\t\tleft = Math.round(elPos.left);\n\t\t\t\t\tright = Math.round(elPos.right);\n\n\t\t\t\t\tif(left > end && $prev) {\n\t\t\t\t\t\treturn $prev;\n\t\t\t\t\t} else if(right > end) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\t\tleft = Math.round(this.horizontal ? elPos.left : elPos.top);\n\t\t\t\t\tright = Math.round(this.horizontal ? elPos.right : elPos.bottom);\n\n\t\t\t\t\tif(right < start && $prev) {\n\t\t\t\t\t\treturn $prev;\n\t\t\t\t\t} else if(left < start) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttop = Math.round(elPos.top);\n\t\t\t\t\tbottom = Math.round(elPos.bottom);\n\n\t\t\t\t\tif(top > end && $prev) {\n\t\t\t\t\t\treturn $prev;\n\t\t\t\t\t} else if(bottom > end) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t});\n\n\n\t\t\tif(found){\n\t\t\t\treturn this.findTextEndRange(found, start, end);\n\t\t\t}\n\n\t\t}\n\n\t\t// end of chapter\n\t\treturn this.findTextEndRange($prev, start, end);\n\t}\n\n\t/**\n\t * Find Text Start Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindTextStartRange(node, start, end){\n\t\tvar ranges = this.splitTextNodeIntoRanges(node);\n\t\tvar range;\n\t\tvar pos;\n\t\tvar left, top, right;\n\n\t\tfor (var i = 0; i < ranges.length; i++) {\n\t\t\trange = ranges[i];\n\n\t\t\tpos = range.getBoundingClientRect();\n\n\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\tleft = pos.left;\n\t\t\t\tif( left >= start ) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\tright = pos.right;\n\t\t\t\tif( right <= end ) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttop = pos.top;\n\t\t\t\tif( top >= start ) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// prev = range;\n\n\t\t}\n\n\t\treturn ranges[0];\n\t}\n\n\t/**\n\t * Find Text End Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindTextEndRange(node, start, end){\n\t\tvar ranges = this.splitTextNodeIntoRanges(node);\n\t\tvar prev;\n\t\tvar range;\n\t\tvar pos;\n\t\tvar left, right, top, bottom;\n\n\t\tfor (var i = 0; i < ranges.length; i++) {\n\t\t\trange = ranges[i];\n\n\t\t\tpos = range.getBoundingClientRect();\n\n\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\tleft = pos.left;\n\t\t\t\tright = pos.right;\n\n\t\t\t\tif(left > end && prev) {\n\t\t\t\t\treturn prev;\n\t\t\t\t} else if(right > end) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\tleft = pos.left\n\t\t\t\tright = pos.right;\n\n\t\t\t\tif(right < start && prev) {\n\t\t\t\t\treturn prev;\n\t\t\t\t} else if(left < start) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttop = pos.top;\n\t\t\t\tbottom = pos.bottom;\n\n\t\t\t\tif(top > end && prev) {\n\t\t\t\t\treturn prev;\n\t\t\t\t} else if(bottom > end) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tprev = range;\n\n\t\t}\n\n\t\t// Ends before limit\n\t\treturn ranges[ranges.length-1];\n\n\t}\n\n\t/**\n\t * Split up a text node into ranges for each word\n\t * @private\n\t * @param {Node} root root node\n\t * @param {string} [_splitter] what to split on\n\t * @return {Range[]}\n\t */\n\tsplitTextNodeIntoRanges(node, _splitter){\n\t\tvar ranges = [];\n\t\tvar textContent = node.textContent || \"\";\n\t\tvar text = textContent.trim();\n\t\tvar range;\n\t\tvar doc = node.ownerDocument;\n\t\tvar splitter = _splitter || \" \";\n\n\t\tvar pos = text.indexOf(splitter);\n\n\t\tif(pos === -1 || node.nodeType != Node.TEXT_NODE) {\n\t\t\trange = doc.createRange();\n\t\t\trange.selectNodeContents(node);\n\t\t\treturn [range];\n\t\t}\n\n\t\trange = doc.createRange();\n\t\trange.setStart(node, 0);\n\t\trange.setEnd(node, pos);\n\t\tranges.push(range);\n\t\trange = false;\n\n\t\twhile ( pos != -1 ) {\n\n\t\t\tpos = text.indexOf(splitter, pos + 1);\n\t\t\tif(pos > 0) {\n\n\t\t\t\tif(range) {\n\t\t\t\t\trange.setEnd(node, pos);\n\t\t\t\t\tranges.push(range);\n\t\t\t\t}\n\n\t\t\t\trange = doc.createRange();\n\t\t\t\trange.setStart(node, pos+1);\n\t\t\t}\n\t\t}\n\n\t\tif(range) {\n\t\t\trange.setEnd(node, text.length);\n\t\t\tranges.push(range);\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\n\t/**\n\t * Turn a pair of ranges into a pair of CFIs\n\t * @private\n\t * @param {string} cfiBase base string for an EpubCFI\n\t * @param {object} rangePair { start: Range, end: Range }\n\t * @return {object} { start: \"epubcfi(...)\", end: \"epubcfi(...)\" }\n\t */\n\trangePairToCfiPair(cfiBase, rangePair){\n\n\t\tvar startRange = rangePair.start;\n\t\tvar endRange = rangePair.end;\n\n\t\tstartRange.collapse(true);\n\t\tendRange.collapse(false);\n\n\t\tlet startCfi = new EpubCFI(startRange, cfiBase).toString();\n\t\tlet endCfi = new EpubCFI(endRange, cfiBase).toString();\n\n\t\treturn {\n\t\t\tstart: startCfi,\n\t\t\tend: endCfi\n\t\t};\n\n\t}\n\n\trangeListToCfiList(cfiBase, columns){\n\t\tvar map = [];\n\t\tvar cifPair;\n\n\t\tfor (var i = 0; i < columns.length; i++) {\n\t\t\tcifPair = this.rangePairToCfiPair(cfiBase, columns[i]);\n\n\t\t\tmap.push(cifPair);\n\n\t\t}\n\n\t\treturn map;\n\t}\n\n\t/**\n\t * Set the axis for mapping\n\t * @param {string} axis horizontal | vertical\n\t * @return {boolean} is it horizontal?\n\t */\n\taxis(axis) {\n\t\tif (axis) {\n\t\t\tthis.horizontal = (axis === \"horizontal\") ? true : false;\n\t\t}\n\t\treturn this.horizontal;\n\t}\n}\n\nexport default Mapping;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}