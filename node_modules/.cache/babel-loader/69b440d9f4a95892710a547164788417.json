{"ast":null,"code":"import { extend, type, findChildren, RangeObject, isNumber } from \"./utils/core\";\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst DOCUMENT_NODE = 9;\n\n/**\n\t* Parsing and creation of EpubCFIs: http://www.idpf.org/epub/linking/cfi/epub-cfi.html\n\n\t* Implements:\n\t* - Character Offset: epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)\n\t* - Simple Ranges : epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)\n\n\t* Does Not Implement:\n\t* - Temporal Offset (~)\n\t* - Spatial Offset (@)\n\t* - Temporal-Spatial Offset (~ + @)\n\t* - Text Location Assertion ([)\n\t* @class\n\t@param {string | Range | Node } [cfiFrom]\n\t@param {string | object} [base]\n\t@param {string} [ignoreClass] class to ignore when parsing DOM\n*/\nclass EpubCFI {\n  constructor(cfiFrom, base, ignoreClass) {\n    var type;\n    this.str = \"\";\n    this.base = {};\n    this.spinePos = 0; // For compatibility\n\n    this.range = false; // true || false;\n\n    this.path = {};\n    this.start = null;\n    this.end = null;\n\n    // Allow instantiation without the \"new\" keyword\n    if (!(this instanceof EpubCFI)) {\n      return new EpubCFI(cfiFrom, base, ignoreClass);\n    }\n    if (typeof base === \"string\") {\n      this.base = this.parseComponent(base);\n    } else if (typeof base === \"object\" && base.steps) {\n      this.base = base;\n    }\n    type = this.checkType(cfiFrom);\n    if (type === \"string\") {\n      this.str = cfiFrom;\n      return extend(this, this.parse(cfiFrom));\n    } else if (type === \"range\") {\n      return extend(this, this.fromRange(cfiFrom, this.base, ignoreClass));\n    } else if (type === \"node\") {\n      return extend(this, this.fromNode(cfiFrom, this.base, ignoreClass));\n    } else if (type === \"EpubCFI\" && cfiFrom.path) {\n      return cfiFrom;\n    } else if (!cfiFrom) {\n      return this;\n    } else {\n      throw new TypeError(\"not a valid argument for EpubCFI\");\n    }\n  }\n\n  /**\n   * Check the type of constructor input\n   * @private\n   */\n  checkType(cfi) {\n    if (this.isCfiString(cfi)) {\n      return \"string\";\n      // Is a range object\n    } else if (cfi && typeof cfi === \"object\" && (type(cfi) === \"Range\" || typeof cfi.startContainer != \"undefined\")) {\n      return \"range\";\n    } else if (cfi && typeof cfi === \"object\" && typeof cfi.nodeType != \"undefined\") {\n      // || typeof cfi === \"function\"\n      return \"node\";\n    } else if (cfi && typeof cfi === \"object\" && cfi instanceof EpubCFI) {\n      return \"EpubCFI\";\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Parse a cfi string to a CFI object representation\n   * @param {string} cfiStr\n   * @returns {object} cfi\n   */\n  parse(cfiStr) {\n    var cfi = {\n      spinePos: -1,\n      range: false,\n      base: {},\n      path: {},\n      start: null,\n      end: null\n    };\n    var baseComponent, pathComponent, range;\n    if (typeof cfiStr !== \"string\") {\n      return {\n        spinePos: -1\n      };\n    }\n    if (cfiStr.indexOf(\"epubcfi(\") === 0 && cfiStr[cfiStr.length - 1] === \")\") {\n      // Remove initial epubcfi( and ending )\n      cfiStr = cfiStr.slice(8, cfiStr.length - 1);\n    }\n    baseComponent = this.getChapterComponent(cfiStr);\n\n    // Make sure this is a valid cfi or return\n    if (!baseComponent) {\n      return {\n        spinePos: -1\n      };\n    }\n    cfi.base = this.parseComponent(baseComponent);\n    pathComponent = this.getPathComponent(cfiStr);\n    cfi.path = this.parseComponent(pathComponent);\n    range = this.getRange(cfiStr);\n    if (range) {\n      cfi.range = true;\n      cfi.start = this.parseComponent(range[0]);\n      cfi.end = this.parseComponent(range[1]);\n    }\n\n    // Get spine node position\n    // cfi.spineSegment = cfi.base.steps[1];\n\n    // Chapter segment is always the second step\n    cfi.spinePos = cfi.base.steps[1].index;\n    return cfi;\n  }\n  parseComponent(componentStr) {\n    var component = {\n      steps: [],\n      terminal: {\n        offset: null,\n        assertion: null\n      }\n    };\n    var parts = componentStr.split(\":\");\n    var steps = parts[0].split(\"/\");\n    var terminal;\n    if (parts.length > 1) {\n      terminal = parts[1];\n      component.terminal = this.parseTerminal(terminal);\n    }\n    if (steps[0] === \"\") {\n      steps.shift(); // Ignore the first slash\n    }\n\n    component.steps = steps.map(function (step) {\n      return this.parseStep(step);\n    }.bind(this));\n    return component;\n  }\n  parseStep(stepStr) {\n    var type, num, index, has_brackets, id;\n    has_brackets = stepStr.match(/\\[(.*)\\]/);\n    if (has_brackets && has_brackets[1]) {\n      id = has_brackets[1];\n    }\n\n    //-- Check if step is a text node or element\n    num = parseInt(stepStr);\n    if (isNaN(num)) {\n      return;\n    }\n    if (num % 2 === 0) {\n      // Even = is an element\n      type = \"element\";\n      index = num / 2 - 1;\n    } else {\n      type = \"text\";\n      index = (num - 1) / 2;\n    }\n    return {\n      \"type\": type,\n      \"index\": index,\n      \"id\": id || null\n    };\n  }\n  parseTerminal(termialStr) {\n    var characterOffset, textLocationAssertion;\n    var assertion = termialStr.match(/\\[(.*)\\]/);\n    if (assertion && assertion[1]) {\n      characterOffset = parseInt(termialStr.split(\"[\")[0]);\n      textLocationAssertion = assertion[1];\n    } else {\n      characterOffset = parseInt(termialStr);\n    }\n    if (!isNumber(characterOffset)) {\n      characterOffset = null;\n    }\n    return {\n      \"offset\": characterOffset,\n      \"assertion\": textLocationAssertion\n    };\n  }\n  getChapterComponent(cfiStr) {\n    var indirection = cfiStr.split(\"!\");\n    return indirection[0];\n  }\n  getPathComponent(cfiStr) {\n    var indirection = cfiStr.split(\"!\");\n    if (indirection[1]) {\n      let ranges = indirection[1].split(\",\");\n      return ranges[0];\n    }\n  }\n  getRange(cfiStr) {\n    var ranges = cfiStr.split(\",\");\n    if (ranges.length === 3) {\n      return [ranges[1], ranges[2]];\n    }\n    return false;\n  }\n  getCharecterOffsetComponent(cfiStr) {\n    var splitStr = cfiStr.split(\":\");\n    return splitStr[1] || \"\";\n  }\n  joinSteps(steps) {\n    if (!steps) {\n      return \"\";\n    }\n    return steps.map(function (part) {\n      var segment = \"\";\n      if (part.type === \"element\") {\n        segment += (part.index + 1) * 2;\n      }\n      if (part.type === \"text\") {\n        segment += 1 + 2 * part.index; // TODO: double check that this is odd\n      }\n\n      if (part.id) {\n        segment += \"[\" + part.id + \"]\";\n      }\n      return segment;\n    }).join(\"/\");\n  }\n  segmentString(segment) {\n    var segmentString = \"/\";\n    segmentString += this.joinSteps(segment.steps);\n    if (segment.terminal && segment.terminal.offset != null) {\n      segmentString += \":\" + segment.terminal.offset;\n    }\n    if (segment.terminal && segment.terminal.assertion != null) {\n      segmentString += \"[\" + segment.terminal.assertion + \"]\";\n    }\n    return segmentString;\n  }\n\n  /**\n   * Convert CFI to a epubcfi(...) string\n   * @returns {string} epubcfi\n   */\n  toString() {\n    var cfiString = \"epubcfi(\";\n    cfiString += this.segmentString(this.base);\n    cfiString += \"!\";\n    cfiString += this.segmentString(this.path);\n\n    // Add Range, if present\n    if (this.range && this.start) {\n      cfiString += \",\";\n      cfiString += this.segmentString(this.start);\n    }\n    if (this.range && this.end) {\n      cfiString += \",\";\n      cfiString += this.segmentString(this.end);\n    }\n    cfiString += \")\";\n    return cfiString;\n  }\n\n  /**\n   * Compare which of two CFIs is earlier in the text\n   * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0\n   */\n  compare(cfiOne, cfiTwo) {\n    var stepsA, stepsB;\n    var terminalA, terminalB;\n    var rangeAStartSteps, rangeAEndSteps;\n    var rangeBEndSteps, rangeBEndSteps;\n    var rangeAStartTerminal, rangeAEndTerminal;\n    var rangeBStartTerminal, rangeBEndTerminal;\n    if (typeof cfiOne === \"string\") {\n      cfiOne = new EpubCFI(cfiOne);\n    }\n    if (typeof cfiTwo === \"string\") {\n      cfiTwo = new EpubCFI(cfiTwo);\n    }\n    // Compare Spine Positions\n    if (cfiOne.spinePos > cfiTwo.spinePos) {\n      return 1;\n    }\n    if (cfiOne.spinePos < cfiTwo.spinePos) {\n      return -1;\n    }\n    if (cfiOne.range) {\n      stepsA = cfiOne.path.steps.concat(cfiOne.start.steps);\n      terminalA = cfiOne.start.terminal;\n    } else {\n      stepsA = cfiOne.path.steps;\n      terminalA = cfiOne.path.terminal;\n    }\n    if (cfiTwo.range) {\n      stepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);\n      terminalB = cfiTwo.start.terminal;\n    } else {\n      stepsB = cfiTwo.path.steps;\n      terminalB = cfiTwo.path.terminal;\n    }\n\n    // Compare Each Step in the First item\n    for (var i = 0; i < stepsA.length; i++) {\n      if (!stepsA[i]) {\n        return -1;\n      }\n      if (!stepsB[i]) {\n        return 1;\n      }\n      if (stepsA[i].index > stepsB[i].index) {\n        return 1;\n      }\n      if (stepsA[i].index < stepsB[i].index) {\n        return -1;\n      }\n      // Otherwise continue checking\n    }\n\n    // All steps in First equal to Second and First is Less Specific\n    if (stepsA.length < stepsB.length) {\n      return -1;\n    }\n\n    // Compare the character offset of the text node\n    if (terminalA.offset > terminalB.offset) {\n      return 1;\n    }\n    if (terminalA.offset < terminalB.offset) {\n      return -1;\n    }\n\n    // CFI's are equal\n    return 0;\n  }\n  step(node) {\n    var nodeType = node.nodeType === TEXT_NODE ? \"text\" : \"element\";\n    return {\n      \"id\": node.id,\n      \"tagName\": node.tagName,\n      \"type\": nodeType,\n      \"index\": this.position(node)\n    };\n  }\n  filteredStep(node, ignoreClass) {\n    var filteredNode = this.filter(node, ignoreClass);\n    var nodeType;\n\n    // Node filtered, so ignore\n    if (!filteredNode) {\n      return;\n    }\n\n    // Otherwise add the filter node in\n    nodeType = filteredNode.nodeType === TEXT_NODE ? \"text\" : \"element\";\n    return {\n      \"id\": filteredNode.id,\n      \"tagName\": filteredNode.tagName,\n      \"type\": nodeType,\n      \"index\": this.filteredPosition(filteredNode, ignoreClass)\n    };\n  }\n  pathTo(node, offset, ignoreClass) {\n    var segment = {\n      steps: [],\n      terminal: {\n        offset: null,\n        assertion: null\n      }\n    };\n    var currentNode = node;\n    var step;\n    while (currentNode && currentNode.parentNode && currentNode.parentNode.nodeType != DOCUMENT_NODE) {\n      if (ignoreClass) {\n        step = this.filteredStep(currentNode, ignoreClass);\n      } else {\n        step = this.step(currentNode);\n      }\n      if (step) {\n        segment.steps.unshift(step);\n      }\n      currentNode = currentNode.parentNode;\n    }\n    if (offset != null && offset >= 0) {\n      segment.terminal.offset = offset;\n\n      // Make sure we are getting to a textNode if there is an offset\n      if (segment.steps[segment.steps.length - 1].type != \"text\") {\n        segment.steps.push({\n          \"type\": \"text\",\n          \"index\": 0\n        });\n      }\n    }\n    return segment;\n  }\n  equalStep(stepA, stepB) {\n    if (!stepA || !stepB) {\n      return false;\n    }\n    if (stepA.index === stepB.index && stepA.id === stepB.id && stepA.type === stepB.type) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Create a CFI object from a Range\n   * @param {Range} range\n   * @param {string | object} base\n   * @param {string} [ignoreClass]\n   * @returns {object} cfi\n   */\n  fromRange(range, base, ignoreClass) {\n    var cfi = {\n      range: false,\n      base: {},\n      path: {},\n      start: null,\n      end: null\n    };\n    var start = range.startContainer;\n    var end = range.endContainer;\n    var startOffset = range.startOffset;\n    var endOffset = range.endOffset;\n    var needsIgnoring = false;\n    if (ignoreClass) {\n      // Tell pathTo if / what to ignore\n      needsIgnoring = start.ownerDocument.querySelector(\".\" + ignoreClass) != null;\n    }\n    if (typeof base === \"string\") {\n      cfi.base = this.parseComponent(base);\n      cfi.spinePos = cfi.base.steps[1].index;\n    } else if (typeof base === \"object\") {\n      cfi.base = base;\n    }\n    if (range.collapsed) {\n      if (needsIgnoring) {\n        startOffset = this.patchOffset(start, startOffset, ignoreClass);\n      }\n      cfi.path = this.pathTo(start, startOffset, ignoreClass);\n    } else {\n      cfi.range = true;\n      if (needsIgnoring) {\n        startOffset = this.patchOffset(start, startOffset, ignoreClass);\n      }\n      cfi.start = this.pathTo(start, startOffset, ignoreClass);\n      if (needsIgnoring) {\n        endOffset = this.patchOffset(end, endOffset, ignoreClass);\n      }\n      cfi.end = this.pathTo(end, endOffset, ignoreClass);\n\n      // Create a new empty path\n      cfi.path = {\n        steps: [],\n        terminal: null\n      };\n\n      // Push steps that are shared between start and end to the common path\n      var len = cfi.start.steps.length;\n      var i;\n      for (i = 0; i < len; i++) {\n        if (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n          if (i === len - 1) {\n            // Last step is equal, check terminals\n            if (cfi.start.terminal === cfi.end.terminal) {\n              // CFI's are equal\n              cfi.path.steps.push(cfi.start.steps[i]);\n              // Not a range\n              cfi.range = false;\n            }\n          } else {\n            cfi.path.steps.push(cfi.start.steps[i]);\n          }\n        } else {\n          break;\n        }\n      }\n      cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);\n      cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length);\n\n      // TODO: Add Sanity check to make sure that the end if greater than the start\n    }\n\n    return cfi;\n  }\n\n  /**\n   * Create a CFI object from a Node\n   * @param {Node} anchor\n   * @param {string | object} base\n   * @param {string} [ignoreClass]\n   * @returns {object} cfi\n   */\n  fromNode(anchor, base, ignoreClass) {\n    var cfi = {\n      range: false,\n      base: {},\n      path: {},\n      start: null,\n      end: null\n    };\n    if (typeof base === \"string\") {\n      cfi.base = this.parseComponent(base);\n      cfi.spinePos = cfi.base.steps[1].index;\n    } else if (typeof base === \"object\") {\n      cfi.base = base;\n    }\n    cfi.path = this.pathTo(anchor, null, ignoreClass);\n    return cfi;\n  }\n  filter(anchor, ignoreClass) {\n    var needsIgnoring;\n    var sibling; // to join with\n    var parent, previousSibling, nextSibling;\n    var isText = false;\n    if (anchor.nodeType === TEXT_NODE) {\n      isText = true;\n      parent = anchor.parentNode;\n      needsIgnoring = anchor.parentNode.classList.contains(ignoreClass);\n    } else {\n      isText = false;\n      needsIgnoring = anchor.classList.contains(ignoreClass);\n    }\n    if (needsIgnoring && isText) {\n      previousSibling = parent.previousSibling;\n      nextSibling = parent.nextSibling;\n\n      // If the sibling is a text node, join the nodes\n      if (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n        sibling = previousSibling;\n      } else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {\n        sibling = nextSibling;\n      }\n      if (sibling) {\n        return sibling;\n      } else {\n        // Parent will be ignored on next step\n        return anchor;\n      }\n    } else if (needsIgnoring && !isText) {\n      // Otherwise just skip the element node\n      return false;\n    } else {\n      // No need to filter\n      return anchor;\n    }\n  }\n  patchOffset(anchor, offset, ignoreClass) {\n    if (anchor.nodeType != TEXT_NODE) {\n      throw new Error(\"Anchor must be a text node\");\n    }\n    var curr = anchor;\n    var totalOffset = offset;\n\n    // If the parent is a ignored node, get offset from it's start\n    if (anchor.parentNode.classList.contains(ignoreClass)) {\n      curr = anchor.parentNode;\n    }\n    while (curr.previousSibling) {\n      if (curr.previousSibling.nodeType === ELEMENT_NODE) {\n        // Originally a text node, so join\n        if (curr.previousSibling.classList.contains(ignoreClass)) {\n          totalOffset += curr.previousSibling.textContent.length;\n        } else {\n          break; // Normal node, dont join\n        }\n      } else {\n        // If the previous sibling is a text node, join the nodes\n        totalOffset += curr.previousSibling.textContent.length;\n      }\n      curr = curr.previousSibling;\n    }\n    return totalOffset;\n  }\n  normalizedMap(children, nodeType, ignoreClass) {\n    var output = {};\n    var prevIndex = -1;\n    var i,\n      len = children.length;\n    var currNodeType;\n    var prevNodeType;\n    for (i = 0; i < len; i++) {\n      currNodeType = children[i].nodeType;\n\n      // Check if needs ignoring\n      if (currNodeType === ELEMENT_NODE && children[i].classList.contains(ignoreClass)) {\n        currNodeType = TEXT_NODE;\n      }\n      if (i > 0 && currNodeType === TEXT_NODE && prevNodeType === TEXT_NODE) {\n        // join text nodes\n        output[i] = prevIndex;\n      } else if (nodeType === currNodeType) {\n        prevIndex = prevIndex + 1;\n        output[i] = prevIndex;\n      }\n      prevNodeType = currNodeType;\n    }\n    return output;\n  }\n  position(anchor) {\n    var children, index;\n    if (anchor.nodeType === ELEMENT_NODE) {\n      children = anchor.parentNode.children;\n      if (!children) {\n        children = findChildren(anchor.parentNode);\n      }\n      index = Array.prototype.indexOf.call(children, anchor);\n    } else {\n      children = this.textNodes(anchor.parentNode);\n      index = children.indexOf(anchor);\n    }\n    return index;\n  }\n  filteredPosition(anchor, ignoreClass) {\n    var children, index, map;\n    if (anchor.nodeType === ELEMENT_NODE) {\n      children = anchor.parentNode.children;\n      map = this.normalizedMap(children, ELEMENT_NODE, ignoreClass);\n    } else {\n      children = anchor.parentNode.childNodes;\n      // Inside an ignored node\n      if (anchor.parentNode.classList.contains(ignoreClass)) {\n        anchor = anchor.parentNode;\n        children = anchor.parentNode.childNodes;\n      }\n      map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n    }\n    index = Array.prototype.indexOf.call(children, anchor);\n    return map[index];\n  }\n  stepsToXpath(steps) {\n    var xpath = [\".\", \"*\"];\n    steps.forEach(function (step) {\n      var position = step.index + 1;\n      if (step.id) {\n        xpath.push(\"*[position()=\" + position + \" and @id='\" + step.id + \"']\");\n      } else if (step.type === \"text\") {\n        xpath.push(\"text()[\" + position + \"]\");\n      } else {\n        xpath.push(\"*[\" + position + \"]\");\n      }\n    });\n    return xpath.join(\"/\");\n  }\n\n  /*\n  \tTo get the last step if needed:\n  \t// Get the terminal step\n  lastStep = steps[steps.length-1];\n  // Get the query string\n  query = this.stepsToQuery(steps);\n  // Find the containing element\n  startContainerParent = doc.querySelector(query);\n  // Find the text node within that element\n  if(startContainerParent && lastStep.type == \"text\") {\n  \tcontainer = startContainerParent.childNodes[lastStep.index];\n  }\n  */\n  stepsToQuerySelector(steps) {\n    var query = [\"html\"];\n    steps.forEach(function (step) {\n      var position = step.index + 1;\n      if (step.id) {\n        query.push(\"#\" + step.id);\n      } else if (step.type === \"text\") {\n        // unsupported in querySelector\n        // query.push(\"text()[\" + position + \"]\");\n      } else {\n        query.push(\"*:nth-child(\" + position + \")\");\n      }\n    });\n    return query.join(\">\");\n  }\n  textNodes(container, ignoreClass) {\n    return Array.prototype.slice.call(container.childNodes).filter(function (node) {\n      if (node.nodeType === TEXT_NODE) {\n        return true;\n      } else if (ignoreClass && node.classList.contains(ignoreClass)) {\n        return true;\n      }\n      return false;\n    });\n  }\n  walkToNode(steps, _doc, ignoreClass) {\n    var doc = _doc || document;\n    var container = doc.documentElement;\n    var children;\n    var step;\n    var len = steps.length;\n    var i;\n    for (i = 0; i < len; i++) {\n      step = steps[i];\n      if (step.type === \"element\") {\n        //better to get a container using id as some times step.index may not be correct\n        //For ex.https://github.com/futurepress/epub.js/issues/561\n        if (step.id) {\n          container = doc.getElementById(step.id);\n        } else {\n          children = container.children || findChildren(container);\n          container = children[step.index];\n        }\n      } else if (step.type === \"text\") {\n        container = this.textNodes(container, ignoreClass)[step.index];\n      }\n      if (!container) {\n        //Break the for loop as due to incorrect index we can get error if\n        //container is undefined so that other functionailties works fine\n        //like navigation\n        break;\n      }\n    }\n    return container;\n  }\n  findNode(steps, _doc, ignoreClass) {\n    var doc = _doc || document;\n    var container;\n    var xpath;\n    if (!ignoreClass && typeof doc.evaluate != \"undefined\") {\n      xpath = this.stepsToXpath(steps);\n      container = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n    } else if (ignoreClass) {\n      container = this.walkToNode(steps, doc, ignoreClass);\n    } else {\n      container = this.walkToNode(steps, doc);\n    }\n    return container;\n  }\n  fixMiss(steps, offset, _doc, ignoreClass) {\n    var container = this.findNode(steps.slice(0, -1), _doc, ignoreClass);\n    var children = container.childNodes;\n    var map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n    var child;\n    var len;\n    var lastStepIndex = steps[steps.length - 1].index;\n    for (let childIndex in map) {\n      if (!map.hasOwnProperty(childIndex)) return;\n      if (map[childIndex] === lastStepIndex) {\n        child = children[childIndex];\n        len = child.textContent.length;\n        if (offset > len) {\n          offset = offset - len;\n        } else {\n          if (child.nodeType === ELEMENT_NODE) {\n            container = child.childNodes[0];\n          } else {\n            container = child;\n          }\n          break;\n        }\n      }\n    }\n    return {\n      container: container,\n      offset: offset\n    };\n  }\n\n  /**\n   * Creates a DOM range representing a CFI\n   * @param {document} _doc document referenced in the base\n   * @param {string} [ignoreClass]\n   * @return {Range}\n   */\n  toRange(_doc, ignoreClass) {\n    var doc = _doc || document;\n    var range;\n    var start, end, startContainer, endContainer;\n    var cfi = this;\n    var startSteps, endSteps;\n    var needsIgnoring = ignoreClass ? doc.querySelector(\".\" + ignoreClass) != null : false;\n    var missed;\n    if (typeof doc.createRange !== \"undefined\") {\n      range = doc.createRange();\n    } else {\n      range = new RangeObject();\n    }\n    if (cfi.range) {\n      start = cfi.start;\n      startSteps = cfi.path.steps.concat(start.steps);\n      startContainer = this.findNode(startSteps, doc, needsIgnoring ? ignoreClass : null);\n      end = cfi.end;\n      endSteps = cfi.path.steps.concat(end.steps);\n      endContainer = this.findNode(endSteps, doc, needsIgnoring ? ignoreClass : null);\n    } else {\n      start = cfi.path;\n      startSteps = cfi.path.steps;\n      startContainer = this.findNode(cfi.path.steps, doc, needsIgnoring ? ignoreClass : null);\n    }\n    if (startContainer) {\n      try {\n        if (start.terminal.offset != null) {\n          range.setStart(startContainer, start.terminal.offset);\n        } else {\n          range.setStart(startContainer, 0);\n        }\n      } catch (e) {\n        missed = this.fixMiss(startSteps, start.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n        range.setStart(missed.container, missed.offset);\n      }\n    } else {\n      console.log(\"No startContainer found for\", this.toString());\n      // No start found\n      return null;\n    }\n    if (endContainer) {\n      try {\n        if (end.terminal.offset != null) {\n          range.setEnd(endContainer, end.terminal.offset);\n        } else {\n          range.setEnd(endContainer, 0);\n        }\n      } catch (e) {\n        missed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n        range.setEnd(missed.container, missed.offset);\n      }\n    }\n\n    // doc.defaultView.getSelection().addRange(range);\n    return range;\n  }\n\n  /**\n   * Check if a string is wrapped with \"epubcfi()\"\n   * @param {string} str\n   * @returns {boolean}\n   */\n  isCfiString(str) {\n    if (typeof str === \"string\" && str.indexOf(\"epubcfi(\") === 0 && str[str.length - 1] === \")\") {\n      return true;\n    }\n    return false;\n  }\n  generateChapterComponent(_spineNodeIndex, _pos, id) {\n    var pos = parseInt(_pos),\n      spineNodeIndex = (_spineNodeIndex + 1) * 2,\n      cfi = \"/\" + spineNodeIndex + \"/\";\n    cfi += (pos + 1) * 2;\n    if (id) {\n      cfi += \"[\" + id + \"]\";\n    }\n    return cfi;\n  }\n\n  /**\n   * Collapse a CFI Range to a single CFI Position\n   * @param {boolean} [toStart=false]\n   */\n  collapse(toStart) {\n    if (!this.range) {\n      return;\n    }\n    this.range = false;\n    if (toStart) {\n      this.path.steps = this.path.steps.concat(this.start.steps);\n      this.path.terminal = this.start.terminal;\n    } else {\n      this.path.steps = this.path.steps.concat(this.end.steps);\n      this.path.terminal = this.end.terminal;\n    }\n  }\n}\nexport default EpubCFI;","map":{"version":3,"names":["extend","type","findChildren","RangeObject","isNumber","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_NODE","EpubCFI","constructor","cfiFrom","base","ignoreClass","str","spinePos","range","path","start","end","parseComponent","steps","checkType","parse","fromRange","fromNode","TypeError","cfi","isCfiString","startContainer","nodeType","cfiStr","baseComponent","pathComponent","indexOf","length","slice","getChapterComponent","getPathComponent","getRange","index","componentStr","component","terminal","offset","assertion","parts","split","parseTerminal","shift","map","step","parseStep","bind","stepStr","num","has_brackets","id","match","parseInt","isNaN","termialStr","characterOffset","textLocationAssertion","indirection","ranges","getCharecterOffsetComponent","splitStr","joinSteps","part","segment","join","segmentString","toString","cfiString","compare","cfiOne","cfiTwo","stepsA","stepsB","terminalA","terminalB","rangeAStartSteps","rangeAEndSteps","rangeBEndSteps","rangeAStartTerminal","rangeAEndTerminal","rangeBStartTerminal","rangeBEndTerminal","concat","i","node","tagName","position","filteredStep","filteredNode","filter","filteredPosition","pathTo","currentNode","parentNode","unshift","push","equalStep","stepA","stepB","endContainer","startOffset","endOffset","needsIgnoring","ownerDocument","querySelector","collapsed","patchOffset","len","anchor","sibling","parent","previousSibling","nextSibling","isText","classList","contains","Error","curr","totalOffset","textContent","normalizedMap","children","output","prevIndex","currNodeType","prevNodeType","Array","prototype","call","textNodes","childNodes","stepsToXpath","xpath","forEach","stepsToQuerySelector","query","container","walkToNode","_doc","doc","document","documentElement","getElementById","findNode","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","fixMiss","child","lastStepIndex","childIndex","hasOwnProperty","toRange","startSteps","endSteps","missed","createRange","setStart","e","console","log","setEnd","generateChapterComponent","_spineNodeIndex","_pos","pos","spineNodeIndex","collapse","toStart"],"sources":["/home/parallels/Downloads/react-epub-viewer-demo/node_modules/epubjs/src/epubcfi.js"],"sourcesContent":["import {extend, type, findChildren, RangeObject, isNumber} from \"./utils/core\";\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst DOCUMENT_NODE = 9;\n\n/**\n\t* Parsing and creation of EpubCFIs: http://www.idpf.org/epub/linking/cfi/epub-cfi.html\n\n\t* Implements:\n\t* - Character Offset: epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)\n\t* - Simple Ranges : epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)\n\n\t* Does Not Implement:\n\t* - Temporal Offset (~)\n\t* - Spatial Offset (@)\n\t* - Temporal-Spatial Offset (~ + @)\n\t* - Text Location Assertion ([)\n\t* @class\n\t@param {string | Range | Node } [cfiFrom]\n\t@param {string | object} [base]\n\t@param {string} [ignoreClass] class to ignore when parsing DOM\n*/\nclass EpubCFI {\n\tconstructor(cfiFrom, base, ignoreClass){\n\t\tvar type;\n\n\t\tthis.str = \"\";\n\n\t\tthis.base = {};\n\t\tthis.spinePos = 0; // For compatibility\n\n\t\tthis.range = false; // true || false;\n\n\t\tthis.path = {};\n\t\tthis.start = null;\n\t\tthis.end = null;\n\n\t\t// Allow instantiation without the \"new\" keyword\n\t\tif (!(this instanceof EpubCFI)) {\n\t\t\treturn new EpubCFI(cfiFrom, base, ignoreClass);\n\t\t}\n\n\t\tif(typeof base === \"string\") {\n\t\t\tthis.base = this.parseComponent(base);\n\t\t} else if(typeof base === \"object\" && base.steps) {\n\t\t\tthis.base = base;\n\t\t}\n\n\t\ttype = this.checkType(cfiFrom);\n\n\n\t\tif(type === \"string\") {\n\t\t\tthis.str = cfiFrom;\n\t\t\treturn extend(this, this.parse(cfiFrom));\n\t\t} else if (type === \"range\") {\n\t\t\treturn extend(this, this.fromRange(cfiFrom, this.base, ignoreClass));\n\t\t} else if (type === \"node\") {\n\t\t\treturn extend(this, this.fromNode(cfiFrom, this.base, ignoreClass));\n\t\t} else if (type === \"EpubCFI\" && cfiFrom.path) {\n\t\t\treturn cfiFrom;\n\t\t} else if (!cfiFrom) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\tthrow new TypeError(\"not a valid argument for EpubCFI\");\n\t\t}\n\n\t}\n\n\t/**\n\t * Check the type of constructor input\n\t * @private\n\t */\n\tcheckType(cfi) {\n\n\t\tif (this.isCfiString(cfi)) {\n\t\t\treturn \"string\";\n\t\t// Is a range object\n\t\t} else if (cfi && typeof cfi === \"object\" && (type(cfi) === \"Range\" || typeof(cfi.startContainer) != \"undefined\")){\n\t\t\treturn \"range\";\n\t\t} else if (cfi && typeof cfi === \"object\" && typeof(cfi.nodeType) != \"undefined\" ){ // || typeof cfi === \"function\"\n\t\t\treturn \"node\";\n\t\t} else if (cfi && typeof cfi === \"object\" && cfi instanceof EpubCFI){\n\t\t\treturn \"EpubCFI\";\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Parse a cfi string to a CFI object representation\n\t * @param {string} cfiStr\n\t * @returns {object} cfi\n\t */\n\tparse(cfiStr) {\n\t\tvar cfi = {\n\t\t\tspinePos: -1,\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\t\tvar baseComponent, pathComponent, range;\n\n\t\tif(typeof cfiStr !== \"string\") {\n\t\t\treturn {spinePos: -1};\n\t\t}\n\n\t\tif(cfiStr.indexOf(\"epubcfi(\") === 0 && cfiStr[cfiStr.length-1] === \")\") {\n\t\t\t// Remove initial epubcfi( and ending )\n\t\t\tcfiStr = cfiStr.slice(8, cfiStr.length-1);\n\t\t}\n\n\t\tbaseComponent = this.getChapterComponent(cfiStr);\n\n\t\t// Make sure this is a valid cfi or return\n\t\tif(!baseComponent) {\n\t\t\treturn {spinePos: -1};\n\t\t}\n\n\t\tcfi.base = this.parseComponent(baseComponent);\n\n\t\tpathComponent = this.getPathComponent(cfiStr);\n\t\tcfi.path = this.parseComponent(pathComponent);\n\n\t\trange = this.getRange(cfiStr);\n\n\t\tif(range) {\n\t\t\tcfi.range = true;\n\t\t\tcfi.start = this.parseComponent(range[0]);\n\t\t\tcfi.end = this.parseComponent(range[1]);\n\t\t}\n\n\t\t// Get spine node position\n\t\t// cfi.spineSegment = cfi.base.steps[1];\n\n\t\t// Chapter segment is always the second step\n\t\tcfi.spinePos = cfi.base.steps[1].index;\n\n\t\treturn cfi;\n\t}\n\n\tparseComponent(componentStr){\n\t\tvar component = {\n\t\t\tsteps: [],\n\t\t\tterminal: {\n\t\t\t\toffset: null,\n\t\t\t\tassertion: null\n\t\t\t}\n\t\t};\n\t\tvar parts = componentStr.split(\":\");\n\t\tvar steps = parts[0].split(\"/\");\n\t\tvar terminal;\n\n\t\tif(parts.length > 1) {\n\t\t\tterminal = parts[1];\n\t\t\tcomponent.terminal = this.parseTerminal(terminal);\n\t\t}\n\n\t\tif (steps[0] === \"\") {\n\t\t\tsteps.shift(); // Ignore the first slash\n\t\t}\n\n\t\tcomponent.steps = steps.map(function(step){\n\t\t\treturn this.parseStep(step);\n\t\t}.bind(this));\n\n\t\treturn component;\n\t}\n\n\tparseStep(stepStr){\n\t\tvar type, num, index, has_brackets, id;\n\n\t\thas_brackets = stepStr.match(/\\[(.*)\\]/);\n\t\tif(has_brackets && has_brackets[1]){\n\t\t\tid = has_brackets[1];\n\t\t}\n\n\t\t//-- Check if step is a text node or element\n\t\tnum = parseInt(stepStr);\n\n\t\tif(isNaN(num)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(num % 2 === 0) { // Even = is an element\n\t\t\ttype = \"element\";\n\t\t\tindex = num / 2 - 1;\n\t\t} else {\n\t\t\ttype = \"text\";\n\t\t\tindex = (num - 1 ) / 2;\n\t\t}\n\n\t\treturn {\n\t\t\t\"type\" : type,\n\t\t\t\"index\" : index,\n\t\t\t\"id\" : id || null\n\t\t};\n\t}\n\n\tparseTerminal(termialStr){\n\t\tvar characterOffset, textLocationAssertion;\n\t\tvar assertion = termialStr.match(/\\[(.*)\\]/);\n\n\t\tif(assertion && assertion[1]){\n\t\t\tcharacterOffset = parseInt(termialStr.split(\"[\")[0]);\n\t\t\ttextLocationAssertion = assertion[1];\n\t\t} else {\n\t\t\tcharacterOffset = parseInt(termialStr);\n\t\t}\n\n\t\tif (!isNumber(characterOffset)) {\n\t\t\tcharacterOffset = null;\n\t\t}\n\n\t\treturn {\n\t\t\t\"offset\": characterOffset,\n\t\t\t\"assertion\": textLocationAssertion\n\t\t};\n\n\t}\n\n\tgetChapterComponent(cfiStr) {\n\n\t\tvar indirection = cfiStr.split(\"!\");\n\n\t\treturn indirection[0];\n\t}\n\n\tgetPathComponent(cfiStr) {\n\n\t\tvar indirection = cfiStr.split(\"!\");\n\n\t\tif(indirection[1]) {\n\t\t\tlet ranges = indirection[1].split(\",\");\n\t\t\treturn ranges[0];\n\t\t}\n\n\t}\n\n\tgetRange(cfiStr) {\n\n\t\tvar ranges = cfiStr.split(\",\");\n\n\t\tif(ranges.length === 3){\n\t\t\treturn [\n\t\t\t\tranges[1],\n\t\t\t\tranges[2]\n\t\t\t];\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetCharecterOffsetComponent(cfiStr) {\n\t\tvar splitStr = cfiStr.split(\":\");\n\t\treturn splitStr[1] || \"\";\n\t}\n\n\tjoinSteps(steps) {\n\t\tif(!steps) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn steps.map(function(part){\n\t\t\tvar segment = \"\";\n\n\t\t\tif(part.type === \"element\") {\n\t\t\t\tsegment += (part.index + 1) * 2;\n\t\t\t}\n\n\t\t\tif(part.type === \"text\") {\n\t\t\t\tsegment += 1 + (2 * part.index); // TODO: double check that this is odd\n\t\t\t}\n\n\t\t\tif(part.id) {\n\t\t\t\tsegment += \"[\" + part.id + \"]\";\n\t\t\t}\n\n\t\t\treturn segment;\n\n\t\t}).join(\"/\");\n\n\t}\n\n\tsegmentString(segment) {\n\t\tvar segmentString = \"/\";\n\n\t\tsegmentString += this.joinSteps(segment.steps);\n\n\t\tif(segment.terminal && segment.terminal.offset != null){\n\t\t\tsegmentString += \":\" + segment.terminal.offset;\n\t\t}\n\n\t\tif(segment.terminal && segment.terminal.assertion != null){\n\t\t\tsegmentString += \"[\" + segment.terminal.assertion + \"]\";\n\t\t}\n\n\t\treturn segmentString;\n\t}\n\n\t/**\n\t * Convert CFI to a epubcfi(...) string\n\t * @returns {string} epubcfi\n\t */\n\ttoString() {\n\t\tvar cfiString = \"epubcfi(\";\n\n\t\tcfiString += this.segmentString(this.base);\n\n\t\tcfiString += \"!\";\n\t\tcfiString += this.segmentString(this.path);\n\n\t\t// Add Range, if present\n\t\tif(this.range && this.start) {\n\t\t\tcfiString += \",\";\n\t\t\tcfiString += this.segmentString(this.start);\n\t\t}\n\n\t\tif(this.range && this.end) {\n\t\t\tcfiString += \",\";\n\t\t\tcfiString += this.segmentString(this.end);\n\t\t}\n\n\t\tcfiString += \")\";\n\n\t\treturn cfiString;\n\t}\n\n\n\t/**\n\t * Compare which of two CFIs is earlier in the text\n\t * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0\n\t */\n\tcompare(cfiOne, cfiTwo) {\n\t\tvar stepsA, stepsB;\n\t\tvar terminalA, terminalB;\n\n\t\tvar rangeAStartSteps, rangeAEndSteps;\n\t\tvar rangeBEndSteps, rangeBEndSteps;\n\t\tvar rangeAStartTerminal, rangeAEndTerminal;\n\t\tvar rangeBStartTerminal, rangeBEndTerminal;\n\n\t\tif(typeof cfiOne === \"string\") {\n\t\t\tcfiOne = new EpubCFI(cfiOne);\n\t\t}\n\t\tif(typeof cfiTwo === \"string\") {\n\t\t\tcfiTwo = new EpubCFI(cfiTwo);\n\t\t}\n\t\t// Compare Spine Positions\n\t\tif(cfiOne.spinePos > cfiTwo.spinePos) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(cfiOne.spinePos < cfiTwo.spinePos) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (cfiOne.range) {\n\t\t\tstepsA = cfiOne.path.steps.concat(cfiOne.start.steps);\n\t\t\tterminalA = cfiOne.start.terminal;\n\t\t} else {\n\t\t\tstepsA = cfiOne.path.steps;\n\t\t\tterminalA = cfiOne.path.terminal;\n\t\t}\n\n\t\tif (cfiTwo.range) {\n\t\t\tstepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);\n\t\t\tterminalB = cfiTwo.start.terminal;\n\t\t} else {\n\t\t\tstepsB = cfiTwo.path.steps;\n\t\t\tterminalB = cfiTwo.path.terminal;\n\t\t}\n\n\t\t// Compare Each Step in the First item\n\t\tfor (var i = 0; i < stepsA.length; i++) {\n\t\t\tif(!stepsA[i]) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(!stepsB[i]) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(stepsA[i].index > stepsB[i].index) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(stepsA[i].index < stepsB[i].index) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// Otherwise continue checking\n\t\t}\n\n\t\t// All steps in First equal to Second and First is Less Specific\n\t\tif(stepsA.length < stepsB.length) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Compare the character offset of the text node\n\t\tif(terminalA.offset > terminalB.offset) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(terminalA.offset < terminalB.offset) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// CFI's are equal\n\t\treturn 0;\n\t}\n\n\tstep(node) {\n\t\tvar nodeType = (node.nodeType === TEXT_NODE) ? \"text\" : \"element\";\n\n\t\treturn {\n\t\t\t\"id\" : node.id,\n\t\t\t\"tagName\" : node.tagName,\n\t\t\t\"type\" : nodeType,\n\t\t\t\"index\" : this.position(node)\n\t\t};\n\t}\n\n\tfilteredStep(node, ignoreClass) {\n\t\tvar filteredNode = this.filter(node, ignoreClass);\n\t\tvar nodeType;\n\n\t\t// Node filtered, so ignore\n\t\tif (!filteredNode) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise add the filter node in\n\t\tnodeType = (filteredNode.nodeType === TEXT_NODE) ? \"text\" : \"element\";\n\n\t\treturn {\n\t\t\t\"id\" : filteredNode.id,\n\t\t\t\"tagName\" : filteredNode.tagName,\n\t\t\t\"type\" : nodeType,\n\t\t\t\"index\" : this.filteredPosition(filteredNode, ignoreClass)\n\t\t};\n\t}\n\n\tpathTo(node, offset, ignoreClass) {\n\t\tvar segment = {\n\t\t\tsteps: [],\n\t\t\tterminal: {\n\t\t\t\toffset: null,\n\t\t\t\tassertion: null\n\t\t\t}\n\t\t};\n\t\tvar currentNode = node;\n\t\tvar step;\n\n\t\twhile(currentNode && currentNode.parentNode &&\n\t\t\t\t\tcurrentNode.parentNode.nodeType != DOCUMENT_NODE) {\n\n\t\t\tif (ignoreClass) {\n\t\t\t\tstep = this.filteredStep(currentNode, ignoreClass);\n\t\t\t} else {\n\t\t\t\tstep = this.step(currentNode);\n\t\t\t}\n\n\t\t\tif (step) {\n\t\t\t\tsegment.steps.unshift(step);\n\t\t\t}\n\n\t\t\tcurrentNode = currentNode.parentNode;\n\n\t\t}\n\n\t\tif (offset != null && offset >= 0) {\n\n\t\t\tsegment.terminal.offset = offset;\n\n\t\t\t// Make sure we are getting to a textNode if there is an offset\n\t\t\tif(segment.steps[segment.steps.length-1].type != \"text\") {\n\t\t\t\tsegment.steps.push({\n\t\t\t\t\t\"type\" : \"text\",\n\t\t\t\t\t\"index\" : 0\n\t\t\t\t});\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn segment;\n\t}\n\n\tequalStep(stepA, stepB) {\n\t\tif (!stepA || !stepB) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif(stepA.index === stepB.index &&\n\t\t\t stepA.id === stepB.id &&\n\t\t\t stepA.type === stepB.type) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create a CFI object from a Range\n\t * @param {Range} range\n\t * @param {string | object} base\n\t * @param {string} [ignoreClass]\n\t * @returns {object} cfi\n\t */\n\tfromRange(range, base, ignoreClass) {\n\t\tvar cfi = {\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\n\t\tvar start = range.startContainer;\n\t\tvar end = range.endContainer;\n\n\t\tvar startOffset = range.startOffset;\n\t\tvar endOffset = range.endOffset;\n\n\t\tvar needsIgnoring = false;\n\n\t\tif (ignoreClass) {\n\t\t\t// Tell pathTo if / what to ignore\n\t\t\tneedsIgnoring = (start.ownerDocument.querySelector(\".\" + ignoreClass) != null);\n\t\t}\n\n\n\t\tif (typeof base === \"string\") {\n\t\t\tcfi.base = this.parseComponent(base);\n\t\t\tcfi.spinePos = cfi.base.steps[1].index;\n\t\t} else if (typeof base === \"object\") {\n\t\t\tcfi.base = base;\n\t\t}\n\n\t\tif (range.collapsed) {\n\t\t\tif (needsIgnoring) {\n\t\t\t\tstartOffset = this.patchOffset(start, startOffset, ignoreClass);\n\t\t\t}\n\t\t\tcfi.path = this.pathTo(start, startOffset, ignoreClass);\n\t\t} else {\n\t\t\tcfi.range = true;\n\n\t\t\tif (needsIgnoring) {\n\t\t\t\tstartOffset = this.patchOffset(start, startOffset, ignoreClass);\n\t\t\t}\n\n\t\t\tcfi.start = this.pathTo(start, startOffset, ignoreClass);\n\t\t\tif (needsIgnoring) {\n\t\t\t\tendOffset = this.patchOffset(end, endOffset, ignoreClass);\n\t\t\t}\n\n\t\t\tcfi.end = this.pathTo(end, endOffset, ignoreClass);\n\n\t\t\t// Create a new empty path\n\t\t\tcfi.path = {\n\t\t\t\tsteps: [],\n\t\t\t\tterminal: null\n\t\t\t};\n\n\t\t\t// Push steps that are shared between start and end to the common path\n\t\t\tvar len = cfi.start.steps.length;\n\t\t\tvar i;\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n\t\t\t\t\tif(i === len-1) {\n\t\t\t\t\t\t// Last step is equal, check terminals\n\t\t\t\t\t\tif(cfi.start.terminal === cfi.end.terminal) {\n\t\t\t\t\t\t\t// CFI's are equal\n\t\t\t\t\t\t\tcfi.path.steps.push(cfi.start.steps[i]);\n\t\t\t\t\t\t\t// Not a range\n\t\t\t\t\t\t\tcfi.range = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcfi.path.steps.push(cfi.start.steps[i]);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);\n\t\t\tcfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length);\n\n\t\t\t// TODO: Add Sanity check to make sure that the end if greater than the start\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Create a CFI object from a Node\n\t * @param {Node} anchor\n\t * @param {string | object} base\n\t * @param {string} [ignoreClass]\n\t * @returns {object} cfi\n\t */\n\tfromNode(anchor, base, ignoreClass) {\n\t\tvar cfi = {\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\n\t\tif (typeof base === \"string\") {\n\t\t\tcfi.base = this.parseComponent(base);\n\t\t\tcfi.spinePos = cfi.base.steps[1].index;\n\t\t} else if (typeof base === \"object\") {\n\t\t\tcfi.base = base;\n\t\t}\n\n\t\tcfi.path = this.pathTo(anchor, null, ignoreClass);\n\n\t\treturn cfi;\n\t}\n\n\tfilter(anchor, ignoreClass) {\n\t\tvar needsIgnoring;\n\t\tvar sibling; // to join with\n\t\tvar parent, previousSibling, nextSibling;\n\t\tvar isText = false;\n\n\t\tif (anchor.nodeType === TEXT_NODE) {\n\t\t\tisText = true;\n\t\t\tparent = anchor.parentNode;\n\t\t\tneedsIgnoring = anchor.parentNode.classList.contains(ignoreClass);\n\t\t} else {\n\t\t\tisText = false;\n\t\t\tneedsIgnoring = anchor.classList.contains(ignoreClass);\n\t\t}\n\n\t\tif (needsIgnoring && isText) {\n\t\t\tpreviousSibling = parent.previousSibling;\n\t\t\tnextSibling = parent.nextSibling;\n\n\t\t\t// If the sibling is a text node, join the nodes\n\t\t\tif (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n\t\t\t\tsibling = previousSibling;\n\t\t\t} else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {\n\t\t\t\tsibling = nextSibling;\n\t\t\t}\n\n\t\t\tif (sibling) {\n\t\t\t\treturn sibling;\n\t\t\t} else {\n\t\t\t\t// Parent will be ignored on next step\n\t\t\t\treturn anchor;\n\t\t\t}\n\n\t\t} else if (needsIgnoring && !isText) {\n\t\t\t// Otherwise just skip the element node\n\t\t\treturn false;\n\t\t} else {\n\t\t\t// No need to filter\n\t\t\treturn anchor;\n\t\t}\n\n\t}\n\n\tpatchOffset(anchor, offset, ignoreClass) {\n\t\tif (anchor.nodeType != TEXT_NODE) {\n\t\t\tthrow new Error(\"Anchor must be a text node\");\n\t\t}\n\n\t\tvar curr = anchor;\n\t\tvar totalOffset = offset;\n\n\t\t// If the parent is a ignored node, get offset from it's start\n\t\tif (anchor.parentNode.classList.contains(ignoreClass)) {\n\t\t\tcurr = anchor.parentNode;\n\t\t}\n\n\t\twhile (curr.previousSibling) {\n\t\t\tif(curr.previousSibling.nodeType === ELEMENT_NODE) {\n\t\t\t\t// Originally a text node, so join\n\t\t\t\tif(curr.previousSibling.classList.contains(ignoreClass)){\n\t\t\t\t\ttotalOffset += curr.previousSibling.textContent.length;\n\t\t\t\t} else {\n\t\t\t\t\tbreak; // Normal node, dont join\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If the previous sibling is a text node, join the nodes\n\t\t\t\ttotalOffset += curr.previousSibling.textContent.length;\n\t\t\t}\n\n\t\t\tcurr = curr.previousSibling;\n\t\t}\n\n\t\treturn totalOffset;\n\n\t}\n\n\tnormalizedMap(children, nodeType, ignoreClass) {\n\t\tvar output = {};\n\t\tvar prevIndex = -1;\n\t\tvar i, len = children.length;\n\t\tvar currNodeType;\n\t\tvar prevNodeType;\n\n\t\tfor (i = 0; i < len; i++) {\n\n\t\t\tcurrNodeType = children[i].nodeType;\n\n\t\t\t// Check if needs ignoring\n\t\t\tif (currNodeType === ELEMENT_NODE &&\n\t\t\t\t\tchildren[i].classList.contains(ignoreClass)) {\n\t\t\t\tcurrNodeType = TEXT_NODE;\n\t\t\t}\n\n\t\t\tif (i > 0 &&\n\t\t\t\t\tcurrNodeType === TEXT_NODE &&\n\t\t\t\t\tprevNodeType === TEXT_NODE) {\n\t\t\t\t// join text nodes\n\t\t\t\toutput[i] = prevIndex;\n\t\t\t} else if (nodeType === currNodeType){\n\t\t\t\tprevIndex = prevIndex + 1;\n\t\t\t\toutput[i] = prevIndex;\n\t\t\t}\n\n\t\t\tprevNodeType = currNodeType;\n\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tposition(anchor) {\n\t\tvar children, index;\n\t\tif (anchor.nodeType === ELEMENT_NODE) {\n\t\t\tchildren = anchor.parentNode.children;\n\t\t\tif (!children) {\n\t\t\t\tchildren = findChildren(anchor.parentNode);\n\t\t\t}\n\t\t\tindex = Array.prototype.indexOf.call(children, anchor);\n\t\t} else {\n\t\t\tchildren = this.textNodes(anchor.parentNode);\n\t\t\tindex = children.indexOf(anchor);\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tfilteredPosition(anchor, ignoreClass) {\n\t\tvar children, index, map;\n\n\t\tif (anchor.nodeType === ELEMENT_NODE) {\n\t\t\tchildren = anchor.parentNode.children;\n\t\t\tmap = this.normalizedMap(children, ELEMENT_NODE, ignoreClass);\n\t\t} else {\n\t\t\tchildren = anchor.parentNode.childNodes;\n\t\t\t// Inside an ignored node\n\t\t\tif(anchor.parentNode.classList.contains(ignoreClass)) {\n\t\t\t\tanchor = anchor.parentNode;\n\t\t\t\tchildren = anchor.parentNode.childNodes;\n\t\t\t}\n\t\t\tmap = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n\t\t}\n\n\n\t\tindex = Array.prototype.indexOf.call(children, anchor);\n\n\t\treturn map[index];\n\t}\n\n\tstepsToXpath(steps) {\n\t\tvar xpath = [\".\", \"*\"];\n\n\t\tsteps.forEach(function(step){\n\t\t\tvar position = step.index + 1;\n\n\t\t\tif(step.id){\n\t\t\t\txpath.push(\"*[position()=\" + position + \" and @id='\" + step.id + \"']\");\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\txpath.push(\"text()[\" + position + \"]\");\n\t\t\t} else {\n\t\t\t\txpath.push(\"*[\" + position + \"]\");\n\t\t\t}\n\t\t});\n\n\t\treturn xpath.join(\"/\");\n\t}\n\n\n\t/*\n\n\tTo get the last step if needed:\n\n\t// Get the terminal step\n\tlastStep = steps[steps.length-1];\n\t// Get the query string\n\tquery = this.stepsToQuery(steps);\n\t// Find the containing element\n\tstartContainerParent = doc.querySelector(query);\n\t// Find the text node within that element\n\tif(startContainerParent && lastStep.type == \"text\") {\n\t\tcontainer = startContainerParent.childNodes[lastStep.index];\n\t}\n\t*/\n\tstepsToQuerySelector(steps) {\n\t\tvar query = [\"html\"];\n\n\t\tsteps.forEach(function(step){\n\t\t\tvar position = step.index + 1;\n\n\t\t\tif(step.id){\n\t\t\t\tquery.push(\"#\" + step.id);\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\t// unsupported in querySelector\n\t\t\t\t// query.push(\"text()[\" + position + \"]\");\n\t\t\t} else {\n\t\t\t\tquery.push(\"*:nth-child(\" + position + \")\");\n\t\t\t}\n\t\t});\n\n\t\treturn query.join(\">\");\n\n\t}\n\n\ttextNodes(container, ignoreClass) {\n\t\treturn Array.prototype.slice.call(container.childNodes).\n\t\t\tfilter(function (node) {\n\t\t\t\tif (node.nodeType === TEXT_NODE) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (ignoreClass && node.classList.contains(ignoreClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t}\n\n\twalkToNode(steps, _doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar container = doc.documentElement;\n\t\tvar children;\n\t\tvar step;\n\t\tvar len = steps.length;\n\t\tvar i;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tstep = steps[i];\n\n\t\t\tif(step.type === \"element\") {\n\t\t\t\t//better to get a container using id as some times step.index may not be correct\n\t\t\t\t//For ex.https://github.com/futurepress/epub.js/issues/561\n\t\t\t\tif(step.id) {\n\t\t\t\t\tcontainer = doc.getElementById(step.id);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchildren = container.children || findChildren(container);\n\t\t\t\t\tcontainer = children[step.index];\n\t\t\t\t}\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\tcontainer = this.textNodes(container, ignoreClass)[step.index];\n\t\t\t}\n\t\t\tif(!container) {\n\t\t\t\t//Break the for loop as due to incorrect index we can get error if\n\t\t\t\t//container is undefined so that other functionailties works fine\n\t\t\t\t//like navigation\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\treturn container;\n\t}\n\n\tfindNode(steps, _doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar container;\n\t\tvar xpath;\n\n\t\tif(!ignoreClass && typeof doc.evaluate != \"undefined\") {\n\t\t\txpath = this.stepsToXpath(steps);\n\t\t\tcontainer = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n\t\t} else if(ignoreClass) {\n\t\t\tcontainer = this.walkToNode(steps, doc, ignoreClass);\n\t\t} else {\n\t\t\tcontainer = this.walkToNode(steps, doc);\n\t\t}\n\n\t\treturn container;\n\t}\n\n\tfixMiss(steps, offset, _doc, ignoreClass) {\n\t\tvar container = this.findNode(steps.slice(0,-1), _doc, ignoreClass);\n\t\tvar children = container.childNodes;\n\t\tvar map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n\t\tvar child;\n\t\tvar len;\n\t\tvar lastStepIndex = steps[steps.length-1].index;\n\n\t\tfor (let childIndex in map) {\n\t\t\tif (!map.hasOwnProperty(childIndex)) return;\n\n\t\t\tif(map[childIndex] === lastStepIndex) {\n\t\t\t\tchild = children[childIndex];\n\t\t\t\tlen = child.textContent.length;\n\t\t\t\tif(offset > len) {\n\t\t\t\t\toffset = offset - len;\n\t\t\t\t} else {\n\t\t\t\t\tif (child.nodeType === ELEMENT_NODE) {\n\t\t\t\t\t\tcontainer = child.childNodes[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontainer = child;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tcontainer: container,\n\t\t\toffset: offset\n\t\t};\n\n\t}\n\n\t/**\n\t * Creates a DOM range representing a CFI\n\t * @param {document} _doc document referenced in the base\n\t * @param {string} [ignoreClass]\n\t * @return {Range}\n\t */\n\ttoRange(_doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar range;\n\t\tvar start, end, startContainer, endContainer;\n\t\tvar cfi = this;\n\t\tvar startSteps, endSteps;\n\t\tvar needsIgnoring = ignoreClass ? (doc.querySelector(\".\" + ignoreClass) != null) : false;\n\t\tvar missed;\n\n\t\tif (typeof(doc.createRange) !== \"undefined\") {\n\t\t\trange = doc.createRange();\n\t\t} else {\n\t\t\trange = new RangeObject();\n\t\t}\n\n\t\tif (cfi.range) {\n\t\t\tstart = cfi.start;\n\t\t\tstartSteps = cfi.path.steps.concat(start.steps);\n\t\t\tstartContainer = this.findNode(startSteps, doc, needsIgnoring ? ignoreClass : null);\n\t\t\tend = cfi.end;\n\t\t\tendSteps = cfi.path.steps.concat(end.steps);\n\t\t\tendContainer = this.findNode(endSteps, doc, needsIgnoring ? ignoreClass : null);\n\t\t} else {\n\t\t\tstart = cfi.path;\n\t\t\tstartSteps = cfi.path.steps;\n\t\t\tstartContainer = this.findNode(cfi.path.steps, doc, needsIgnoring ? ignoreClass : null);\n\t\t}\n\n\t\tif(startContainer) {\n\t\t\ttry {\n\n\t\t\t\tif(start.terminal.offset != null) {\n\t\t\t\t\trange.setStart(startContainer, start.terminal.offset);\n\t\t\t\t} else {\n\t\t\t\t\trange.setStart(startContainer, 0);\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\t\t\t\tmissed = this.fixMiss(startSteps, start.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n\t\t\t\trange.setStart(missed.container, missed.offset);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log(\"No startContainer found for\", this.toString());\n\t\t\t// No start found\n\t\t\treturn null;\n\t\t}\n\n\t\tif (endContainer) {\n\t\t\ttry {\n\n\t\t\t\tif(end.terminal.offset != null) {\n\t\t\t\t\trange.setEnd(endContainer, end.terminal.offset);\n\t\t\t\t} else {\n\t\t\t\t\trange.setEnd(endContainer, 0);\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\t\t\t\tmissed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n\t\t\t\trange.setEnd(missed.container, missed.offset);\n\t\t\t}\n\t\t}\n\n\n\t\t// doc.defaultView.getSelection().addRange(range);\n\t\treturn range;\n\t}\n\n\t/**\n\t * Check if a string is wrapped with \"epubcfi()\"\n\t * @param {string} str\n\t * @returns {boolean}\n\t */\n\tisCfiString(str) {\n\t\tif(typeof str === \"string\" &&\n\t\t\tstr.indexOf(\"epubcfi(\") === 0 &&\n\t\t\tstr[str.length-1] === \")\") {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgenerateChapterComponent(_spineNodeIndex, _pos, id) {\n\t\tvar pos = parseInt(_pos),\n\t\t\t\tspineNodeIndex = (_spineNodeIndex + 1) * 2,\n\t\t\t\tcfi = \"/\"+spineNodeIndex+\"/\";\n\n\t\tcfi += (pos + 1) * 2;\n\n\t\tif(id) {\n\t\t\tcfi += \"[\" + id + \"]\";\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Collapse a CFI Range to a single CFI Position\n\t * @param {boolean} [toStart=false]\n\t */\n\tcollapse(toStart) {\n\t\tif (!this.range) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.range = false;\n\n\t\tif (toStart) {\n\t\t\tthis.path.steps = this.path.steps.concat(this.start.steps);\n\t\t\tthis.path.terminal = this.start.terminal;\n\t\t} else {\n\t\t\tthis.path.steps = this.path.steps.concat(this.end.steps);\n\t\t\tthis.path.terminal = this.end.terminal;\n\t\t}\n\n\t}\n}\n\nexport default EpubCFI;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}