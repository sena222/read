{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.proxyMouse = proxyMouse;\nexports.clone = clone;\n// import 'babelify/polyfill'; // needed for Object.assign\n\nexports.default = {\n  proxyMouse: proxyMouse\n};\n\n/**\n * Start proxying all mouse events that occur on the target node to each node in\n * a set of tracked nodes.\n *\n * The items in tracked do not strictly have to be DOM Nodes, but they do have\n * to have dispatchEvent, getBoundingClientRect, and getClientRects methods.\n *\n * @param target {Node} The node on which to listen for mouse events.\n * @param tracked {Node[]} A (possibly mutable) array of nodes to which to proxy\n *                         events.\n */\n\nfunction proxyMouse(target, tracked) {\n  function dispatch(e) {\n    // We walk through the set of tracked elements in reverse order so that\n    // events are sent to those most recently added first.\n    //\n    // This is the least surprising behaviour as it simulates the way the\n    // browser would work if items added later were drawn \"on top of\"\n    // earlier ones.\n    for (var i = tracked.length - 1; i >= 0; i--) {\n      var t = tracked[i];\n      var x = e.clientX;\n      var y = e.clientY;\n      if (e.touches && e.touches.length) {\n        x = e.touches[0].clientX;\n        y = e.touches[0].clientY;\n      }\n      if (!contains(t, target, x, y)) {\n        continue;\n      }\n\n      // The event targets this mark, so dispatch a cloned event:\n      t.dispatchEvent(clone(e));\n      // We only dispatch the cloned event to the first matching mark.\n      break;\n    }\n  }\n  if (target.nodeName === \"iframe\" || target.nodeName === \"IFRAME\") {\n    try {\n      // Try to get the contents if same domain\n      this.target = target.contentDocument;\n    } catch (err) {\n      this.target = target;\n    }\n  } else {\n    this.target = target;\n  }\n  var _arr = ['mouseup', 'mousedown', 'click', 'touchstart'];\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var ev = _arr[_i];\n    this.target.addEventListener(ev, function (e) {\n      return dispatch(e);\n    }, false);\n  }\n}\n\n/**\n * Clone a mouse event object.\n *\n * @param e {MouseEvent} A mouse event object to clone.\n * @returns {MouseEvent}\n */\nfunction clone(e) {\n  var opts = Object.assign({}, e, {\n    bubbles: false\n  });\n  try {\n    return new MouseEvent(e.type, opts);\n  } catch (err) {\n    // compat: webkit\n    var copy = document.createEvent('MouseEvents');\n    copy.initMouseEvent(e.type, false, opts.cancelable, opts.view, opts.detail, opts.screenX, opts.screenY, opts.clientX, opts.clientY, opts.ctrlKey, opts.altKey, opts.shiftKey, opts.metaKey, opts.button, opts.relatedTarget);\n    return copy;\n  }\n}\n\n/**\n * Check if the item contains the point denoted by the passed coordinates\n * @param item {Object} An object with getBoundingClientRect and getClientRects\n *                      methods.\n * @param x {Number}\n * @param y {Number}\n * @returns {Boolean}\n */\nfunction contains(item, target, x, y) {\n  // offset\n  var offset = target.getBoundingClientRect();\n  function rectContains(r, x, y) {\n    var top = r.top - offset.top;\n    var left = r.left - offset.left;\n    var bottom = top + r.height;\n    var right = left + r.width;\n    return top <= y && left <= x && bottom > y && right > x;\n  }\n\n  // Check overall bounding box first\n  var rect = item.getBoundingClientRect();\n  if (!rectContains(rect, x, y)) {\n    return false;\n  }\n\n  // Then continue to check each child rect\n  var rects = item.getClientRects();\n  for (var i = 0, len = rects.length; i < len; i++) {\n    if (rectContains(rects[i], x, y)) {\n      return true;\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","proxyMouse","clone","default","target","tracked","dispatch","e","i","length","t","x","clientX","y","clientY","touches","contains","dispatchEvent","nodeName","contentDocument","err","_arr","_i","ev","addEventListener","opts","assign","bubbles","MouseEvent","type","copy","document","createEvent","initMouseEvent","cancelable","view","detail","screenX","screenY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","item","offset","getBoundingClientRect","rectContains","r","top","left","bottom","height","right","width","rect","rects","getClientRects","len"],"sources":["/home/parallels/Downloads/read/node_modules/marks-pane/lib/events.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.proxyMouse = proxyMouse;\nexports.clone = clone;\n// import 'babelify/polyfill'; // needed for Object.assign\n\nexports.default = {\n    proxyMouse: proxyMouse\n};\n\n/**\n * Start proxying all mouse events that occur on the target node to each node in\n * a set of tracked nodes.\n *\n * The items in tracked do not strictly have to be DOM Nodes, but they do have\n * to have dispatchEvent, getBoundingClientRect, and getClientRects methods.\n *\n * @param target {Node} The node on which to listen for mouse events.\n * @param tracked {Node[]} A (possibly mutable) array of nodes to which to proxy\n *                         events.\n */\n\nfunction proxyMouse(target, tracked) {\n    function dispatch(e) {\n        // We walk through the set of tracked elements in reverse order so that\n        // events are sent to those most recently added first.\n        //\n        // This is the least surprising behaviour as it simulates the way the\n        // browser would work if items added later were drawn \"on top of\"\n        // earlier ones.\n        for (var i = tracked.length - 1; i >= 0; i--) {\n            var t = tracked[i];\n            var x = e.clientX;\n            var y = e.clientY;\n\n            if (e.touches && e.touches.length) {\n                x = e.touches[0].clientX;\n                y = e.touches[0].clientY;\n            }\n\n            if (!contains(t, target, x, y)) {\n                continue;\n            }\n\n            // The event targets this mark, so dispatch a cloned event:\n            t.dispatchEvent(clone(e));\n            // We only dispatch the cloned event to the first matching mark.\n            break;\n        }\n    }\n\n    if (target.nodeName === \"iframe\" || target.nodeName === \"IFRAME\") {\n\n        try {\n            // Try to get the contents if same domain\n            this.target = target.contentDocument;\n        } catch (err) {\n            this.target = target;\n        }\n    } else {\n        this.target = target;\n    }\n\n    var _arr = ['mouseup', 'mousedown', 'click', 'touchstart'];\n    for (var _i = 0; _i < _arr.length; _i++) {\n        var ev = _arr[_i];\n        this.target.addEventListener(ev, function (e) {\n            return dispatch(e);\n        }, false);\n    }\n}\n\n/**\n * Clone a mouse event object.\n *\n * @param e {MouseEvent} A mouse event object to clone.\n * @returns {MouseEvent}\n */\nfunction clone(e) {\n    var opts = Object.assign({}, e, { bubbles: false });\n    try {\n        return new MouseEvent(e.type, opts);\n    } catch (err) {\n        // compat: webkit\n        var copy = document.createEvent('MouseEvents');\n        copy.initMouseEvent(e.type, false, opts.cancelable, opts.view, opts.detail, opts.screenX, opts.screenY, opts.clientX, opts.clientY, opts.ctrlKey, opts.altKey, opts.shiftKey, opts.metaKey, opts.button, opts.relatedTarget);\n        return copy;\n    }\n}\n\n/**\n * Check if the item contains the point denoted by the passed coordinates\n * @param item {Object} An object with getBoundingClientRect and getClientRects\n *                      methods.\n * @param x {Number}\n * @param y {Number}\n * @returns {Boolean}\n */\nfunction contains(item, target, x, y) {\n    // offset\n    var offset = target.getBoundingClientRect();\n\n    function rectContains(r, x, y) {\n        var top = r.top - offset.top;\n        var left = r.left - offset.left;\n        var bottom = top + r.height;\n        var right = left + r.width;\n        return top <= y && left <= x && bottom > y && right > x;\n    }\n\n    // Check overall bounding box first\n    var rect = item.getBoundingClientRect();\n    if (!rectContains(rect, x, y)) {\n        return false;\n    }\n\n    // Then continue to check each child rect\n    var rects = item.getClientRects();\n    for (var i = 0, len = rects.length; i < len; i++) {\n        if (rectContains(rects[i], x, y)) {\n            return true;\n        }\n    }\n    return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}