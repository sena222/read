{"ast":null,"code":"import _classCallCheck from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport EpubCFI from \"./epubcfi\";\nimport Hook from \"./utils/hook\";\nimport Section from \"./section\";\nimport { replaceBase, replaceCanonical, replaceMeta } from \"./utils/replacements\";\n\n/**\n * A collection of Spine Items\n */\nvar Spine = /*#__PURE__*/function () {\n  function Spine() {\n    _classCallCheck(this, Spine);\n    this.spineItems = [];\n    this.spineByHref = {};\n    this.spineById = {};\n    this.hooks = {};\n    this.hooks.serialize = new Hook();\n    this.hooks.content = new Hook();\n\n    // Register replacements\n    this.hooks.content.register(replaceBase);\n    this.hooks.content.register(replaceCanonical);\n    this.hooks.content.register(replaceMeta);\n    this.epubcfi = new EpubCFI();\n    this.loaded = false;\n    this.items = undefined;\n    this.manifest = undefined;\n    this.spineNodeIndex = undefined;\n    this.baseUrl = undefined;\n    this.length = undefined;\n  }\n\n  /**\n   * Unpack items from a opf into spine items\n   * @param  {Packaging} _package\n   * @param  {method} resolver URL resolver\n   * @param  {method} canonical Resolve canonical url\n   */\n  _createClass(Spine, [{\n    key: \"unpack\",\n    value: function unpack(_package, resolver, canonical) {\n      var _this = this;\n      this.items = _package.spine;\n      this.manifest = _package.manifest;\n      this.spineNodeIndex = _package.spineNodeIndex;\n      this.baseUrl = _package.baseUrl || _package.basePath || \"\";\n      this.length = this.items.length;\n      this.items.forEach(function (item, index) {\n        var manifestItem = _this.manifest[item.idref];\n        var spineItem;\n        item.index = index;\n        item.cfiBase = _this.epubcfi.generateChapterComponent(_this.spineNodeIndex, item.index, item.id);\n        if (item.href) {\n          item.url = resolver(item.href, true);\n          item.canonical = canonical(item.href);\n        }\n        if (manifestItem) {\n          item.href = manifestItem.href;\n          item.url = resolver(item.href, true);\n          item.canonical = canonical(item.href);\n          if (manifestItem.properties.length) {\n            item.properties.push.apply(item.properties, manifestItem.properties);\n          }\n        }\n        if (item.linear === \"yes\") {\n          item.prev = function () {\n            var prevIndex = item.index;\n            while (prevIndex > 0) {\n              var prev = this.get(prevIndex - 1);\n              if (prev && prev.linear) {\n                return prev;\n              }\n              prevIndex -= 1;\n            }\n            return;\n          }.bind(_this);\n          item.next = function () {\n            var nextIndex = item.index;\n            while (nextIndex < this.spineItems.length - 1) {\n              var next = this.get(nextIndex + 1);\n              if (next && next.linear) {\n                return next;\n              }\n              nextIndex += 1;\n            }\n            return;\n          }.bind(_this);\n        } else {\n          item.prev = function () {\n            return;\n          };\n          item.next = function () {\n            return;\n          };\n        }\n        spineItem = new Section(item, _this.hooks);\n        _this.append(spineItem);\n      });\n      this.loaded = true;\n    }\n\n    /**\n     * Get an item from the spine\n     * @param  {string|number} [target]\n     * @return {Section} section\n     * @example spine.get();\n     * @example spine.get(1);\n     * @example spine.get(\"chap1.html\");\n     * @example spine.get(\"#id1234\");\n     */\n  }, {\n    key: \"get\",\n    value: function get(target) {\n      var index = 0;\n      if (typeof target === \"undefined\") {\n        while (index < this.spineItems.length) {\n          var next = this.spineItems[index];\n          if (next && next.linear) {\n            break;\n          }\n          index += 1;\n        }\n      } else if (this.epubcfi.isCfiString(target)) {\n        var cfi = new EpubCFI(target);\n        index = cfi.spinePos;\n      } else if (typeof target === \"number\" || isNaN(target) === false) {\n        index = target;\n      } else if (typeof target === \"string\" && target.indexOf(\"#\") === 0) {\n        index = this.spineById[target.substring(1)];\n      } else if (typeof target === \"string\") {\n        // Remove fragments\n        target = target.split(\"#\")[0];\n        index = this.spineByHref[target] || this.spineByHref[encodeURI(target)];\n      }\n      return this.spineItems[index] || null;\n    }\n\n    /**\n     * Append a Section to the Spine\n     * @private\n     * @param  {Section} section\n     */\n  }, {\n    key: \"append\",\n    value: function append(section) {\n      var index = this.spineItems.length;\n      section.index = index;\n      this.spineItems.push(section);\n\n      // Encode and Decode href lookups\n      // see pr for details: https://github.com/futurepress/epub.js/pull/358\n      this.spineByHref[decodeURI(section.href)] = index;\n      this.spineByHref[encodeURI(section.href)] = index;\n      this.spineByHref[section.href] = index;\n      this.spineById[section.idref] = index;\n      return index;\n    }\n\n    /**\n     * Prepend a Section to the Spine\n     * @private\n     * @param  {Section} section\n     */\n  }, {\n    key: \"prepend\",\n    value: function prepend(section) {\n      // var index = this.spineItems.unshift(section);\n      this.spineByHref[section.href] = 0;\n      this.spineById[section.idref] = 0;\n\n      // Re-index\n      this.spineItems.forEach(function (item, index) {\n        item.index = index;\n      });\n      return 0;\n    }\n\n    // insert(section, index) {\n    //\n    // };\n\n    /**\n     * Remove a Section from the Spine\n     * @private\n     * @param  {Section} section\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(section) {\n      var index = this.spineItems.indexOf(section);\n      if (index > -1) {\n        delete this.spineByHref[section.href];\n        delete this.spineById[section.idref];\n        return this.spineItems.splice(index, 1);\n      }\n    }\n\n    /**\n     * Loop over the Sections in the Spine\n     * @return {method} forEach\n     */\n  }, {\n    key: \"each\",\n    value: function each() {\n      return this.spineItems.forEach.apply(this.spineItems, arguments);\n    }\n\n    /**\n     * Find the first Section in the Spine\n     * @return {Section} first section\n     */\n  }, {\n    key: \"first\",\n    value: function first() {\n      var index = 0;\n      do {\n        var next = this.get(index);\n        if (next && next.linear) {\n          return next;\n        }\n        index += 1;\n      } while (index < this.spineItems.length);\n    }\n\n    /**\n     * Find the last Section in the Spine\n     * @return {Section} last section\n     */\n  }, {\n    key: \"last\",\n    value: function last() {\n      var index = this.spineItems.length - 1;\n      do {\n        var prev = this.get(index);\n        if (prev && prev.linear) {\n          return prev;\n        }\n        index -= 1;\n      } while (index >= 0);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.each(function (section) {\n        return section.destroy();\n      });\n      this.spineItems = undefined;\n      this.spineByHref = undefined;\n      this.spineById = undefined;\n      this.hooks.serialize.clear();\n      this.hooks.content.clear();\n      this.hooks = undefined;\n      this.epubcfi = undefined;\n      this.loaded = false;\n      this.items = undefined;\n      this.manifest = undefined;\n      this.spineNodeIndex = undefined;\n      this.baseUrl = undefined;\n      this.length = undefined;\n    }\n  }]);\n  return Spine;\n}();\nexport default Spine;","map":{"version":3,"names":["EpubCFI","Hook","Section","replaceBase","replaceCanonical","replaceMeta","Spine","spineItems","spineByHref","spineById","hooks","serialize","content","register","epubcfi","loaded","items","undefined","manifest","spineNodeIndex","baseUrl","length","_package","resolver","canonical","spine","basePath","forEach","item","index","manifestItem","idref","spineItem","cfiBase","generateChapterComponent","id","href","url","properties","push","apply","linear","prev","prevIndex","get","bind","next","nextIndex","append","target","isCfiString","cfi","spinePos","isNaN","indexOf","substring","split","encodeURI","section","decodeURI","splice","arguments","each","destroy","clear"],"sources":["/home/parallels/Downloads/read/node_modules/epubjs/src/spine.js"],"sourcesContent":["import EpubCFI from \"./epubcfi\";\nimport Hook from \"./utils/hook\";\nimport Section from \"./section\";\nimport {replaceBase, replaceCanonical, replaceMeta} from \"./utils/replacements\";\n\n/**\n * A collection of Spine Items\n */\nclass Spine {\n\tconstructor() {\n\t\tthis.spineItems = [];\n\t\tthis.spineByHref = {};\n\t\tthis.spineById = {};\n\n\t\tthis.hooks = {};\n\t\tthis.hooks.serialize = new Hook();\n\t\tthis.hooks.content = new Hook();\n\n\t\t// Register replacements\n\t\tthis.hooks.content.register(replaceBase);\n\t\tthis.hooks.content.register(replaceCanonical);\n\t\tthis.hooks.content.register(replaceMeta);\n\n\t\tthis.epubcfi = new EpubCFI();\n\n\t\tthis.loaded = false;\n\n\t\tthis.items = undefined;\n\t\tthis.manifest = undefined;\n\t\tthis.spineNodeIndex = undefined;\n\t\tthis.baseUrl = undefined;\n\t\tthis.length = undefined;\n\t}\n\n\t/**\n\t * Unpack items from a opf into spine items\n\t * @param  {Packaging} _package\n\t * @param  {method} resolver URL resolver\n\t * @param  {method} canonical Resolve canonical url\n\t */\n\tunpack(_package, resolver, canonical) {\n\n\t\tthis.items = _package.spine;\n\t\tthis.manifest = _package.manifest;\n\t\tthis.spineNodeIndex = _package.spineNodeIndex;\n\t\tthis.baseUrl = _package.baseUrl || _package.basePath || \"\";\n\t\tthis.length = this.items.length;\n\n\t\tthis.items.forEach( (item, index) => {\n\t\t\tvar manifestItem = this.manifest[item.idref];\n\t\t\tvar spineItem;\n\n\t\t\titem.index = index;\n\t\t\titem.cfiBase = this.epubcfi.generateChapterComponent(this.spineNodeIndex, item.index, item.id);\n\n\t\t\tif (item.href) {\n\t\t\t\titem.url = resolver(item.href, true);\n\t\t\t\titem.canonical = canonical(item.href);\n\t\t\t}\n\n\t\t\tif(manifestItem) {\n\t\t\t\titem.href = manifestItem.href;\n\t\t\t\titem.url = resolver(item.href, true);\n\t\t\t\titem.canonical = canonical(item.href);\n\n\t\t\t\tif(manifestItem.properties.length){\n\t\t\t\t\titem.properties.push.apply(item.properties, manifestItem.properties);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (item.linear === \"yes\") {\n\t\t\t\titem.prev = function() {\n\t\t\t\t\tlet prevIndex = item.index;\n\t\t\t\t\twhile (prevIndex > 0) {\n\t\t\t\t\t\tlet prev = this.get(prevIndex-1);\n\t\t\t\t\t\tif (prev && prev.linear) {\n\t\t\t\t\t\t\treturn prev;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprevIndex -= 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}.bind(this);\n\t\t\t\titem.next = function() {\n\t\t\t\t\tlet nextIndex = item.index;\n\t\t\t\t\twhile (nextIndex < this.spineItems.length-1) {\n\t\t\t\t\t\tlet next = this.get(nextIndex+1);\n\t\t\t\t\t\tif (next && next.linear) {\n\t\t\t\t\t\t\treturn next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}.bind(this);\n\t\t\t} else {\n\t\t\t\titem.prev = function() {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\titem.next = function() {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tspineItem = new Section(item, this.hooks);\n\n\t\t\tthis.append(spineItem);\n\n\n\t\t});\n\n\t\tthis.loaded = true;\n\t}\n\n\t/**\n\t * Get an item from the spine\n\t * @param  {string|number} [target]\n\t * @return {Section} section\n\t * @example spine.get();\n\t * @example spine.get(1);\n\t * @example spine.get(\"chap1.html\");\n\t * @example spine.get(\"#id1234\");\n\t */\n\tget(target) {\n\t\tvar index = 0;\n\n\t\tif (typeof target === \"undefined\") {\n\t\t\twhile (index < this.spineItems.length) {\n\t\t\t\tlet next = this.spineItems[index];\n\t\t\t\tif (next && next.linear) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tindex += 1;\n\t\t\t}\n\t\t} else if(this.epubcfi.isCfiString(target)) {\n\t\t\tlet cfi = new EpubCFI(target);\n\t\t\tindex = cfi.spinePos;\n\t\t} else if(typeof target === \"number\" || isNaN(target) === false){\n\t\t\tindex = target;\n\t\t} else if(typeof target === \"string\" && target.indexOf(\"#\") === 0) {\n\t\t\tindex = this.spineById[target.substring(1)];\n\t\t} else if(typeof target === \"string\") {\n\t\t\t// Remove fragments\n\t\t\ttarget = target.split(\"#\")[0];\n\t\t\tindex = this.spineByHref[target] || this.spineByHref[encodeURI(target)];\n\t\t}\n\n\t\treturn this.spineItems[index] || null;\n\t}\n\n\t/**\n\t * Append a Section to the Spine\n\t * @private\n\t * @param  {Section} section\n\t */\n\tappend(section) {\n\t\tvar index = this.spineItems.length;\n\t\tsection.index = index;\n\n\t\tthis.spineItems.push(section);\n\n\t\t// Encode and Decode href lookups\n\t\t// see pr for details: https://github.com/futurepress/epub.js/pull/358\n\t\tthis.spineByHref[decodeURI(section.href)] = index;\n\t\tthis.spineByHref[encodeURI(section.href)] = index;\n\t\tthis.spineByHref[section.href] = index;\n\n\t\tthis.spineById[section.idref] = index;\n\n\t\treturn index;\n\t}\n\n\t/**\n\t * Prepend a Section to the Spine\n\t * @private\n\t * @param  {Section} section\n\t */\n\tprepend(section) {\n\t\t// var index = this.spineItems.unshift(section);\n\t\tthis.spineByHref[section.href] = 0;\n\t\tthis.spineById[section.idref] = 0;\n\n\t\t// Re-index\n\t\tthis.spineItems.forEach(function(item, index){\n\t\t\titem.index = index;\n\t\t});\n\n\t\treturn 0;\n\t}\n\n\t// insert(section, index) {\n\t//\n\t// };\n\n\t/**\n\t * Remove a Section from the Spine\n\t * @private\n\t * @param  {Section} section\n\t */\n\tremove(section) {\n\t\tvar index = this.spineItems.indexOf(section);\n\n\t\tif(index > -1) {\n\t\t\tdelete this.spineByHref[section.href];\n\t\t\tdelete this.spineById[section.idref];\n\n\t\t\treturn this.spineItems.splice(index, 1);\n\t\t}\n\t}\n\n\t/**\n\t * Loop over the Sections in the Spine\n\t * @return {method} forEach\n\t */\n\teach() {\n\t\treturn this.spineItems.forEach.apply(this.spineItems, arguments);\n\t}\n\n\t/**\n\t * Find the first Section in the Spine\n\t * @return {Section} first section\n\t */\n\tfirst() {\n\t\tlet index = 0;\n\n\t\tdo {\n\t\t\tlet next = this.get(index);\n\n\t\t\tif (next && next.linear) {\n\t\t\t\treturn next;\n\t\t\t}\n\t\t\tindex += 1;\n\t\t} while (index < this.spineItems.length) ;\n\t}\n\n\t/**\n\t * Find the last Section in the Spine\n\t * @return {Section} last section\n\t */\n\tlast() {\n\t\tlet index = this.spineItems.length-1;\n\n\t\tdo {\n\t\t\tlet prev = this.get(index);\n\t\t\tif (prev && prev.linear) {\n\t\t\t\treturn prev;\n\t\t\t}\n\t\t\tindex -= 1;\n\t\t} while (index >= 0);\n\t}\n\n\tdestroy() {\n\t\tthis.each((section) => section.destroy());\n\n\t\tthis.spineItems = undefined\n\t\tthis.spineByHref = undefined\n\t\tthis.spineById = undefined\n\n\t\tthis.hooks.serialize.clear();\n\t\tthis.hooks.content.clear();\n\t\tthis.hooks = undefined;\n\n\t\tthis.epubcfi = undefined;\n\n\t\tthis.loaded = false;\n\n\t\tthis.items = undefined;\n\t\tthis.manifest = undefined;\n\t\tthis.spineNodeIndex = undefined;\n\t\tthis.baseUrl = undefined;\n\t\tthis.length = undefined;\n\t}\n}\n\nexport default Spine;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}