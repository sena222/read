{"ast":null,"code":"import _classCallCheck from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { defer, requestAnimationFrame } from \"./core\";\n\n/**\n * Queue for handling tasks one at a time\n * @class\n * @param {scope} context what this will resolve to in the tasks\n */\nvar Queue = /*#__PURE__*/function () {\n  function Queue(context) {\n    _classCallCheck(this, Queue);\n    this._q = [];\n    this.context = context;\n    this.tick = requestAnimationFrame;\n    this.running = false;\n    this.paused = false;\n  }\n\n  /**\n   * Add an item to the queue\n   * @return {Promise}\n   */\n  _createClass(Queue, [{\n    key: \"enqueue\",\n    value: function enqueue() {\n      var deferred, promise;\n      var queued;\n      var task = [].shift.call(arguments);\n      var args = arguments;\n\n      // Handle single args without context\n      // if(args && !Array.isArray(args)) {\n      //   args = [args];\n      // }\n      if (!task) {\n        throw new Error(\"No Task Provided\");\n      }\n      if (typeof task === \"function\") {\n        deferred = new defer();\n        promise = deferred.promise;\n        queued = {\n          \"task\": task,\n          \"args\": args,\n          //\"context\"  : context,\n          \"deferred\": deferred,\n          \"promise\": promise\n        };\n      } else {\n        // Task is a promise\n        queued = {\n          \"promise\": task\n        };\n      }\n      this._q.push(queued);\n\n      // Wait to start queue flush\n      if (this.paused == false && !this.running) {\n        // setTimeout(this.flush.bind(this), 0);\n        // this.tick.call(window, this.run.bind(this));\n        this.run();\n      }\n      return queued.promise;\n    }\n\n    /**\n     * Run one item\n     * @return {Promise}\n     */\n  }, {\n    key: \"dequeue\",\n    value: function dequeue() {\n      var inwait, task, result;\n      if (this._q.length && !this.paused) {\n        inwait = this._q.shift();\n        task = inwait.task;\n        if (task) {\n          // console.log(task)\n\n          result = task.apply(this.context, inwait.args);\n          if (result && typeof result[\"then\"] === \"function\") {\n            // Task is a function that returns a promise\n            return result.then(function () {\n              inwait.deferred.resolve.apply(this.context, arguments);\n            }.bind(this), function () {\n              inwait.deferred.reject.apply(this.context, arguments);\n            }.bind(this));\n          } else {\n            // Task resolves immediately\n            inwait.deferred.resolve.apply(this.context, result);\n            return inwait.promise;\n          }\n        } else if (inwait.promise) {\n          // Task is a promise\n          return inwait.promise;\n        }\n      } else {\n        inwait = new defer();\n        inwait.deferred.resolve();\n        return inwait.promise;\n      }\n    }\n\n    // Run All Immediately\n  }, {\n    key: \"dump\",\n    value: function dump() {\n      while (this._q.length) {\n        this.dequeue();\n      }\n    }\n\n    /**\n     * Run all tasks sequentially, at convince\n     * @return {Promise}\n     */\n  }, {\n    key: \"run\",\n    value: function run() {\n      var _this = this;\n      if (!this.running) {\n        this.running = true;\n        this.defered = new defer();\n      }\n      this.tick.call(window, function () {\n        if (_this._q.length) {\n          _this.dequeue().then(function () {\n            this.run();\n          }.bind(_this));\n        } else {\n          _this.defered.resolve();\n          _this.running = undefined;\n        }\n      });\n\n      // Unpause\n      if (this.paused == true) {\n        this.paused = false;\n      }\n      return this.defered.promise;\n    }\n\n    /**\n     * Flush all, as quickly as possible\n     * @return {Promise}\n     */\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this.running) {\n        return this.running;\n      }\n      if (this._q.length) {\n        this.running = this.dequeue().then(function () {\n          this.running = undefined;\n          return this.flush();\n        }.bind(this));\n        return this.running;\n      }\n    }\n\n    /**\n     * Clear all items in wait\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._q = [];\n    }\n\n    /**\n     * Get the number of tasks in the queue\n     * @return {number} tasks\n     */\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this._q.length;\n    }\n\n    /**\n     * Pause a running queue\n     */\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.paused = true;\n    }\n\n    /**\n     * End the queue\n     */\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._q = [];\n      this.running = false;\n      this.paused = true;\n    }\n  }]);\n  return Queue;\n}();\n/**\n * Create a new task from a callback\n * @class\n * @private\n * @param {function} task\n * @param {array} args\n * @param {scope} context\n * @return {function} task\n */\nvar Task = /*#__PURE__*/_createClass(function Task(task, args, context) {\n  _classCallCheck(this, Task);\n  return function () {\n    var _this2 = this;\n    var toApply = arguments || [];\n    return new Promise(function (resolve, reject) {\n      var callback = function callback(value, err) {\n        if (!value && err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      };\n      // Add the callback to the arguments list\n      toApply.push(callback);\n\n      // Apply all arguments to the functions\n      task.apply(context || _this2, toApply);\n    });\n  };\n});\nexport default Queue;\nexport { Task };","map":{"version":3,"names":["defer","requestAnimationFrame","Queue","context","_q","tick","running","paused","deferred","promise","queued","task","shift","call","arguments","args","Error","push","run","inwait","result","length","apply","then","resolve","bind","reject","dequeue","defered","window","undefined","flush","Task","toApply","Promise","callback","value","err"],"sources":["/home/parallels/Downloads/read/node_modules/epubjs/src/utils/queue.js"],"sourcesContent":["import {defer, requestAnimationFrame} from \"./core\";\n\n/**\n * Queue for handling tasks one at a time\n * @class\n * @param {scope} context what this will resolve to in the tasks\n */\nclass Queue {\n\tconstructor(context){\n\t\tthis._q = [];\n\t\tthis.context = context;\n\t\tthis.tick = requestAnimationFrame;\n\t\tthis.running = false;\n\t\tthis.paused = false;\n\t}\n\n\t/**\n\t * Add an item to the queue\n\t * @return {Promise}\n\t */\n\tenqueue() {\n\t\tvar deferred, promise;\n\t\tvar queued;\n\t\tvar task = [].shift.call(arguments);\n\t\tvar args = arguments;\n\n\t\t// Handle single args without context\n\t\t// if(args && !Array.isArray(args)) {\n\t\t//   args = [args];\n\t\t// }\n\t\tif(!task) {\n\t\t\tthrow new Error(\"No Task Provided\");\n\t\t}\n\n\t\tif(typeof task === \"function\"){\n\n\t\t\tdeferred = new defer();\n\t\t\tpromise = deferred.promise;\n\n\t\t\tqueued = {\n\t\t\t\t\"task\" : task,\n\t\t\t\t\"args\"     : args,\n\t\t\t\t//\"context\"  : context,\n\t\t\t\t\"deferred\" : deferred,\n\t\t\t\t\"promise\" : promise\n\t\t\t};\n\n\t\t} else {\n\t\t\t// Task is a promise\n\t\t\tqueued = {\n\t\t\t\t\"promise\" : task\n\t\t\t};\n\n\t\t}\n\n\t\tthis._q.push(queued);\n\n\t\t// Wait to start queue flush\n\t\tif (this.paused == false && !this.running) {\n\t\t\t// setTimeout(this.flush.bind(this), 0);\n\t\t\t// this.tick.call(window, this.run.bind(this));\n\t\t\tthis.run();\n\t\t}\n\n\t\treturn queued.promise;\n\t}\n\n\t/**\n\t * Run one item\n\t * @return {Promise}\n\t */\n\tdequeue(){\n\t\tvar inwait, task, result;\n\n\t\tif(this._q.length && !this.paused) {\n\t\t\tinwait = this._q.shift();\n\t\t\ttask = inwait.task;\n\t\t\tif(task){\n\t\t\t\t// console.log(task)\n\n\t\t\t\tresult = task.apply(this.context, inwait.args);\n\n\t\t\t\tif(result && typeof result[\"then\"] === \"function\") {\n\t\t\t\t\t// Task is a function that returns a promise\n\t\t\t\t\treturn result.then(function(){\n\t\t\t\t\t\tinwait.deferred.resolve.apply(this.context, arguments);\n\t\t\t\t\t}.bind(this), function() {\n\t\t\t\t\t\tinwait.deferred.reject.apply(this.context, arguments);\n\t\t\t\t\t}.bind(this));\n\t\t\t\t} else {\n\t\t\t\t\t// Task resolves immediately\n\t\t\t\t\tinwait.deferred.resolve.apply(this.context, result);\n\t\t\t\t\treturn inwait.promise;\n\t\t\t\t}\n\n\n\n\t\t\t} else if(inwait.promise) {\n\t\t\t\t// Task is a promise\n\t\t\t\treturn inwait.promise;\n\t\t\t}\n\n\t\t} else {\n\t\t\tinwait = new defer();\n\t\t\tinwait.deferred.resolve();\n\t\t\treturn inwait.promise;\n\t\t}\n\n\t}\n\n\t// Run All Immediately\n\tdump(){\n\t\twhile(this._q.length) {\n\t\t\tthis.dequeue();\n\t\t}\n\t}\n\n\t/**\n\t * Run all tasks sequentially, at convince\n\t * @return {Promise}\n\t */\n\trun(){\n\n\t\tif(!this.running){\n\t\t\tthis.running = true;\n\t\t\tthis.defered = new defer();\n\t\t}\n\n\t\tthis.tick.call(window, () => {\n\n\t\t\tif(this._q.length) {\n\n\t\t\t\tthis.dequeue()\n\t\t\t\t\t.then(function(){\n\t\t\t\t\t\tthis.run();\n\t\t\t\t\t}.bind(this));\n\n\t\t\t} else {\n\t\t\t\tthis.defered.resolve();\n\t\t\t\tthis.running = undefined;\n\t\t\t}\n\n\t\t});\n\n\t\t// Unpause\n\t\tif(this.paused == true) {\n\t\t\tthis.paused = false;\n\t\t}\n\n\t\treturn this.defered.promise;\n\t}\n\n\t/**\n\t * Flush all, as quickly as possible\n\t * @return {Promise}\n\t */\n\tflush(){\n\n\t\tif(this.running){\n\t\t\treturn this.running;\n\t\t}\n\n\t\tif(this._q.length) {\n\t\t\tthis.running = this.dequeue()\n\t\t\t\t.then(function(){\n\t\t\t\t\tthis.running = undefined;\n\t\t\t\t\treturn this.flush();\n\t\t\t\t}.bind(this));\n\n\t\t\treturn this.running;\n\t\t}\n\n\t}\n\n\t/**\n\t * Clear all items in wait\n\t */\n\tclear(){\n\t\tthis._q = [];\n\t}\n\n\t/**\n\t * Get the number of tasks in the queue\n\t * @return {number} tasks\n\t */\n\tlength(){\n\t\treturn this._q.length;\n\t}\n\n\t/**\n\t * Pause a running queue\n\t */\n\tpause(){\n\t\tthis.paused = true;\n\t}\n\n\t/**\n\t * End the queue\n\t */\n\tstop(){\n\t\tthis._q = [];\n\t\tthis.running = false;\n\t\tthis.paused = true;\n\t}\n}\n\n\n/**\n * Create a new task from a callback\n * @class\n * @private\n * @param {function} task\n * @param {array} args\n * @param {scope} context\n * @return {function} task\n */\nclass Task {\n\tconstructor(task, args, context){\n\n\t\treturn function(){\n\t\t\tvar toApply = arguments || [];\n\n\t\t\treturn new Promise( (resolve, reject) => {\n\t\t\t\tvar callback = function(value, err){\n\t\t\t\t\tif (!value && err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t// Add the callback to the arguments list\n\t\t\t\ttoApply.push(callback);\n\n\t\t\t\t// Apply all arguments to the functions\n\t\t\t\ttask.apply(context || this, toApply);\n\n\t\t\t});\n\n\t\t};\n\n\t}\n}\n\n\nexport default Queue;\nexport { Task };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}