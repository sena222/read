{"ast":null,"code":"import _classCallCheck from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { extend } from \"./utils/core\";\nimport { EVENTS } from \"./utils/constants\";\nimport EventEmitter from \"event-emitter\";\n\n/**\n * Figures out the CSS values to apply for a layout\n * @class\n * @param {object} settings\n * @param {string} [settings.layout='reflowable']\n * @param {string} [settings.spread]\n * @param {number} [settings.minSpreadWidth=800]\n * @param {boolean} [settings.evenSpreads=false]\n */\nvar Layout = /*#__PURE__*/function () {\n  function Layout(settings) {\n    _classCallCheck(this, Layout);\n    this.settings = settings;\n    this.name = settings.layout || \"reflowable\";\n    this._spread = settings.spread === \"none\" ? false : true;\n    this._minSpreadWidth = settings.minSpreadWidth || 800;\n    this._evenSpreads = settings.evenSpreads || false;\n    if (settings.flow === \"scrolled\" || settings.flow === \"scrolled-continuous\" || settings.flow === \"scrolled-doc\") {\n      this._flow = \"scrolled\";\n    } else {\n      this._flow = \"paginated\";\n    }\n    this.width = 0;\n    this.height = 0;\n    this.spreadWidth = 0;\n    this.delta = 0;\n    this.columnWidth = 0;\n    this.gap = 0;\n    this.divisor = 1;\n    this.props = {\n      name: this.name,\n      spread: this._spread,\n      flow: this._flow,\n      width: 0,\n      height: 0,\n      spreadWidth: 0,\n      delta: 0,\n      columnWidth: 0,\n      gap: 0,\n      divisor: 1\n    };\n  }\n\n  /**\n   * Switch the flow between paginated and scrolled\n   * @param  {string} flow paginated | scrolled\n   * @return {string} simplified flow\n   */\n  _createClass(Layout, [{\n    key: \"flow\",\n    value: function flow(_flow) {\n      if (typeof _flow != \"undefined\") {\n        if (_flow === \"scrolled\" || _flow === \"scrolled-continuous\" || _flow === \"scrolled-doc\") {\n          this._flow = \"scrolled\";\n        } else {\n          this._flow = \"paginated\";\n        }\n        // this.props.flow = this._flow;\n        this.update({\n          flow: this._flow\n        });\n      }\n      return this._flow;\n    }\n\n    /**\n     * Switch between using spreads or not, and set the\n     * width at which they switch to single.\n     * @param  {string} spread \"none\" | \"always\" | \"auto\"\n     * @param  {number} min integer in pixels\n     * @return {boolean} spread true | false\n     */\n  }, {\n    key: \"spread\",\n    value: function spread(_spread, min) {\n      if (_spread) {\n        this._spread = _spread === \"none\" ? false : true;\n        // this.props.spread = this._spread;\n        this.update({\n          spread: this._spread\n        });\n      }\n      if (min >= 0) {\n        this._minSpreadWidth = min;\n      }\n      return this._spread;\n    }\n\n    /**\n     * Calculate the dimensions of the pagination\n     * @param  {number} _width  width of the rendering\n     * @param  {number} _height height of the rendering\n     * @param  {number} _gap    width of the gap between columns\n     */\n  }, {\n    key: \"calculate\",\n    value: function calculate(_width, _height, _gap) {\n      var divisor = 1;\n      var gap = _gap || 0;\n\n      //-- Check the width and create even width columns\n      // var fullWidth = Math.floor(_width);\n      var width = _width;\n      var height = _height;\n      var section = Math.floor(width / 12);\n      var columnWidth;\n      var spreadWidth;\n      var pageWidth;\n      var delta;\n      if (this._spread && width >= this._minSpreadWidth) {\n        divisor = 2;\n      } else {\n        divisor = 1;\n      }\n      if (this.name === \"reflowable\" && this._flow === \"paginated\" && !(_gap >= 0)) {\n        gap = section % 2 === 0 ? section : section - 1;\n      }\n      if (this.name === \"pre-paginated\") {\n        gap = 0;\n      }\n\n      //-- Double Page\n      if (divisor > 1) {\n        // width = width - gap;\n        // columnWidth = (width - gap) / divisor;\n        // gap = gap / divisor;\n        columnWidth = width / divisor - gap;\n        pageWidth = columnWidth + gap;\n      } else {\n        columnWidth = width;\n        pageWidth = width;\n      }\n      if (this.name === \"pre-paginated\" && divisor > 1) {\n        width = columnWidth;\n      }\n      spreadWidth = columnWidth * divisor + gap;\n      delta = width;\n      this.width = width;\n      this.height = height;\n      this.spreadWidth = spreadWidth;\n      this.pageWidth = pageWidth;\n      this.delta = delta;\n      this.columnWidth = columnWidth;\n      this.gap = gap;\n      this.divisor = divisor;\n\n      // this.props.width = width;\n      // this.props.height = _height;\n      // this.props.spreadWidth = spreadWidth;\n      // this.props.pageWidth = pageWidth;\n      // this.props.delta = delta;\n      //\n      // this.props.columnWidth = colWidth;\n      // this.props.gap = gap;\n      // this.props.divisor = divisor;\n\n      this.update({\n        width: width,\n        height: height,\n        spreadWidth: spreadWidth,\n        pageWidth: pageWidth,\n        delta: delta,\n        columnWidth: columnWidth,\n        gap: gap,\n        divisor: divisor\n      });\n    }\n\n    /**\n     * Apply Css to a Document\n     * @param  {Contents} contents\n     * @return {Promise}\n     */\n  }, {\n    key: \"format\",\n    value: function format(contents, section, axis) {\n      var formating;\n      if (this.name === \"pre-paginated\") {\n        formating = contents.fit(this.columnWidth, this.height, section);\n      } else if (this._flow === \"paginated\") {\n        formating = contents.columns(this.width, this.height, this.columnWidth, this.gap, this.settings.direction);\n      } else if (axis && axis === \"horizontal\") {\n        formating = contents.size(null, this.height);\n      } else {\n        formating = contents.size(this.width, null);\n      }\n      return formating; // might be a promise in some View Managers\n    }\n\n    /**\n     * Count number of pages\n     * @param  {number} totalLength\n     * @param  {number} pageLength\n     * @return {{spreads: Number, pages: Number}}\n     */\n  }, {\n    key: \"count\",\n    value: function count(totalLength, pageLength) {\n      var spreads, pages;\n      if (this.name === \"pre-paginated\") {\n        spreads = 1;\n        pages = 1;\n      } else if (this._flow === \"paginated\") {\n        pageLength = pageLength || this.delta;\n        spreads = Math.ceil(totalLength / pageLength);\n        pages = spreads * this.divisor;\n      } else {\n        // scrolled\n        pageLength = pageLength || this.height;\n        spreads = Math.ceil(totalLength / pageLength);\n        pages = spreads;\n      }\n      return {\n        spreads: spreads,\n        pages: pages\n      };\n    }\n\n    /**\n     * Update props that have changed\n     * @private\n     * @param  {object} props\n     */\n  }, {\n    key: \"update\",\n    value: function update(props) {\n      var _this = this;\n      // Remove props that haven't changed\n      Object.keys(props).forEach(function (propName) {\n        if (_this.props[propName] === props[propName]) {\n          delete props[propName];\n        }\n      });\n      if (Object.keys(props).length > 0) {\n        var newProps = extend(this.props, props);\n        this.emit(EVENTS.LAYOUT.UPDATED, newProps, props);\n      }\n    }\n  }]);\n  return Layout;\n}();\nEventEmitter(Layout.prototype);\nexport default Layout;","map":{"version":3,"names":["extend","EVENTS","EventEmitter","Layout","settings","name","layout","_spread","spread","_minSpreadWidth","minSpreadWidth","_evenSpreads","evenSpreads","flow","_flow","width","height","spreadWidth","delta","columnWidth","gap","divisor","props","update","min","_width","_height","_gap","section","Math","floor","pageWidth","contents","axis","formating","fit","columns","direction","size","totalLength","pageLength","spreads","pages","ceil","Object","keys","forEach","propName","length","newProps","emit","LAYOUT","UPDATED","prototype"],"sources":["/home/parallels/Downloads/read/node_modules/epubjs/src/layout.js"],"sourcesContent":["import { extend } from \"./utils/core\";\nimport { EVENTS } from \"./utils/constants\";\nimport EventEmitter from \"event-emitter\";\n\n/**\n * Figures out the CSS values to apply for a layout\n * @class\n * @param {object} settings\n * @param {string} [settings.layout='reflowable']\n * @param {string} [settings.spread]\n * @param {number} [settings.minSpreadWidth=800]\n * @param {boolean} [settings.evenSpreads=false]\n */\nclass Layout {\n\tconstructor(settings) {\n\t\tthis.settings = settings;\n\t\tthis.name = settings.layout || \"reflowable\";\n\t\tthis._spread = (settings.spread === \"none\") ? false : true;\n\t\tthis._minSpreadWidth = settings.minSpreadWidth || 800;\n\t\tthis._evenSpreads = settings.evenSpreads || false;\n\n\t\tif (settings.flow === \"scrolled\" ||\n\t\t\t\tsettings.flow === \"scrolled-continuous\" ||\n\t\t\t\tsettings.flow === \"scrolled-doc\") {\n\t\t\tthis._flow = \"scrolled\";\n\t\t} else {\n\t\t\tthis._flow = \"paginated\";\n\t\t}\n\n\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\t\tthis.spreadWidth = 0;\n\t\tthis.delta = 0;\n\n\t\tthis.columnWidth = 0;\n\t\tthis.gap = 0;\n\t\tthis.divisor = 1;\n\n\t\tthis.props = {\n\t\t\tname: this.name,\n\t\t\tspread: this._spread,\n\t\t\tflow: this._flow,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tspreadWidth: 0,\n\t\t\tdelta: 0,\n\t\t\tcolumnWidth: 0,\n\t\t\tgap: 0,\n\t\t\tdivisor: 1\n\t\t};\n\n\t}\n\n\t/**\n\t * Switch the flow between paginated and scrolled\n\t * @param  {string} flow paginated | scrolled\n\t * @return {string} simplified flow\n\t */\n\tflow(flow) {\n\t\tif (typeof(flow) != \"undefined\") {\n\t\t\tif (flow === \"scrolled\" ||\n\t\t\t\t\tflow === \"scrolled-continuous\" ||\n\t\t\t\t\tflow === \"scrolled-doc\") {\n\t\t\t\tthis._flow = \"scrolled\";\n\t\t\t} else {\n\t\t\t\tthis._flow = \"paginated\";\n\t\t\t}\n\t\t\t// this.props.flow = this._flow;\n\t\t\tthis.update({flow: this._flow});\n\t\t}\n\t\treturn this._flow;\n\t}\n\n\t/**\n\t * Switch between using spreads or not, and set the\n\t * width at which they switch to single.\n\t * @param  {string} spread \"none\" | \"always\" | \"auto\"\n\t * @param  {number} min integer in pixels\n\t * @return {boolean} spread true | false\n\t */\n\tspread(spread, min) {\n\n\t\tif (spread) {\n\t\t\tthis._spread = (spread === \"none\") ? false : true;\n\t\t\t// this.props.spread = this._spread;\n\t\t\tthis.update({spread: this._spread});\n\t\t}\n\n\t\tif (min >= 0) {\n\t\t\tthis._minSpreadWidth = min;\n\t\t}\n\n\t\treturn this._spread;\n\t}\n\n\t/**\n\t * Calculate the dimensions of the pagination\n\t * @param  {number} _width  width of the rendering\n\t * @param  {number} _height height of the rendering\n\t * @param  {number} _gap    width of the gap between columns\n\t */\n\tcalculate(_width, _height, _gap){\n\n\t\tvar divisor = 1;\n\t\tvar gap = _gap || 0;\n\n\t\t//-- Check the width and create even width columns\n\t\t// var fullWidth = Math.floor(_width);\n\t\tvar width = _width;\n\t\tvar height = _height;\n\n\t\tvar section = Math.floor(width / 12);\n\n\t\tvar columnWidth;\n\t\tvar spreadWidth;\n\t\tvar pageWidth;\n\t\tvar delta;\n\n\t\tif (this._spread && width >= this._minSpreadWidth) {\n\t\t\tdivisor = 2;\n\t\t} else {\n\t\t\tdivisor = 1;\n\t\t}\n\n\t\tif (this.name === \"reflowable\" && this._flow === \"paginated\" && !(_gap >= 0)) {\n\t\t\tgap = ((section % 2 === 0) ? section : section - 1);\n\t\t}\n\n\t\tif (this.name === \"pre-paginated\" ) {\n\t\t\tgap = 0;\n\t\t}\n\n\t\t//-- Double Page\n\t\tif(divisor > 1) {\n\t\t\t// width = width - gap;\n\t\t\t// columnWidth = (width - gap) / divisor;\n\t\t\t// gap = gap / divisor;\n\t\t\tcolumnWidth = (width / divisor) - gap;\n\t\t\tpageWidth = columnWidth + gap;\n\t\t} else {\n\t\t\tcolumnWidth = width;\n\t\t\tpageWidth = width;\n\t\t}\n\n\t\tif (this.name === \"pre-paginated\" && divisor > 1) {\n\t\t\twidth = columnWidth;\n\t\t}\n\n\t\tspreadWidth = (columnWidth * divisor) + gap;\n\n\t\tdelta = width;\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.spreadWidth = spreadWidth;\n\t\tthis.pageWidth = pageWidth;\n\t\tthis.delta = delta;\n\n\t\tthis.columnWidth = columnWidth;\n\t\tthis.gap = gap;\n\t\tthis.divisor = divisor;\n\n\t\t// this.props.width = width;\n\t\t// this.props.height = _height;\n\t\t// this.props.spreadWidth = spreadWidth;\n\t\t// this.props.pageWidth = pageWidth;\n\t\t// this.props.delta = delta;\n\t\t//\n\t\t// this.props.columnWidth = colWidth;\n\t\t// this.props.gap = gap;\n\t\t// this.props.divisor = divisor;\n\n\t\tthis.update({\n\t\t\twidth,\n\t\t\theight,\n\t\t\tspreadWidth,\n\t\t\tpageWidth,\n\t\t\tdelta,\n\t\t\tcolumnWidth,\n\t\t\tgap,\n\t\t\tdivisor\n\t\t});\n\n\t}\n\n\t/**\n\t * Apply Css to a Document\n\t * @param  {Contents} contents\n\t * @return {Promise}\n\t */\n\tformat(contents, section, axis){\n\t\tvar formating;\n\n\t\tif (this.name === \"pre-paginated\") {\n\t\t\tformating = contents.fit(this.columnWidth, this.height, section);\n\t\t} else if (this._flow === \"paginated\") {\n\t\t\tformating = contents.columns(this.width, this.height, this.columnWidth, this.gap, this.settings.direction);\n\t\t} else if (axis && axis === \"horizontal\") {\n\t\t\tformating = contents.size(null, this.height);\n\t\t} else {\n\t\t\tformating = contents.size(this.width, null);\t\t\t\t\n\t\t}\n\n\t\treturn formating; // might be a promise in some View Managers\n\t}\n\n\t/**\n\t * Count number of pages\n\t * @param  {number} totalLength\n\t * @param  {number} pageLength\n\t * @return {{spreads: Number, pages: Number}}\n\t */\n\tcount(totalLength, pageLength) {\n\n\t\tlet spreads, pages;\n\n\t\tif (this.name === \"pre-paginated\") {\n\t\t\tspreads = 1;\n\t\t\tpages = 1;\n\t\t} else if (this._flow === \"paginated\") {\n\t\t\tpageLength = pageLength || this.delta;\n\t\t\tspreads = Math.ceil( totalLength / pageLength);\n\t\t\tpages = spreads * this.divisor;\n\t\t} else { // scrolled\n\t\t\tpageLength = pageLength || this.height;\n\t\t\tspreads = Math.ceil( totalLength / pageLength);\n\t\t\tpages = spreads;\n\t\t}\n\n\t\treturn {\n\t\t\tspreads,\n\t\t\tpages\n\t\t};\n\n\t}\n\n\t/**\n\t * Update props that have changed\n\t * @private\n\t * @param  {object} props\n\t */\n\tupdate(props) {\n\t\t// Remove props that haven't changed\n\t\tObject.keys(props).forEach((propName) => {\n\t\t\tif (this.props[propName] === props[propName]) {\n\t\t\t\tdelete props[propName];\n\t\t\t}\n\t\t});\n\n\t\tif(Object.keys(props).length > 0) {\n\t\t\tlet newProps = extend(this.props, props);\n\t\t\tthis.emit(EVENTS.LAYOUT.UPDATED, newProps, props);\n\t\t}\n\t}\n}\n\nEventEmitter(Layout.prototype);\n\nexport default Layout;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}