{"ast":null,"code":"import _classCallCheck from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { qs, qsa, qsp, indexOfElementNode } from \"./utils/core\";\n\n/**\n * Open Packaging Format Parser\n * @class\n * @param {document} packageDocument OPF XML\n */\nvar Packaging = /*#__PURE__*/function () {\n  function Packaging(packageDocument) {\n    _classCallCheck(this, Packaging);\n    this.manifest = {};\n    this.navPath = '';\n    this.ncxPath = '';\n    this.coverPath = '';\n    this.spineNodeIndex = 0;\n    this.spine = [];\n    this.metadata = {};\n    if (packageDocument) {\n      this.parse(packageDocument);\n    }\n  }\n\n  /**\n   * Parse OPF XML\n   * @param  {document} packageDocument OPF XML\n   * @return {object} parsed package parts\n   */\n  _createClass(Packaging, [{\n    key: \"parse\",\n    value: function parse(packageDocument) {\n      var metadataNode, manifestNode, spineNode;\n      if (!packageDocument) {\n        throw new Error(\"Package File Not Found\");\n      }\n      metadataNode = qs(packageDocument, \"metadata\");\n      if (!metadataNode) {\n        throw new Error(\"No Metadata Found\");\n      }\n      manifestNode = qs(packageDocument, \"manifest\");\n      if (!manifestNode) {\n        throw new Error(\"No Manifest Found\");\n      }\n      spineNode = qs(packageDocument, \"spine\");\n      if (!spineNode) {\n        throw new Error(\"No Spine Found\");\n      }\n      this.manifest = this.parseManifest(manifestNode);\n      this.navPath = this.findNavPath(manifestNode);\n      this.ncxPath = this.findNcxPath(manifestNode, spineNode);\n      this.coverPath = this.findCoverPath(packageDocument);\n      this.spineNodeIndex = indexOfElementNode(spineNode);\n      this.spine = this.parseSpine(spineNode, this.manifest);\n      this.uniqueIdentifier = this.findUniqueIdentifier(packageDocument);\n      this.metadata = this.parseMetadata(metadataNode);\n      this.metadata.direction = spineNode.getAttribute(\"page-progression-direction\");\n      return {\n        \"metadata\": this.metadata,\n        \"spine\": this.spine,\n        \"manifest\": this.manifest,\n        \"navPath\": this.navPath,\n        \"ncxPath\": this.ncxPath,\n        \"coverPath\": this.coverPath,\n        \"spineNodeIndex\": this.spineNodeIndex\n      };\n    }\n\n    /**\n     * Parse Metadata\n     * @private\n     * @param  {node} xml\n     * @return {object} metadata\n     */\n  }, {\n    key: \"parseMetadata\",\n    value: function parseMetadata(xml) {\n      var metadata = {};\n      metadata.title = this.getElementText(xml, \"title\");\n      metadata.creator = this.getElementText(xml, \"creator\");\n      metadata.description = this.getElementText(xml, \"description\");\n      metadata.pubdate = this.getElementText(xml, \"date\");\n      metadata.publisher = this.getElementText(xml, \"publisher\");\n      metadata.identifier = this.getElementText(xml, \"identifier\");\n      metadata.language = this.getElementText(xml, \"language\");\n      metadata.rights = this.getElementText(xml, \"rights\");\n      metadata.modified_date = this.getPropertyText(xml, \"dcterms:modified\");\n      metadata.layout = this.getPropertyText(xml, \"rendition:layout\");\n      metadata.orientation = this.getPropertyText(xml, \"rendition:orientation\");\n      metadata.flow = this.getPropertyText(xml, \"rendition:flow\");\n      metadata.viewport = this.getPropertyText(xml, \"rendition:viewport\");\n      metadata.media_active_class = this.getPropertyText(xml, \"media:active-class\");\n      metadata.spread = this.getPropertyText(xml, \"rendition:spread\");\n      // metadata.page_prog_dir = packageXml.querySelector(\"spine\").getAttribute(\"page-progression-direction\");\n\n      return metadata;\n    }\n\n    /**\n     * Parse Manifest\n     * @private\n     * @param  {node} manifestXml\n     * @return {object} manifest\n     */\n  }, {\n    key: \"parseManifest\",\n    value: function parseManifest(manifestXml) {\n      var manifest = {};\n\n      //-- Turn items into an array\n      // var selected = manifestXml.querySelectorAll(\"item\");\n      var selected = qsa(manifestXml, \"item\");\n      var items = Array.prototype.slice.call(selected);\n\n      //-- Create an object with the id as key\n      items.forEach(function (item) {\n        var id = item.getAttribute(\"id\"),\n          href = item.getAttribute(\"href\") || \"\",\n          type = item.getAttribute(\"media-type\") || \"\",\n          overlay = item.getAttribute(\"media-overlay\") || \"\",\n          properties = item.getAttribute(\"properties\") || \"\";\n        manifest[id] = {\n          \"href\": href,\n          // \"url\" : href,\n          \"type\": type,\n          \"overlay\": overlay,\n          \"properties\": properties.length ? properties.split(\" \") : []\n        };\n      });\n      return manifest;\n    }\n\n    /**\n     * Parse Spine\n     * @private\n     * @param  {node} spineXml\n     * @param  {Packaging.manifest} manifest\n     * @return {object} spine\n     */\n  }, {\n    key: \"parseSpine\",\n    value: function parseSpine(spineXml, manifest) {\n      var spine = [];\n      var selected = qsa(spineXml, \"itemref\");\n      var items = Array.prototype.slice.call(selected);\n\n      // var epubcfi = new EpubCFI();\n\n      //-- Add to array to maintain ordering and cross reference with manifest\n      items.forEach(function (item, index) {\n        var idref = item.getAttribute(\"idref\");\n        // var cfiBase = epubcfi.generateChapterComponent(spineNodeIndex, index, Id);\n        var props = item.getAttribute(\"properties\") || \"\";\n        var propArray = props.length ? props.split(\" \") : [];\n        // var manifestProps = manifest[Id].properties;\n        // var manifestPropArray = manifestProps.length ? manifestProps.split(\" \") : [];\n\n        var itemref = {\n          \"id\": item.getAttribute(\"id\"),\n          \"idref\": idref,\n          \"linear\": item.getAttribute(\"linear\") || \"yes\",\n          \"properties\": propArray,\n          // \"href\" : manifest[Id].href,\n          // \"url\" :  manifest[Id].url,\n          \"index\": index\n          // \"cfiBase\" : cfiBase\n        };\n\n        spine.push(itemref);\n      });\n      return spine;\n    }\n\n    /**\n     * Find Unique Identifier\n     * @private\n     * @param  {node} packageXml\n     * @return {string} Unique Identifier text\n     */\n  }, {\n    key: \"findUniqueIdentifier\",\n    value: function findUniqueIdentifier(packageXml) {\n      var uniqueIdentifierId = packageXml.documentElement.getAttribute(\"unique-identifier\");\n      if (!uniqueIdentifierId) {\n        return \"\";\n      }\n      var identifier = packageXml.getElementById(uniqueIdentifierId);\n      if (!identifier) {\n        return \"\";\n      }\n      if (identifier.localName === \"identifier\" && identifier.namespaceURI === \"http://purl.org/dc/elements/1.1/\") {\n        return identifier.childNodes.length > 0 ? identifier.childNodes[0].nodeValue.trim() : \"\";\n      }\n      return \"\";\n    }\n\n    /**\n     * Find TOC NAV\n     * @private\n     * @param {element} manifestNode\n     * @return {string}\n     */\n  }, {\n    key: \"findNavPath\",\n    value: function findNavPath(manifestNode) {\n      // Find item with property \"nav\"\n      // Should catch nav regardless of order\n      // var node = manifestNode.querySelector(\"item[properties$='nav'], item[properties^='nav '], item[properties*=' nav ']\");\n      var node = qsp(manifestNode, \"item\", {\n        \"properties\": \"nav\"\n      });\n      return node ? node.getAttribute(\"href\") : false;\n    }\n\n    /**\n     * Find TOC NCX\n     * media-type=\"application/x-dtbncx+xml\" href=\"toc.ncx\"\n     * @private\n     * @param {element} manifestNode\n     * @param {element} spineNode\n     * @return {string}\n     */\n  }, {\n    key: \"findNcxPath\",\n    value: function findNcxPath(manifestNode, spineNode) {\n      // var node = manifestNode.querySelector(\"item[media-type='application/x-dtbncx+xml']\");\n      var node = qsp(manifestNode, \"item\", {\n        \"media-type\": \"application/x-dtbncx+xml\"\n      });\n      var tocId;\n\n      // If we can't find the toc by media-type then try to look for id of the item in the spine attributes as\n      // according to http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.4.1.2,\n      // \"The item that describes the NCX must be referenced by the spine toc attribute.\"\n      if (!node) {\n        tocId = spineNode.getAttribute(\"toc\");\n        if (tocId) {\n          // node = manifestNode.querySelector(\"item[id='\" + tocId + \"']\");\n          node = manifestNode.querySelector(\"#\".concat(tocId));\n        }\n      }\n      return node ? node.getAttribute(\"href\") : false;\n    }\n\n    /**\n     * Find the Cover Path\n     * <item properties=\"cover-image\" id=\"ci\" href=\"cover.svg\" media-type=\"image/svg+xml\" />\n     * Fallback for Epub 2.0\n     * @private\n     * @param  {node} packageXml\n     * @return {string} href\n     */\n  }, {\n    key: \"findCoverPath\",\n    value: function findCoverPath(packageXml) {\n      var pkg = qs(packageXml, \"package\");\n      var epubVersion = pkg.getAttribute(\"version\");\n\n      // Try parsing cover with epub 3.\n      // var node = packageXml.querySelector(\"item[properties='cover-image']\");\n      var node = qsp(packageXml, \"item\", {\n        \"properties\": \"cover-image\"\n      });\n      if (node) return node.getAttribute(\"href\");\n\n      // Fallback to epub 2.\n      var metaCover = qsp(packageXml, \"meta\", {\n        \"name\": \"cover\"\n      });\n      if (metaCover) {\n        var coverId = metaCover.getAttribute(\"content\");\n        // var cover = packageXml.querySelector(\"item[id='\" + coverId + \"']\");\n        var cover = packageXml.getElementById(coverId);\n        return cover ? cover.getAttribute(\"href\") : \"\";\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Get text of a namespaced element\n     * @private\n     * @param  {node} xml\n     * @param  {string} tag\n     * @return {string} text\n     */\n  }, {\n    key: \"getElementText\",\n    value: function getElementText(xml, tag) {\n      var found = xml.getElementsByTagNameNS(\"http://purl.org/dc/elements/1.1/\", tag);\n      var el;\n      if (!found || found.length === 0) return \"\";\n      el = found[0];\n      if (el.childNodes.length) {\n        return el.childNodes[0].nodeValue;\n      }\n      return \"\";\n    }\n\n    /**\n     * Get text by property\n     * @private\n     * @param  {node} xml\n     * @param  {string} property\n     * @return {string} text\n     */\n  }, {\n    key: \"getPropertyText\",\n    value: function getPropertyText(xml, property) {\n      var el = qsp(xml, \"meta\", {\n        \"property\": property\n      });\n      if (el && el.childNodes.length) {\n        return el.childNodes[0].nodeValue;\n      }\n      return \"\";\n    }\n\n    /**\n     * Load JSON Manifest\n     * @param  {document} packageDocument OPF XML\n     * @return {object} parsed package parts\n     */\n  }, {\n    key: \"load\",\n    value: function load(json) {\n      var _this = this;\n      this.metadata = json.metadata;\n      var spine = json.readingOrder || json.spine;\n      this.spine = spine.map(function (item, index) {\n        item.index = index;\n        item.linear = item.linear || \"yes\";\n        return item;\n      });\n      json.resources.forEach(function (item, index) {\n        _this.manifest[index] = item;\n        if (item.rel && item.rel[0] === \"cover\") {\n          _this.coverPath = item.href;\n        }\n      });\n      this.spineNodeIndex = 0;\n      this.toc = json.toc.map(function (item, index) {\n        item.label = item.title;\n        return item;\n      });\n      return {\n        \"metadata\": this.metadata,\n        \"spine\": this.spine,\n        \"manifest\": this.manifest,\n        \"navPath\": this.navPath,\n        \"ncxPath\": this.ncxPath,\n        \"coverPath\": this.coverPath,\n        \"spineNodeIndex\": this.spineNodeIndex,\n        \"toc\": this.toc\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.manifest = undefined;\n      this.navPath = undefined;\n      this.ncxPath = undefined;\n      this.coverPath = undefined;\n      this.spineNodeIndex = undefined;\n      this.spine = undefined;\n      this.metadata = undefined;\n    }\n  }]);\n  return Packaging;\n}();\nexport default Packaging;","map":{"version":3,"names":["qs","qsa","qsp","indexOfElementNode","Packaging","packageDocument","manifest","navPath","ncxPath","coverPath","spineNodeIndex","spine","metadata","parse","metadataNode","manifestNode","spineNode","Error","parseManifest","findNavPath","findNcxPath","findCoverPath","parseSpine","uniqueIdentifier","findUniqueIdentifier","parseMetadata","direction","getAttribute","xml","title","getElementText","creator","description","pubdate","publisher","identifier","language","rights","modified_date","getPropertyText","layout","orientation","flow","viewport","media_active_class","spread","manifestXml","selected","items","Array","prototype","slice","call","forEach","item","id","href","type","overlay","properties","length","split","spineXml","index","idref","props","propArray","itemref","push","packageXml","uniqueIdentifierId","documentElement","getElementById","localName","namespaceURI","childNodes","nodeValue","trim","node","tocId","querySelector","pkg","epubVersion","metaCover","coverId","cover","tag","found","getElementsByTagNameNS","el","property","json","readingOrder","map","linear","resources","rel","toc","label","undefined"],"sources":["/home/parallels/Downloads/read/node_modules/epubjs/src/packaging.js"],"sourcesContent":["import {qs, qsa, qsp, indexOfElementNode} from \"./utils/core\";\n\n/**\n * Open Packaging Format Parser\n * @class\n * @param {document} packageDocument OPF XML\n */\nclass Packaging {\n\tconstructor(packageDocument) {\n\t\tthis.manifest = {};\n\t\tthis.navPath = '';\n\t\tthis.ncxPath = '';\n\t\tthis.coverPath = '';\n\t\tthis.spineNodeIndex = 0;\n\t\tthis.spine = [];\n\t\tthis.metadata = {};\n\n\t\tif (packageDocument) {\n\t\t\tthis.parse(packageDocument);\n\t\t}\n\t}\n\n\t/**\n\t * Parse OPF XML\n\t * @param  {document} packageDocument OPF XML\n\t * @return {object} parsed package parts\n\t */\n\tparse(packageDocument){\n\t\tvar metadataNode, manifestNode, spineNode;\n\n\t\tif(!packageDocument) {\n\t\t\tthrow new Error(\"Package File Not Found\");\n\t\t}\n\n\t\tmetadataNode = qs(packageDocument, \"metadata\");\n\t\tif(!metadataNode) {\n\t\t\tthrow new Error(\"No Metadata Found\");\n\t\t}\n\n\t\tmanifestNode = qs(packageDocument, \"manifest\");\n\t\tif(!manifestNode) {\n\t\t\tthrow new Error(\"No Manifest Found\");\n\t\t}\n\n\t\tspineNode = qs(packageDocument, \"spine\");\n\t\tif(!spineNode) {\n\t\t\tthrow new Error(\"No Spine Found\");\n\t\t}\n\n\t\tthis.manifest = this.parseManifest(manifestNode);\n\t\tthis.navPath = this.findNavPath(manifestNode);\n\t\tthis.ncxPath = this.findNcxPath(manifestNode, spineNode);\n\t\tthis.coverPath = this.findCoverPath(packageDocument);\n\n\t\tthis.spineNodeIndex = indexOfElementNode(spineNode);\n\n\t\tthis.spine = this.parseSpine(spineNode, this.manifest);\n\n\t\tthis.uniqueIdentifier = this.findUniqueIdentifier(packageDocument);\n\t\tthis.metadata = this.parseMetadata(metadataNode);\n\n\t\tthis.metadata.direction = spineNode.getAttribute(\"page-progression-direction\");\n\n\t\treturn {\n\t\t\t\"metadata\" : this.metadata,\n\t\t\t\"spine\"    : this.spine,\n\t\t\t\"manifest\" : this.manifest,\n\t\t\t\"navPath\"  : this.navPath,\n\t\t\t\"ncxPath\"  : this.ncxPath,\n\t\t\t\"coverPath\": this.coverPath,\n\t\t\t\"spineNodeIndex\" : this.spineNodeIndex\n\t\t};\n\t}\n\n\t/**\n\t * Parse Metadata\n\t * @private\n\t * @param  {node} xml\n\t * @return {object} metadata\n\t */\n\tparseMetadata(xml){\n\t\tvar metadata = {};\n\n\t\tmetadata.title = this.getElementText(xml, \"title\");\n\t\tmetadata.creator = this.getElementText(xml, \"creator\");\n\t\tmetadata.description = this.getElementText(xml, \"description\");\n\n\t\tmetadata.pubdate = this.getElementText(xml, \"date\");\n\n\t\tmetadata.publisher = this.getElementText(xml, \"publisher\");\n\n\t\tmetadata.identifier = this.getElementText(xml, \"identifier\");\n\t\tmetadata.language = this.getElementText(xml, \"language\");\n\t\tmetadata.rights = this.getElementText(xml, \"rights\");\n\n\t\tmetadata.modified_date = this.getPropertyText(xml, \"dcterms:modified\");\n\n\t\tmetadata.layout = this.getPropertyText(xml, \"rendition:layout\");\n\t\tmetadata.orientation = this.getPropertyText(xml, \"rendition:orientation\");\n\t\tmetadata.flow = this.getPropertyText(xml, \"rendition:flow\");\n\t\tmetadata.viewport = this.getPropertyText(xml, \"rendition:viewport\");\n\t\tmetadata.media_active_class = this.getPropertyText(xml, \"media:active-class\");\n\t\tmetadata.spread = this.getPropertyText(xml, \"rendition:spread\");\n\t\t// metadata.page_prog_dir = packageXml.querySelector(\"spine\").getAttribute(\"page-progression-direction\");\n\n\t\treturn metadata;\n\t}\n\n\t/**\n\t * Parse Manifest\n\t * @private\n\t * @param  {node} manifestXml\n\t * @return {object} manifest\n\t */\n\tparseManifest(manifestXml){\n\t\tvar manifest = {};\n\n\t\t//-- Turn items into an array\n\t\t// var selected = manifestXml.querySelectorAll(\"item\");\n\t\tvar selected = qsa(manifestXml, \"item\");\n\t\tvar items = Array.prototype.slice.call(selected);\n\n\t\t//-- Create an object with the id as key\n\t\titems.forEach(function(item){\n\t\t\tvar id = item.getAttribute(\"id\"),\n\t\t\t\t\thref = item.getAttribute(\"href\") || \"\",\n\t\t\t\t\ttype = item.getAttribute(\"media-type\") || \"\",\n\t\t\t\t\toverlay = item.getAttribute(\"media-overlay\") || \"\",\n\t\t\t\t\tproperties = item.getAttribute(\"properties\") || \"\";\n\n\t\t\tmanifest[id] = {\n\t\t\t\t\"href\" : href,\n\t\t\t\t// \"url\" : href,\n\t\t\t\t\"type\" : type,\n\t\t\t\t\"overlay\" : overlay,\n\t\t\t\t\"properties\" : properties.length ? properties.split(\" \") : []\n\t\t\t};\n\n\t\t});\n\n\t\treturn manifest;\n\n\t}\n\n\t/**\n\t * Parse Spine\n\t * @private\n\t * @param  {node} spineXml\n\t * @param  {Packaging.manifest} manifest\n\t * @return {object} spine\n\t */\n\tparseSpine(spineXml, manifest){\n\t\tvar spine = [];\n\n\t\tvar selected = qsa(spineXml, \"itemref\");\n\t\tvar items = Array.prototype.slice.call(selected);\n\n\t\t// var epubcfi = new EpubCFI();\n\n\t\t//-- Add to array to maintain ordering and cross reference with manifest\n\t\titems.forEach(function(item, index){\n\t\t\tvar idref = item.getAttribute(\"idref\");\n\t\t\t// var cfiBase = epubcfi.generateChapterComponent(spineNodeIndex, index, Id);\n\t\t\tvar props = item.getAttribute(\"properties\") || \"\";\n\t\t\tvar propArray = props.length ? props.split(\" \") : [];\n\t\t\t// var manifestProps = manifest[Id].properties;\n\t\t\t// var manifestPropArray = manifestProps.length ? manifestProps.split(\" \") : [];\n\n\t\t\tvar itemref = {\n\t\t\t\t\"id\" : item.getAttribute(\"id\"),\n\t\t\t\t\"idref\" : idref,\n\t\t\t\t\"linear\" : item.getAttribute(\"linear\") || \"yes\",\n\t\t\t\t\"properties\" : propArray,\n\t\t\t\t// \"href\" : manifest[Id].href,\n\t\t\t\t// \"url\" :  manifest[Id].url,\n\t\t\t\t\"index\" : index\n\t\t\t\t// \"cfiBase\" : cfiBase\n\t\t\t};\n\t\t\tspine.push(itemref);\n\t\t});\n\n\t\treturn spine;\n\t}\n\n\t/**\n\t * Find Unique Identifier\n\t * @private\n\t * @param  {node} packageXml\n\t * @return {string} Unique Identifier text\n\t */\n\tfindUniqueIdentifier(packageXml){\n\t\tvar uniqueIdentifierId = packageXml.documentElement.getAttribute(\"unique-identifier\");\n\t\tif (! uniqueIdentifierId) {\n\t\t\treturn \"\";\n\t\t}\n\t\tvar identifier = packageXml.getElementById(uniqueIdentifierId);\n\t\tif (! identifier) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tif (identifier.localName === \"identifier\" && identifier.namespaceURI === \"http://purl.org/dc/elements/1.1/\") {\n\t\t\treturn identifier.childNodes.length > 0 ? identifier.childNodes[0].nodeValue.trim() : \"\";\n\t\t}\n\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Find TOC NAV\n\t * @private\n\t * @param {element} manifestNode\n\t * @return {string}\n\t */\n\tfindNavPath(manifestNode){\n\t\t// Find item with property \"nav\"\n\t\t// Should catch nav regardless of order\n\t\t// var node = manifestNode.querySelector(\"item[properties$='nav'], item[properties^='nav '], item[properties*=' nav ']\");\n\t\tvar node = qsp(manifestNode, \"item\", {\"properties\":\"nav\"});\n\t\treturn node ? node.getAttribute(\"href\") : false;\n\t}\n\n\t/**\n\t * Find TOC NCX\n\t * media-type=\"application/x-dtbncx+xml\" href=\"toc.ncx\"\n\t * @private\n\t * @param {element} manifestNode\n\t * @param {element} spineNode\n\t * @return {string}\n\t */\n\tfindNcxPath(manifestNode, spineNode){\n\t\t// var node = manifestNode.querySelector(\"item[media-type='application/x-dtbncx+xml']\");\n\t\tvar node = qsp(manifestNode, \"item\", {\"media-type\":\"application/x-dtbncx+xml\"});\n\t\tvar tocId;\n\n\t\t// If we can't find the toc by media-type then try to look for id of the item in the spine attributes as\n\t\t// according to http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.4.1.2,\n\t\t// \"The item that describes the NCX must be referenced by the spine toc attribute.\"\n\t\tif (!node) {\n\t\t\ttocId = spineNode.getAttribute(\"toc\");\n\t\t\tif(tocId) {\n\t\t\t\t// node = manifestNode.querySelector(\"item[id='\" + tocId + \"']\");\n\t\t\t\tnode = manifestNode.querySelector(`#${tocId}`);\n\t\t\t}\n\t\t}\n\n\t\treturn node ? node.getAttribute(\"href\") : false;\n\t}\n\n\t/**\n\t * Find the Cover Path\n\t * <item properties=\"cover-image\" id=\"ci\" href=\"cover.svg\" media-type=\"image/svg+xml\" />\n\t * Fallback for Epub 2.0\n\t * @private\n\t * @param  {node} packageXml\n\t * @return {string} href\n\t */\n\tfindCoverPath(packageXml){\n\t\tvar pkg = qs(packageXml, \"package\");\n\t\tvar epubVersion = pkg.getAttribute(\"version\");\n\t\t\n\t\t// Try parsing cover with epub 3.\n\t\t// var node = packageXml.querySelector(\"item[properties='cover-image']\");\n\t\tvar node = qsp(packageXml, \"item\", {\"properties\":\"cover-image\"});\n\t\tif (node) return node.getAttribute(\"href\");\n\t\t\n\t\t// Fallback to epub 2.\n\t\tvar metaCover = qsp(packageXml, \"meta\", {\"name\":\"cover\"});\n\n\t\tif (metaCover) {\n\t\t\tvar coverId = metaCover.getAttribute(\"content\");\n\t\t\t// var cover = packageXml.querySelector(\"item[id='\" + coverId + \"']\");\n\t\t\tvar cover = packageXml.getElementById(coverId);\n\t\t\treturn cover ? cover.getAttribute(\"href\") : \"\";\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Get text of a namespaced element\n\t * @private\n\t * @param  {node} xml\n\t * @param  {string} tag\n\t * @return {string} text\n\t */\n\tgetElementText(xml, tag){\n\t\tvar found = xml.getElementsByTagNameNS(\"http://purl.org/dc/elements/1.1/\", tag);\n\t\tvar el;\n\n\t\tif(!found || found.length === 0) return \"\";\n\n\t\tel = found[0];\n\n\t\tif(el.childNodes.length){\n\t\t\treturn el.childNodes[0].nodeValue;\n\t\t}\n\n\t\treturn \"\";\n\n\t}\n\n\t/**\n\t * Get text by property\n\t * @private\n\t * @param  {node} xml\n\t * @param  {string} property\n\t * @return {string} text\n\t */\n\tgetPropertyText(xml, property){\n\t\tvar el = qsp(xml, \"meta\", {\"property\":property});\n\n\t\tif(el && el.childNodes.length){\n\t\t\treturn el.childNodes[0].nodeValue;\n\t\t}\n\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Load JSON Manifest\n\t * @param  {document} packageDocument OPF XML\n\t * @return {object} parsed package parts\n\t */\n\tload(json) {\n\t\tthis.metadata = json.metadata;\n\n\t\tlet spine = json.readingOrder || json.spine;\n\t\tthis.spine = spine.map((item, index) =>{\n\t\t\titem.index = index;\n\t\t\titem.linear = item.linear || \"yes\";\n\t\t\treturn item;\n\t\t});\n\n\t\tjson.resources.forEach((item, index) => {\n\t\t\tthis.manifest[index] = item;\n\n\t\t\tif (item.rel && item.rel[0] === \"cover\") {\n\t\t\t\tthis.coverPath = item.href;\n\t\t\t}\n\t\t});\n\n\t\tthis.spineNodeIndex = 0;\n\n\t\tthis.toc = json.toc.map((item, index) =>{\n\t\t\titem.label = item.title;\n\t\t\treturn item;\n\t\t});\n\n\t\treturn {\n\t\t\t\"metadata\" : this.metadata,\n\t\t\t\"spine\"    : this.spine,\n\t\t\t\"manifest\" : this.manifest,\n\t\t\t\"navPath\"  : this.navPath,\n\t\t\t\"ncxPath\"  : this.ncxPath,\n\t\t\t\"coverPath\": this.coverPath,\n\t\t\t\"spineNodeIndex\" : this.spineNodeIndex,\n\t\t\t\"toc\" : this.toc\n\t\t};\n\t}\n\n\tdestroy() {\n\t\tthis.manifest = undefined;\n\t\tthis.navPath = undefined;\n\t\tthis.ncxPath = undefined;\n\t\tthis.coverPath = undefined;\n\t\tthis.spineNodeIndex = undefined;\n\t\tthis.spine = undefined;\n\t\tthis.metadata = undefined;\n\t}\n}\n\nexport default Packaging;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}