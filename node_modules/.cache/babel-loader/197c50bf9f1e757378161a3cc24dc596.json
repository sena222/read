{"ast":null,"code":"import { qs, qsa, qsp, indexOfElementNode } from \"./utils/core\";\n\n/**\n * Open Packaging Format Parser\n * @class\n * @param {document} packageDocument OPF XML\n */\nclass Packaging {\n  constructor(packageDocument) {\n    this.manifest = {};\n    this.navPath = '';\n    this.ncxPath = '';\n    this.coverPath = '';\n    this.spineNodeIndex = 0;\n    this.spine = [];\n    this.metadata = {};\n    if (packageDocument) {\n      this.parse(packageDocument);\n    }\n  }\n\n  /**\n   * Parse OPF XML\n   * @param  {document} packageDocument OPF XML\n   * @return {object} parsed package parts\n   */\n  parse(packageDocument) {\n    var metadataNode, manifestNode, spineNode;\n    if (!packageDocument) {\n      throw new Error(\"Package File Not Found\");\n    }\n    metadataNode = qs(packageDocument, \"metadata\");\n    if (!metadataNode) {\n      throw new Error(\"No Metadata Found\");\n    }\n    manifestNode = qs(packageDocument, \"manifest\");\n    if (!manifestNode) {\n      throw new Error(\"No Manifest Found\");\n    }\n    spineNode = qs(packageDocument, \"spine\");\n    if (!spineNode) {\n      throw new Error(\"No Spine Found\");\n    }\n    this.manifest = this.parseManifest(manifestNode);\n    this.navPath = this.findNavPath(manifestNode);\n    this.ncxPath = this.findNcxPath(manifestNode, spineNode);\n    this.coverPath = this.findCoverPath(packageDocument);\n    this.spineNodeIndex = indexOfElementNode(spineNode);\n    this.spine = this.parseSpine(spineNode, this.manifest);\n    this.uniqueIdentifier = this.findUniqueIdentifier(packageDocument);\n    this.metadata = this.parseMetadata(metadataNode);\n    this.metadata.direction = spineNode.getAttribute(\"page-progression-direction\");\n    return {\n      \"metadata\": this.metadata,\n      \"spine\": this.spine,\n      \"manifest\": this.manifest,\n      \"navPath\": this.navPath,\n      \"ncxPath\": this.ncxPath,\n      \"coverPath\": this.coverPath,\n      \"spineNodeIndex\": this.spineNodeIndex\n    };\n  }\n\n  /**\n   * Parse Metadata\n   * @private\n   * @param  {node} xml\n   * @return {object} metadata\n   */\n  parseMetadata(xml) {\n    var metadata = {};\n    metadata.title = this.getElementText(xml, \"title\");\n    metadata.creator = this.getElementText(xml, \"creator\");\n    metadata.description = this.getElementText(xml, \"description\");\n    metadata.pubdate = this.getElementText(xml, \"date\");\n    metadata.publisher = this.getElementText(xml, \"publisher\");\n    metadata.identifier = this.getElementText(xml, \"identifier\");\n    metadata.language = this.getElementText(xml, \"language\");\n    metadata.rights = this.getElementText(xml, \"rights\");\n    metadata.modified_date = this.getPropertyText(xml, \"dcterms:modified\");\n    metadata.layout = this.getPropertyText(xml, \"rendition:layout\");\n    metadata.orientation = this.getPropertyText(xml, \"rendition:orientation\");\n    metadata.flow = this.getPropertyText(xml, \"rendition:flow\");\n    metadata.viewport = this.getPropertyText(xml, \"rendition:viewport\");\n    metadata.media_active_class = this.getPropertyText(xml, \"media:active-class\");\n    metadata.spread = this.getPropertyText(xml, \"rendition:spread\");\n    // metadata.page_prog_dir = packageXml.querySelector(\"spine\").getAttribute(\"page-progression-direction\");\n\n    return metadata;\n  }\n\n  /**\n   * Parse Manifest\n   * @private\n   * @param  {node} manifestXml\n   * @return {object} manifest\n   */\n  parseManifest(manifestXml) {\n    var manifest = {};\n\n    //-- Turn items into an array\n    // var selected = manifestXml.querySelectorAll(\"item\");\n    var selected = qsa(manifestXml, \"item\");\n    var items = Array.prototype.slice.call(selected);\n\n    //-- Create an object with the id as key\n    items.forEach(function (item) {\n      var id = item.getAttribute(\"id\"),\n        href = item.getAttribute(\"href\") || \"\",\n        type = item.getAttribute(\"media-type\") || \"\",\n        overlay = item.getAttribute(\"media-overlay\") || \"\",\n        properties = item.getAttribute(\"properties\") || \"\";\n      manifest[id] = {\n        \"href\": href,\n        // \"url\" : href,\n        \"type\": type,\n        \"overlay\": overlay,\n        \"properties\": properties.length ? properties.split(\" \") : []\n      };\n    });\n    return manifest;\n  }\n\n  /**\n   * Parse Spine\n   * @private\n   * @param  {node} spineXml\n   * @param  {Packaging.manifest} manifest\n   * @return {object} spine\n   */\n  parseSpine(spineXml, manifest) {\n    var spine = [];\n    var selected = qsa(spineXml, \"itemref\");\n    var items = Array.prototype.slice.call(selected);\n\n    // var epubcfi = new EpubCFI();\n\n    //-- Add to array to maintain ordering and cross reference with manifest\n    items.forEach(function (item, index) {\n      var idref = item.getAttribute(\"idref\");\n      // var cfiBase = epubcfi.generateChapterComponent(spineNodeIndex, index, Id);\n      var props = item.getAttribute(\"properties\") || \"\";\n      var propArray = props.length ? props.split(\" \") : [];\n      // var manifestProps = manifest[Id].properties;\n      // var manifestPropArray = manifestProps.length ? manifestProps.split(\" \") : [];\n\n      var itemref = {\n        \"id\": item.getAttribute(\"id\"),\n        \"idref\": idref,\n        \"linear\": item.getAttribute(\"linear\") || \"yes\",\n        \"properties\": propArray,\n        // \"href\" : manifest[Id].href,\n        // \"url\" :  manifest[Id].url,\n        \"index\": index\n        // \"cfiBase\" : cfiBase\n      };\n\n      spine.push(itemref);\n    });\n    return spine;\n  }\n\n  /**\n   * Find Unique Identifier\n   * @private\n   * @param  {node} packageXml\n   * @return {string} Unique Identifier text\n   */\n  findUniqueIdentifier(packageXml) {\n    var uniqueIdentifierId = packageXml.documentElement.getAttribute(\"unique-identifier\");\n    if (!uniqueIdentifierId) {\n      return \"\";\n    }\n    var identifier = packageXml.getElementById(uniqueIdentifierId);\n    if (!identifier) {\n      return \"\";\n    }\n    if (identifier.localName === \"identifier\" && identifier.namespaceURI === \"http://purl.org/dc/elements/1.1/\") {\n      return identifier.childNodes.length > 0 ? identifier.childNodes[0].nodeValue.trim() : \"\";\n    }\n    return \"\";\n  }\n\n  /**\n   * Find TOC NAV\n   * @private\n   * @param {element} manifestNode\n   * @return {string}\n   */\n  findNavPath(manifestNode) {\n    // Find item with property \"nav\"\n    // Should catch nav regardless of order\n    // var node = manifestNode.querySelector(\"item[properties$='nav'], item[properties^='nav '], item[properties*=' nav ']\");\n    var node = qsp(manifestNode, \"item\", {\n      \"properties\": \"nav\"\n    });\n    return node ? node.getAttribute(\"href\") : false;\n  }\n\n  /**\n   * Find TOC NCX\n   * media-type=\"application/x-dtbncx+xml\" href=\"toc.ncx\"\n   * @private\n   * @param {element} manifestNode\n   * @param {element} spineNode\n   * @return {string}\n   */\n  findNcxPath(manifestNode, spineNode) {\n    // var node = manifestNode.querySelector(\"item[media-type='application/x-dtbncx+xml']\");\n    var node = qsp(manifestNode, \"item\", {\n      \"media-type\": \"application/x-dtbncx+xml\"\n    });\n    var tocId;\n\n    // If we can't find the toc by media-type then try to look for id of the item in the spine attributes as\n    // according to http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.4.1.2,\n    // \"The item that describes the NCX must be referenced by the spine toc attribute.\"\n    if (!node) {\n      tocId = spineNode.getAttribute(\"toc\");\n      if (tocId) {\n        // node = manifestNode.querySelector(\"item[id='\" + tocId + \"']\");\n        node = manifestNode.querySelector(`#${tocId}`);\n      }\n    }\n    return node ? node.getAttribute(\"href\") : false;\n  }\n\n  /**\n   * Find the Cover Path\n   * <item properties=\"cover-image\" id=\"ci\" href=\"cover.svg\" media-type=\"image/svg+xml\" />\n   * Fallback for Epub 2.0\n   * @private\n   * @param  {node} packageXml\n   * @return {string} href\n   */\n  findCoverPath(packageXml) {\n    var pkg = qs(packageXml, \"package\");\n    var epubVersion = pkg.getAttribute(\"version\");\n\n    // Try parsing cover with epub 3.\n    // var node = packageXml.querySelector(\"item[properties='cover-image']\");\n    var node = qsp(packageXml, \"item\", {\n      \"properties\": \"cover-image\"\n    });\n    if (node) return node.getAttribute(\"href\");\n\n    // Fallback to epub 2.\n    var metaCover = qsp(packageXml, \"meta\", {\n      \"name\": \"cover\"\n    });\n    if (metaCover) {\n      var coverId = metaCover.getAttribute(\"content\");\n      // var cover = packageXml.querySelector(\"item[id='\" + coverId + \"']\");\n      var cover = packageXml.getElementById(coverId);\n      return cover ? cover.getAttribute(\"href\") : \"\";\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Get text of a namespaced element\n   * @private\n   * @param  {node} xml\n   * @param  {string} tag\n   * @return {string} text\n   */\n  getElementText(xml, tag) {\n    var found = xml.getElementsByTagNameNS(\"http://purl.org/dc/elements/1.1/\", tag);\n    var el;\n    if (!found || found.length === 0) return \"\";\n    el = found[0];\n    if (el.childNodes.length) {\n      return el.childNodes[0].nodeValue;\n    }\n    return \"\";\n  }\n\n  /**\n   * Get text by property\n   * @private\n   * @param  {node} xml\n   * @param  {string} property\n   * @return {string} text\n   */\n  getPropertyText(xml, property) {\n    var el = qsp(xml, \"meta\", {\n      \"property\": property\n    });\n    if (el && el.childNodes.length) {\n      return el.childNodes[0].nodeValue;\n    }\n    return \"\";\n  }\n\n  /**\n   * Load JSON Manifest\n   * @param  {document} packageDocument OPF XML\n   * @return {object} parsed package parts\n   */\n  load(json) {\n    this.metadata = json.metadata;\n    let spine = json.readingOrder || json.spine;\n    this.spine = spine.map((item, index) => {\n      item.index = index;\n      item.linear = item.linear || \"yes\";\n      return item;\n    });\n    json.resources.forEach((item, index) => {\n      this.manifest[index] = item;\n      if (item.rel && item.rel[0] === \"cover\") {\n        this.coverPath = item.href;\n      }\n    });\n    this.spineNodeIndex = 0;\n    this.toc = json.toc.map((item, index) => {\n      item.label = item.title;\n      return item;\n    });\n    return {\n      \"metadata\": this.metadata,\n      \"spine\": this.spine,\n      \"manifest\": this.manifest,\n      \"navPath\": this.navPath,\n      \"ncxPath\": this.ncxPath,\n      \"coverPath\": this.coverPath,\n      \"spineNodeIndex\": this.spineNodeIndex,\n      \"toc\": this.toc\n    };\n  }\n  destroy() {\n    this.manifest = undefined;\n    this.navPath = undefined;\n    this.ncxPath = undefined;\n    this.coverPath = undefined;\n    this.spineNodeIndex = undefined;\n    this.spine = undefined;\n    this.metadata = undefined;\n  }\n}\nexport default Packaging;","map":{"version":3,"names":["qs","qsa","qsp","indexOfElementNode","Packaging","constructor","packageDocument","manifest","navPath","ncxPath","coverPath","spineNodeIndex","spine","metadata","parse","metadataNode","manifestNode","spineNode","Error","parseManifest","findNavPath","findNcxPath","findCoverPath","parseSpine","uniqueIdentifier","findUniqueIdentifier","parseMetadata","direction","getAttribute","xml","title","getElementText","creator","description","pubdate","publisher","identifier","language","rights","modified_date","getPropertyText","layout","orientation","flow","viewport","media_active_class","spread","manifestXml","selected","items","Array","prototype","slice","call","forEach","item","id","href","type","overlay","properties","length","split","spineXml","index","idref","props","propArray","itemref","push","packageXml","uniqueIdentifierId","documentElement","getElementById","localName","namespaceURI","childNodes","nodeValue","trim","node","tocId","querySelector","pkg","epubVersion","metaCover","coverId","cover","tag","found","getElementsByTagNameNS","el","property","load","json","readingOrder","map","linear","resources","rel","toc","label","destroy","undefined"],"sources":["/home/parallels/Downloads/react-epub-viewer-demo/node_modules/epubjs/src/packaging.js"],"sourcesContent":["import {qs, qsa, qsp, indexOfElementNode} from \"./utils/core\";\n\n/**\n * Open Packaging Format Parser\n * @class\n * @param {document} packageDocument OPF XML\n */\nclass Packaging {\n\tconstructor(packageDocument) {\n\t\tthis.manifest = {};\n\t\tthis.navPath = '';\n\t\tthis.ncxPath = '';\n\t\tthis.coverPath = '';\n\t\tthis.spineNodeIndex = 0;\n\t\tthis.spine = [];\n\t\tthis.metadata = {};\n\n\t\tif (packageDocument) {\n\t\t\tthis.parse(packageDocument);\n\t\t}\n\t}\n\n\t/**\n\t * Parse OPF XML\n\t * @param  {document} packageDocument OPF XML\n\t * @return {object} parsed package parts\n\t */\n\tparse(packageDocument){\n\t\tvar metadataNode, manifestNode, spineNode;\n\n\t\tif(!packageDocument) {\n\t\t\tthrow new Error(\"Package File Not Found\");\n\t\t}\n\n\t\tmetadataNode = qs(packageDocument, \"metadata\");\n\t\tif(!metadataNode) {\n\t\t\tthrow new Error(\"No Metadata Found\");\n\t\t}\n\n\t\tmanifestNode = qs(packageDocument, \"manifest\");\n\t\tif(!manifestNode) {\n\t\t\tthrow new Error(\"No Manifest Found\");\n\t\t}\n\n\t\tspineNode = qs(packageDocument, \"spine\");\n\t\tif(!spineNode) {\n\t\t\tthrow new Error(\"No Spine Found\");\n\t\t}\n\n\t\tthis.manifest = this.parseManifest(manifestNode);\n\t\tthis.navPath = this.findNavPath(manifestNode);\n\t\tthis.ncxPath = this.findNcxPath(manifestNode, spineNode);\n\t\tthis.coverPath = this.findCoverPath(packageDocument);\n\n\t\tthis.spineNodeIndex = indexOfElementNode(spineNode);\n\n\t\tthis.spine = this.parseSpine(spineNode, this.manifest);\n\n\t\tthis.uniqueIdentifier = this.findUniqueIdentifier(packageDocument);\n\t\tthis.metadata = this.parseMetadata(metadataNode);\n\n\t\tthis.metadata.direction = spineNode.getAttribute(\"page-progression-direction\");\n\n\t\treturn {\n\t\t\t\"metadata\" : this.metadata,\n\t\t\t\"spine\"    : this.spine,\n\t\t\t\"manifest\" : this.manifest,\n\t\t\t\"navPath\"  : this.navPath,\n\t\t\t\"ncxPath\"  : this.ncxPath,\n\t\t\t\"coverPath\": this.coverPath,\n\t\t\t\"spineNodeIndex\" : this.spineNodeIndex\n\t\t};\n\t}\n\n\t/**\n\t * Parse Metadata\n\t * @private\n\t * @param  {node} xml\n\t * @return {object} metadata\n\t */\n\tparseMetadata(xml){\n\t\tvar metadata = {};\n\n\t\tmetadata.title = this.getElementText(xml, \"title\");\n\t\tmetadata.creator = this.getElementText(xml, \"creator\");\n\t\tmetadata.description = this.getElementText(xml, \"description\");\n\n\t\tmetadata.pubdate = this.getElementText(xml, \"date\");\n\n\t\tmetadata.publisher = this.getElementText(xml, \"publisher\");\n\n\t\tmetadata.identifier = this.getElementText(xml, \"identifier\");\n\t\tmetadata.language = this.getElementText(xml, \"language\");\n\t\tmetadata.rights = this.getElementText(xml, \"rights\");\n\n\t\tmetadata.modified_date = this.getPropertyText(xml, \"dcterms:modified\");\n\n\t\tmetadata.layout = this.getPropertyText(xml, \"rendition:layout\");\n\t\tmetadata.orientation = this.getPropertyText(xml, \"rendition:orientation\");\n\t\tmetadata.flow = this.getPropertyText(xml, \"rendition:flow\");\n\t\tmetadata.viewport = this.getPropertyText(xml, \"rendition:viewport\");\n\t\tmetadata.media_active_class = this.getPropertyText(xml, \"media:active-class\");\n\t\tmetadata.spread = this.getPropertyText(xml, \"rendition:spread\");\n\t\t// metadata.page_prog_dir = packageXml.querySelector(\"spine\").getAttribute(\"page-progression-direction\");\n\n\t\treturn metadata;\n\t}\n\n\t/**\n\t * Parse Manifest\n\t * @private\n\t * @param  {node} manifestXml\n\t * @return {object} manifest\n\t */\n\tparseManifest(manifestXml){\n\t\tvar manifest = {};\n\n\t\t//-- Turn items into an array\n\t\t// var selected = manifestXml.querySelectorAll(\"item\");\n\t\tvar selected = qsa(manifestXml, \"item\");\n\t\tvar items = Array.prototype.slice.call(selected);\n\n\t\t//-- Create an object with the id as key\n\t\titems.forEach(function(item){\n\t\t\tvar id = item.getAttribute(\"id\"),\n\t\t\t\t\thref = item.getAttribute(\"href\") || \"\",\n\t\t\t\t\ttype = item.getAttribute(\"media-type\") || \"\",\n\t\t\t\t\toverlay = item.getAttribute(\"media-overlay\") || \"\",\n\t\t\t\t\tproperties = item.getAttribute(\"properties\") || \"\";\n\n\t\t\tmanifest[id] = {\n\t\t\t\t\"href\" : href,\n\t\t\t\t// \"url\" : href,\n\t\t\t\t\"type\" : type,\n\t\t\t\t\"overlay\" : overlay,\n\t\t\t\t\"properties\" : properties.length ? properties.split(\" \") : []\n\t\t\t};\n\n\t\t});\n\n\t\treturn manifest;\n\n\t}\n\n\t/**\n\t * Parse Spine\n\t * @private\n\t * @param  {node} spineXml\n\t * @param  {Packaging.manifest} manifest\n\t * @return {object} spine\n\t */\n\tparseSpine(spineXml, manifest){\n\t\tvar spine = [];\n\n\t\tvar selected = qsa(spineXml, \"itemref\");\n\t\tvar items = Array.prototype.slice.call(selected);\n\n\t\t// var epubcfi = new EpubCFI();\n\n\t\t//-- Add to array to maintain ordering and cross reference with manifest\n\t\titems.forEach(function(item, index){\n\t\t\tvar idref = item.getAttribute(\"idref\");\n\t\t\t// var cfiBase = epubcfi.generateChapterComponent(spineNodeIndex, index, Id);\n\t\t\tvar props = item.getAttribute(\"properties\") || \"\";\n\t\t\tvar propArray = props.length ? props.split(\" \") : [];\n\t\t\t// var manifestProps = manifest[Id].properties;\n\t\t\t// var manifestPropArray = manifestProps.length ? manifestProps.split(\" \") : [];\n\n\t\t\tvar itemref = {\n\t\t\t\t\"id\" : item.getAttribute(\"id\"),\n\t\t\t\t\"idref\" : idref,\n\t\t\t\t\"linear\" : item.getAttribute(\"linear\") || \"yes\",\n\t\t\t\t\"properties\" : propArray,\n\t\t\t\t// \"href\" : manifest[Id].href,\n\t\t\t\t// \"url\" :  manifest[Id].url,\n\t\t\t\t\"index\" : index\n\t\t\t\t// \"cfiBase\" : cfiBase\n\t\t\t};\n\t\t\tspine.push(itemref);\n\t\t});\n\n\t\treturn spine;\n\t}\n\n\t/**\n\t * Find Unique Identifier\n\t * @private\n\t * @param  {node} packageXml\n\t * @return {string} Unique Identifier text\n\t */\n\tfindUniqueIdentifier(packageXml){\n\t\tvar uniqueIdentifierId = packageXml.documentElement.getAttribute(\"unique-identifier\");\n\t\tif (! uniqueIdentifierId) {\n\t\t\treturn \"\";\n\t\t}\n\t\tvar identifier = packageXml.getElementById(uniqueIdentifierId);\n\t\tif (! identifier) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tif (identifier.localName === \"identifier\" && identifier.namespaceURI === \"http://purl.org/dc/elements/1.1/\") {\n\t\t\treturn identifier.childNodes.length > 0 ? identifier.childNodes[0].nodeValue.trim() : \"\";\n\t\t}\n\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Find TOC NAV\n\t * @private\n\t * @param {element} manifestNode\n\t * @return {string}\n\t */\n\tfindNavPath(manifestNode){\n\t\t// Find item with property \"nav\"\n\t\t// Should catch nav regardless of order\n\t\t// var node = manifestNode.querySelector(\"item[properties$='nav'], item[properties^='nav '], item[properties*=' nav ']\");\n\t\tvar node = qsp(manifestNode, \"item\", {\"properties\":\"nav\"});\n\t\treturn node ? node.getAttribute(\"href\") : false;\n\t}\n\n\t/**\n\t * Find TOC NCX\n\t * media-type=\"application/x-dtbncx+xml\" href=\"toc.ncx\"\n\t * @private\n\t * @param {element} manifestNode\n\t * @param {element} spineNode\n\t * @return {string}\n\t */\n\tfindNcxPath(manifestNode, spineNode){\n\t\t// var node = manifestNode.querySelector(\"item[media-type='application/x-dtbncx+xml']\");\n\t\tvar node = qsp(manifestNode, \"item\", {\"media-type\":\"application/x-dtbncx+xml\"});\n\t\tvar tocId;\n\n\t\t// If we can't find the toc by media-type then try to look for id of the item in the spine attributes as\n\t\t// according to http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.4.1.2,\n\t\t// \"The item that describes the NCX must be referenced by the spine toc attribute.\"\n\t\tif (!node) {\n\t\t\ttocId = spineNode.getAttribute(\"toc\");\n\t\t\tif(tocId) {\n\t\t\t\t// node = manifestNode.querySelector(\"item[id='\" + tocId + \"']\");\n\t\t\t\tnode = manifestNode.querySelector(`#${tocId}`);\n\t\t\t}\n\t\t}\n\n\t\treturn node ? node.getAttribute(\"href\") : false;\n\t}\n\n\t/**\n\t * Find the Cover Path\n\t * <item properties=\"cover-image\" id=\"ci\" href=\"cover.svg\" media-type=\"image/svg+xml\" />\n\t * Fallback for Epub 2.0\n\t * @private\n\t * @param  {node} packageXml\n\t * @return {string} href\n\t */\n\tfindCoverPath(packageXml){\n\t\tvar pkg = qs(packageXml, \"package\");\n\t\tvar epubVersion = pkg.getAttribute(\"version\");\n\t\t\n\t\t// Try parsing cover with epub 3.\n\t\t// var node = packageXml.querySelector(\"item[properties='cover-image']\");\n\t\tvar node = qsp(packageXml, \"item\", {\"properties\":\"cover-image\"});\n\t\tif (node) return node.getAttribute(\"href\");\n\t\t\n\t\t// Fallback to epub 2.\n\t\tvar metaCover = qsp(packageXml, \"meta\", {\"name\":\"cover\"});\n\n\t\tif (metaCover) {\n\t\t\tvar coverId = metaCover.getAttribute(\"content\");\n\t\t\t// var cover = packageXml.querySelector(\"item[id='\" + coverId + \"']\");\n\t\t\tvar cover = packageXml.getElementById(coverId);\n\t\t\treturn cover ? cover.getAttribute(\"href\") : \"\";\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Get text of a namespaced element\n\t * @private\n\t * @param  {node} xml\n\t * @param  {string} tag\n\t * @return {string} text\n\t */\n\tgetElementText(xml, tag){\n\t\tvar found = xml.getElementsByTagNameNS(\"http://purl.org/dc/elements/1.1/\", tag);\n\t\tvar el;\n\n\t\tif(!found || found.length === 0) return \"\";\n\n\t\tel = found[0];\n\n\t\tif(el.childNodes.length){\n\t\t\treturn el.childNodes[0].nodeValue;\n\t\t}\n\n\t\treturn \"\";\n\n\t}\n\n\t/**\n\t * Get text by property\n\t * @private\n\t * @param  {node} xml\n\t * @param  {string} property\n\t * @return {string} text\n\t */\n\tgetPropertyText(xml, property){\n\t\tvar el = qsp(xml, \"meta\", {\"property\":property});\n\n\t\tif(el && el.childNodes.length){\n\t\t\treturn el.childNodes[0].nodeValue;\n\t\t}\n\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Load JSON Manifest\n\t * @param  {document} packageDocument OPF XML\n\t * @return {object} parsed package parts\n\t */\n\tload(json) {\n\t\tthis.metadata = json.metadata;\n\n\t\tlet spine = json.readingOrder || json.spine;\n\t\tthis.spine = spine.map((item, index) =>{\n\t\t\titem.index = index;\n\t\t\titem.linear = item.linear || \"yes\";\n\t\t\treturn item;\n\t\t});\n\n\t\tjson.resources.forEach((item, index) => {\n\t\t\tthis.manifest[index] = item;\n\n\t\t\tif (item.rel && item.rel[0] === \"cover\") {\n\t\t\t\tthis.coverPath = item.href;\n\t\t\t}\n\t\t});\n\n\t\tthis.spineNodeIndex = 0;\n\n\t\tthis.toc = json.toc.map((item, index) =>{\n\t\t\titem.label = item.title;\n\t\t\treturn item;\n\t\t});\n\n\t\treturn {\n\t\t\t\"metadata\" : this.metadata,\n\t\t\t\"spine\"    : this.spine,\n\t\t\t\"manifest\" : this.manifest,\n\t\t\t\"navPath\"  : this.navPath,\n\t\t\t\"ncxPath\"  : this.ncxPath,\n\t\t\t\"coverPath\": this.coverPath,\n\t\t\t\"spineNodeIndex\" : this.spineNodeIndex,\n\t\t\t\"toc\" : this.toc\n\t\t};\n\t}\n\n\tdestroy() {\n\t\tthis.manifest = undefined;\n\t\tthis.navPath = undefined;\n\t\tthis.ncxPath = undefined;\n\t\tthis.coverPath = undefined;\n\t\tthis.spineNodeIndex = undefined;\n\t\tthis.spine = undefined;\n\t\tthis.metadata = undefined;\n\t}\n}\n\nexport default Packaging;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}