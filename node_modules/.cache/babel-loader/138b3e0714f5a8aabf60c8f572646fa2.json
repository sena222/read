{"ast":null,"code":"import _classCallCheck from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { qs, qsa, querySelectorByType, filterChildren, getParentByTagName } from \"./utils/core\";\n\n/**\n * Navigation Parser\n * @param {document} xml navigation html / xhtml / ncx\n */\nvar Navigation = /*#__PURE__*/function () {\n  function Navigation(xml) {\n    _classCallCheck(this, Navigation);\n    this.toc = [];\n    this.tocByHref = {};\n    this.tocById = {};\n    this.landmarks = [];\n    this.landmarksByType = {};\n    this.length = 0;\n    if (xml) {\n      this.parse(xml);\n    }\n  }\n\n  /**\n   * Parse out the navigation items\n   * @param {document} xml navigation html / xhtml / ncx\n   */\n  _createClass(Navigation, [{\n    key: \"parse\",\n    value: function parse(xml) {\n      var isXml = xml.nodeType;\n      var html;\n      var ncx;\n      if (isXml) {\n        html = qs(xml, \"html\");\n        ncx = qs(xml, \"ncx\");\n      }\n      if (!isXml) {\n        this.toc = this.load(xml);\n      } else if (html) {\n        this.toc = this.parseNav(xml);\n        this.landmarks = this.parseLandmarks(xml);\n      } else if (ncx) {\n        this.toc = this.parseNcx(xml);\n      }\n      this.length = 0;\n      this.unpack(this.toc);\n    }\n\n    /**\n     * Unpack navigation items\n     * @private\n     * @param  {array} toc\n     */\n  }, {\n    key: \"unpack\",\n    value: function unpack(toc) {\n      var item;\n      for (var i = 0; i < toc.length; i++) {\n        item = toc[i];\n        if (item.href) {\n          this.tocByHref[item.href] = i;\n        }\n        if (item.id) {\n          this.tocById[item.id] = i;\n        }\n        this.length++;\n        if (item.subitems.length) {\n          this.unpack(item.subitems);\n        }\n      }\n    }\n\n    /**\n     * Get an item from the navigation\n     * @param  {string} target\n     * @return {object} navItem\n     */\n  }, {\n    key: \"get\",\n    value: function get(target) {\n      var index;\n      if (!target) {\n        return this.toc;\n      }\n      if (target.indexOf(\"#\") === 0) {\n        index = this.tocById[target.substring(1)];\n      } else if (target in this.tocByHref) {\n        index = this.tocByHref[target];\n      }\n      return this.getByIndex(target, index, this.toc);\n    }\n\n    /**\n     * Get an item from navigation subitems recursively by index\n     * @param  {string} target\n     * @param  {number} index\n     * @param  {array} navItems\n     * @return {object} navItem\n     */\n  }, {\n    key: \"getByIndex\",\n    value: function getByIndex(target, index, navItems) {\n      if (navItems.length === 0) {\n        return;\n      }\n      var item = navItems[index];\n      if (item && (target === item.id || target === item.href)) {\n        return item;\n      } else {\n        var result;\n        for (var i = 0; i < navItems.length; ++i) {\n          result = this.getByIndex(target, index, navItems[i].subitems);\n          if (result) {\n            break;\n          }\n        }\n        return result;\n      }\n    }\n\n    /**\n     * Get a landmark by type\n     * List of types: https://idpf.github.io/epub-vocabs/structure/\n     * @param  {string} type\n     * @return {object} landmarkItem\n     */\n  }, {\n    key: \"landmark\",\n    value: function landmark(type) {\n      var index;\n      if (!type) {\n        return this.landmarks;\n      }\n      index = this.landmarksByType[type];\n      return this.landmarks[index];\n    }\n\n    /**\n     * Parse toc from a Epub > 3.0 Nav\n     * @private\n     * @param  {document} navHtml\n     * @return {array} navigation list\n     */\n  }, {\n    key: \"parseNav\",\n    value: function parseNav(navHtml) {\n      var navElement = querySelectorByType(navHtml, \"nav\", \"toc\");\n      var list = [];\n      if (!navElement) return list;\n      var navList = filterChildren(navElement, \"ol\", true);\n      if (!navList) return list;\n      list = this.parseNavList(navList);\n      return list;\n    }\n\n    /**\n     * Parses lists in the toc\n     * @param  {document} navListHtml\n     * @param  {string} parent id\n     * @return {array} navigation list\n     */\n  }, {\n    key: \"parseNavList\",\n    value: function parseNavList(navListHtml, parent) {\n      var result = [];\n      if (!navListHtml) return result;\n      if (!navListHtml.children) return result;\n      for (var i = 0; i < navListHtml.children.length; i++) {\n        var item = this.navItem(navListHtml.children[i], parent);\n        if (item) {\n          result.push(item);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Create a navItem\n     * @private\n     * @param  {element} item\n     * @return {object} navItem\n     */\n  }, {\n    key: \"navItem\",\n    value: function navItem(item, parent) {\n      var id = item.getAttribute(\"id\") || undefined;\n      var content = filterChildren(item, \"a\", true) || filterChildren(item, \"span\", true);\n      if (!content) {\n        return;\n      }\n      var src = content.getAttribute(\"href\") || \"\";\n      if (!id) {\n        id = src;\n      }\n      var text = content.textContent || \"\";\n      var subitems = [];\n      var nested = filterChildren(item, \"ol\", true);\n      if (nested) {\n        subitems = this.parseNavList(nested, id);\n      }\n      return {\n        \"id\": id,\n        \"href\": src,\n        \"label\": text,\n        \"subitems\": subitems,\n        \"parent\": parent\n      };\n    }\n\n    /**\n     * Parse landmarks from a Epub > 3.0 Nav\n     * @private\n     * @param  {document} navHtml\n     * @return {array} landmarks list\n     */\n  }, {\n    key: \"parseLandmarks\",\n    value: function parseLandmarks(navHtml) {\n      var navElement = querySelectorByType(navHtml, \"nav\", \"landmarks\");\n      var navItems = navElement ? qsa(navElement, \"li\") : [];\n      var length = navItems.length;\n      var i;\n      var list = [];\n      var item;\n      if (!navItems || length === 0) return list;\n      for (i = 0; i < length; ++i) {\n        item = this.landmarkItem(navItems[i]);\n        if (item) {\n          list.push(item);\n          this.landmarksByType[item.type] = i;\n        }\n      }\n      return list;\n    }\n\n    /**\n     * Create a landmarkItem\n     * @private\n     * @param  {element} item\n     * @return {object} landmarkItem\n     */\n  }, {\n    key: \"landmarkItem\",\n    value: function landmarkItem(item) {\n      var content = filterChildren(item, \"a\", true);\n      if (!content) {\n        return;\n      }\n      var type = content.getAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\") || undefined;\n      var href = content.getAttribute(\"href\") || \"\";\n      var text = content.textContent || \"\";\n      return {\n        \"href\": href,\n        \"label\": text,\n        \"type\": type\n      };\n    }\n\n    /**\n     * Parse from a Epub > 3.0 NC\n     * @private\n     * @param  {document} navHtml\n     * @return {array} navigation list\n     */\n  }, {\n    key: \"parseNcx\",\n    value: function parseNcx(tocXml) {\n      var navPoints = qsa(tocXml, \"navPoint\");\n      var length = navPoints.length;\n      var i;\n      var toc = {};\n      var list = [];\n      var item, parent;\n      if (!navPoints || length === 0) return list;\n      for (i = 0; i < length; ++i) {\n        item = this.ncxItem(navPoints[i]);\n        toc[item.id] = item;\n        if (!item.parent) {\n          list.push(item);\n        } else {\n          parent = toc[item.parent];\n          parent.subitems.push(item);\n        }\n      }\n      return list;\n    }\n\n    /**\n     * Create a ncxItem\n     * @private\n     * @param  {element} item\n     * @return {object} ncxItem\n     */\n  }, {\n    key: \"ncxItem\",\n    value: function ncxItem(item) {\n      var id = item.getAttribute(\"id\") || false,\n        content = qs(item, \"content\"),\n        src = content.getAttribute(\"src\"),\n        navLabel = qs(item, \"navLabel\"),\n        text = navLabel.textContent ? navLabel.textContent : \"\",\n        subitems = [],\n        parentNode = item.parentNode,\n        parent;\n      if (parentNode && (parentNode.nodeName === \"navPoint\" || parentNode.nodeName.split(':').slice(-1)[0] === \"navPoint\")) {\n        parent = parentNode.getAttribute(\"id\");\n      }\n      return {\n        \"id\": id,\n        \"href\": src,\n        \"label\": text,\n        \"subitems\": subitems,\n        \"parent\": parent\n      };\n    }\n\n    /**\n     * Load Spine Items\n     * @param  {object} json the items to be loaded\n     * @return {Array} navItems\n     */\n  }, {\n    key: \"load\",\n    value: function load(json) {\n      var _this = this;\n      return json.map(function (item) {\n        item.label = item.title;\n        item.subitems = item.children ? _this.load(item.children) : [];\n        return item;\n      });\n    }\n\n    /**\n     * forEach pass through\n     * @param  {Function} fn function to run on each item\n     * @return {method} forEach loop\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn) {\n      return this.toc.forEach(fn);\n    }\n  }]);\n  return Navigation;\n}();\nexport default Navigation;","map":{"version":3,"names":["qs","qsa","querySelectorByType","filterChildren","getParentByTagName","Navigation","xml","toc","tocByHref","tocById","landmarks","landmarksByType","length","parse","isXml","nodeType","html","ncx","load","parseNav","parseLandmarks","parseNcx","unpack","item","i","href","id","subitems","target","index","indexOf","substring","getByIndex","navItems","result","type","navHtml","navElement","list","navList","parseNavList","navListHtml","parent","children","navItem","push","getAttribute","undefined","content","src","text","textContent","nested","landmarkItem","getAttributeNS","tocXml","navPoints","ncxItem","navLabel","parentNode","nodeName","split","slice","json","map","label","title","fn","forEach"],"sources":["/home/parallels/Downloads/read/node_modules/epubjs/src/navigation.js"],"sourcesContent":["import {qs, qsa, querySelectorByType, filterChildren, getParentByTagName} from \"./utils/core\";\n\n/**\n * Navigation Parser\n * @param {document} xml navigation html / xhtml / ncx\n */\nclass Navigation {\n\tconstructor(xml) {\n\t\tthis.toc = [];\n\t\tthis.tocByHref = {};\n\t\tthis.tocById = {};\n\n\t\tthis.landmarks = [];\n\t\tthis.landmarksByType = {};\n\n\t\tthis.length = 0;\n\t\tif (xml) {\n\t\t\tthis.parse(xml);\n\t\t}\n\t}\n\n\t/**\n\t * Parse out the navigation items\n\t * @param {document} xml navigation html / xhtml / ncx\n\t */\n\tparse(xml) {\n\t\tlet isXml = xml.nodeType;\n\t\tlet html;\n\t\tlet ncx;\n\n\t\tif (isXml) {\n\t\t\thtml = qs(xml, \"html\");\n\t\t\tncx = qs(xml, \"ncx\");\n\t\t}\n\n\t\tif (!isXml) {\n\t\t\tthis.toc = this.load(xml);\n\t\t} else if(html) {\n\t\t\tthis.toc = this.parseNav(xml);\n\t\t\tthis.landmarks = this.parseLandmarks(xml);\n\t\t} else if(ncx){\n\t\t\tthis.toc = this.parseNcx(xml);\n\t\t}\n\n\t\tthis.length = 0;\n\n\t\tthis.unpack(this.toc);\n\t}\n\n\t/**\n\t * Unpack navigation items\n\t * @private\n\t * @param  {array} toc\n\t */\n\tunpack(toc) {\n\t\tvar item;\n\n\t\tfor (var i = 0; i < toc.length; i++) {\n\t\t\titem = toc[i];\n\n\t\t\tif (item.href) {\n\t\t\t\tthis.tocByHref[item.href] = i;\n\t\t\t}\n\n\t\t\tif (item.id) {\n\t\t\t\tthis.tocById[item.id] = i;\n\t\t\t}\n\n\t\t\tthis.length++;\n\n\t\t\tif (item.subitems.length) {\n\t\t\t\tthis.unpack(item.subitems);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Get an item from the navigation\n\t * @param  {string} target\n\t * @return {object} navItem\n\t */\n\tget(target) {\n\t\tvar index;\n\n\t\tif(!target) {\n\t\t\treturn this.toc;\n\t\t}\n\n\t\tif(target.indexOf(\"#\") === 0) {\n\t\t\tindex = this.tocById[target.substring(1)];\n\t\t} else if(target in this.tocByHref){\n\t\t\tindex = this.tocByHref[target];\n\t\t}\n\n\t\treturn this.getByIndex(target, index, this.toc);\n\t}\n\n\t/**\n\t * Get an item from navigation subitems recursively by index\n\t * @param  {string} target\n\t * @param  {number} index\n\t * @param  {array} navItems\n\t * @return {object} navItem\n\t */\n\tgetByIndex(target, index, navItems) {\n\t\tif (navItems.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst item = navItems[index];\n\t\tif (item && (target === item.id || target === item.href)) {\n\t\t\treturn item;\n\t\t} else {\n\t\t\tlet result;\n\t\t\tfor (let i = 0; i < navItems.length; ++i) {\n\t\t\t\tresult = this.getByIndex(target, index, navItems[i].subitems);\n\t\t\t\tif (result) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Get a landmark by type\n\t * List of types: https://idpf.github.io/epub-vocabs/structure/\n\t * @param  {string} type\n\t * @return {object} landmarkItem\n\t */\n\tlandmark(type) {\n\t\tvar index;\n\n\t\tif(!type) {\n\t\t\treturn this.landmarks;\n\t\t}\n\n\t\tindex = this.landmarksByType[type];\n\n\t\treturn this.landmarks[index];\n\t}\n\n\t/**\n\t * Parse toc from a Epub > 3.0 Nav\n\t * @private\n\t * @param  {document} navHtml\n\t * @return {array} navigation list\n\t */\n\tparseNav(navHtml){\n\t\tvar navElement = querySelectorByType(navHtml, \"nav\", \"toc\");\n\t\tvar list = [];\n\n\t\tif (!navElement) return list;\n\n\t\tlet navList = filterChildren(navElement, \"ol\", true);\n\t\tif (!navList) return list;\n\n\t\tlist = this.parseNavList(navList);\n\t\treturn list;\n\t}\n\n\t/**\n\t * Parses lists in the toc\n\t * @param  {document} navListHtml\n\t * @param  {string} parent id\n\t * @return {array} navigation list\n\t */\n\tparseNavList(navListHtml, parent) {\n\t\tconst result = [];\n\n\t\tif (!navListHtml) return result;\n\t\tif (!navListHtml.children) return result;\n\t\t\n\t\tfor (let i = 0; i < navListHtml.children.length; i++) {\n\t\t\tconst item = this.navItem(navListHtml.children[i], parent);\n\n\t\t\tif (item) {\n\t\t\t\tresult.push(item);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Create a navItem\n\t * @private\n\t * @param  {element} item\n\t * @return {object} navItem\n\t */\n\tnavItem(item, parent) {\n\t\tlet id = item.getAttribute(\"id\") || undefined;\n\t\tlet content = filterChildren(item, \"a\", true)\n\t\t\t|| filterChildren(item, \"span\", true);\n\n\t\tif (!content) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet src = content.getAttribute(\"href\") || \"\";\n\t\t\n\t\tif (!id) {\n\t\t\tid = src;\n\t\t}\n\t\tlet text = content.textContent || \"\";\n\n\t\tlet subitems = [];\n\t\tlet nested = filterChildren(item, \"ol\", true);\n\t\tif (nested) {\n\t\t\tsubitems = \tthis.parseNavList(nested, id);\n\t\t}\n\n\t\treturn {\n\t\t\t\"id\": id,\n\t\t\t\"href\": src,\n\t\t\t\"label\": text,\n\t\t\t\"subitems\" : subitems,\n\t\t\t\"parent\" : parent\n\t\t};\n\t}\n\n\t/**\n\t * Parse landmarks from a Epub > 3.0 Nav\n\t * @private\n\t * @param  {document} navHtml\n\t * @return {array} landmarks list\n\t */\n\tparseLandmarks(navHtml){\n\t\tvar navElement = querySelectorByType(navHtml, \"nav\", \"landmarks\");\n\t\tvar navItems = navElement ? qsa(navElement, \"li\") : [];\n\t\tvar length = navItems.length;\n\t\tvar i;\n\t\tvar list = [];\n\t\tvar item;\n\n\t\tif(!navItems || length === 0) return list;\n\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\titem = this.landmarkItem(navItems[i]);\n\t\t\tif (item) {\n\t\t\t\tlist.push(item);\n\t\t\t\tthis.landmarksByType[item.type] = i;\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}\n\n\t/**\n\t * Create a landmarkItem\n\t * @private\n\t * @param  {element} item\n\t * @return {object} landmarkItem\n\t */\n\tlandmarkItem(item){\n\t\tlet content = filterChildren(item, \"a\", true);\n\n\t\tif (!content) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet type = content.getAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\") || undefined;\n\t\tlet href = content.getAttribute(\"href\") || \"\";\n\t\tlet text = content.textContent || \"\";\n\n\t\treturn {\n\t\t\t\"href\": href,\n\t\t\t\"label\": text,\n\t\t\t\"type\" : type\n\t\t};\n\t}\n\n\t/**\n\t * Parse from a Epub > 3.0 NC\n\t * @private\n\t * @param  {document} navHtml\n\t * @return {array} navigation list\n\t */\n\tparseNcx(tocXml){\n\t\tvar navPoints = qsa(tocXml, \"navPoint\");\n\t\tvar length = navPoints.length;\n\t\tvar i;\n\t\tvar toc = {};\n\t\tvar list = [];\n\t\tvar item, parent;\n\n\t\tif(!navPoints || length === 0) return list;\n\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\titem = this.ncxItem(navPoints[i]);\n\t\t\ttoc[item.id] = item;\n\t\t\tif(!item.parent) {\n\t\t\t\tlist.push(item);\n\t\t\t} else {\n\t\t\t\tparent = toc[item.parent];\n\t\t\t\tparent.subitems.push(item);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}\n\n\t/**\n\t * Create a ncxItem\n\t * @private\n\t * @param  {element} item\n\t * @return {object} ncxItem\n\t */\n\tncxItem(item){\n\t\tvar id = item.getAttribute(\"id\") || false,\n\t\t\t\tcontent = qs(item, \"content\"),\n\t\t\t\tsrc = content.getAttribute(\"src\"),\n\t\t\t\tnavLabel = qs(item, \"navLabel\"),\n\t\t\t\ttext = navLabel.textContent ? navLabel.textContent : \"\",\n\t\t\t\tsubitems = [],\n\t\t\t\tparentNode = item.parentNode,\n\t\t\t\tparent;\n\n\t\tif(parentNode && (parentNode.nodeName === \"navPoint\" || parentNode.nodeName.split(':').slice(-1)[0] === \"navPoint\")) {\n\t\t\tparent = parentNode.getAttribute(\"id\");\n\t\t}\n\n\n\t\treturn {\n\t\t\t\"id\": id,\n\t\t\t\"href\": src,\n\t\t\t\"label\": text,\n\t\t\t\"subitems\" : subitems,\n\t\t\t\"parent\" : parent\n\t\t};\n\t}\n\n\t/**\n\t * Load Spine Items\n\t * @param  {object} json the items to be loaded\n\t * @return {Array} navItems\n\t */\n\tload(json) {\n\t\treturn json.map(item => {\n\t\t\titem.label = item.title;\n\t\t\titem.subitems = item.children ? this.load(item.children) : [];\n\t\t\treturn item;\n\t\t});\n\t}\n\n\t/**\n\t * forEach pass through\n\t * @param  {Function} fn function to run on each item\n\t * @return {method} forEach loop\n\t */\n\tforEach(fn) {\n\t\treturn this.toc.forEach(fn);\n\t}\n}\n\nexport default Navigation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}