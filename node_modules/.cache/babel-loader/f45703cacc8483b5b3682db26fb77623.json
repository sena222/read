{"ast":null,"code":"import { defer, isXml, parse } from \"./utils/core\";\nimport request from \"./utils/request\";\nimport mime from \"./utils/mime\";\nimport Path from \"./utils/path\";\nimport JSZip from \"jszip/dist/jszip\";\n\n/**\n * Handles Unzipping a requesting files from an Epub Archive\n * @class\n */\nclass Archive {\n  constructor() {\n    this.zip = undefined;\n    this.urlCache = {};\n    this.checkRequirements();\n  }\n\n  /**\n   * Checks to see if JSZip exists in global namspace,\n   * Requires JSZip if it isn't there\n   * @private\n   */\n  checkRequirements() {\n    try {\n      this.zip = new JSZip();\n    } catch (e) {\n      throw new Error(\"JSZip lib not loaded\");\n    }\n  }\n\n  /**\n   * Open an archive\n   * @param  {binary} input\n   * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded\n   * @return {Promise} zipfile\n   */\n  open(input, isBase64) {\n    return this.zip.loadAsync(input, {\n      \"base64\": isBase64\n    });\n  }\n\n  /**\n   * Load and Open an archive\n   * @param  {string} zipUrl\n   * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded\n   * @return {Promise} zipfile\n   */\n  openUrl(zipUrl, isBase64) {\n    return request(zipUrl, \"binary\").then(function (data) {\n      return this.zip.loadAsync(data, {\n        \"base64\": isBase64\n      });\n    }.bind(this));\n  }\n\n  /**\n   * Request a url from the archive\n   * @param  {string} url  a url to request from the archive\n   * @param  {string} [type] specify the type of the returned result\n   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}\n   */\n  request(url, type) {\n    var deferred = new defer();\n    var response;\n    var path = new Path(url);\n\n    // If type isn't set, determine it from the file extension\n    if (!type) {\n      type = path.extension;\n    }\n    if (type == \"blob\") {\n      response = this.getBlob(url);\n    } else {\n      response = this.getText(url);\n    }\n    if (response) {\n      response.then(function (r) {\n        let result = this.handleResponse(r, type);\n        deferred.resolve(result);\n      }.bind(this));\n    } else {\n      deferred.reject({\n        message: \"File not found in the epub: \" + url,\n        stack: new Error().stack\n      });\n    }\n    return deferred.promise;\n  }\n\n  /**\n   * Handle the response from request\n   * @private\n   * @param  {any} response\n   * @param  {string} [type]\n   * @return {any} the parsed result\n   */\n  handleResponse(response, type) {\n    var r;\n    if (type == \"json\") {\n      r = JSON.parse(response);\n    } else if (isXml(type)) {\n      r = parse(response, \"text/xml\");\n    } else if (type == \"xhtml\") {\n      r = parse(response, \"application/xhtml+xml\");\n    } else if (type == \"html\" || type == \"htm\") {\n      r = parse(response, \"text/html\");\n    } else {\n      r = response;\n    }\n    return r;\n  }\n\n  /**\n   * Get a Blob from Archive by Url\n   * @param  {string} url\n   * @param  {string} [mimeType]\n   * @return {Blob}\n   */\n  getBlob(url, mimeType) {\n    var decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n    var entry = this.zip.file(decodededUrl);\n    if (entry) {\n      mimeType = mimeType || mime.lookup(entry.name);\n      return entry.async(\"uint8array\").then(function (uint8array) {\n        return new Blob([uint8array], {\n          type: mimeType\n        });\n      });\n    }\n  }\n\n  /**\n   * Get Text from Archive by Url\n   * @param  {string} url\n   * @param  {string} [encoding]\n   * @return {string}\n   */\n  getText(url, encoding) {\n    var decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n    var entry = this.zip.file(decodededUrl);\n    if (entry) {\n      return entry.async(\"string\").then(function (text) {\n        return text;\n      });\n    }\n  }\n\n  /**\n   * Get a base64 encoded result from Archive by Url\n   * @param  {string} url\n   * @param  {string} [mimeType]\n   * @return {string} base64 encoded\n   */\n  getBase64(url, mimeType) {\n    var decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n    var entry = this.zip.file(decodededUrl);\n    if (entry) {\n      mimeType = mimeType || mime.lookup(entry.name);\n      return entry.async(\"base64\").then(function (data) {\n        return \"data:\" + mimeType + \";base64,\" + data;\n      });\n    }\n  }\n\n  /**\n   * Create a Url from an unarchived item\n   * @param  {string} url\n   * @param  {object} [options.base64] use base64 encoding or blob url\n   * @return {Promise} url promise with Url string\n   */\n  createUrl(url, options) {\n    var deferred = new defer();\n    var _URL = window.URL || window.webkitURL || window.mozURL;\n    var tempUrl;\n    var response;\n    var useBase64 = options && options.base64;\n    if (url in this.urlCache) {\n      deferred.resolve(this.urlCache[url]);\n      return deferred.promise;\n    }\n    if (useBase64) {\n      response = this.getBase64(url);\n      if (response) {\n        response.then(function (tempUrl) {\n          this.urlCache[url] = tempUrl;\n          deferred.resolve(tempUrl);\n        }.bind(this));\n      }\n    } else {\n      response = this.getBlob(url);\n      if (response) {\n        response.then(function (blob) {\n          tempUrl = _URL.createObjectURL(blob);\n          this.urlCache[url] = tempUrl;\n          deferred.resolve(tempUrl);\n        }.bind(this));\n      }\n    }\n    if (!response) {\n      deferred.reject({\n        message: \"File not found in the epub: \" + url,\n        stack: new Error().stack\n      });\n    }\n    return deferred.promise;\n  }\n\n  /**\n   * Revoke Temp Url for a archive item\n   * @param  {string} url url of the item in the archive\n   */\n  revokeUrl(url) {\n    var _URL = window.URL || window.webkitURL || window.mozURL;\n    var fromCache = this.urlCache[url];\n    if (fromCache) _URL.revokeObjectURL(fromCache);\n  }\n  destroy() {\n    var _URL = window.URL || window.webkitURL || window.mozURL;\n    for (let fromCache in this.urlCache) {\n      _URL.revokeObjectURL(fromCache);\n    }\n    this.zip = undefined;\n    this.urlCache = {};\n  }\n}\nexport default Archive;","map":{"version":3,"names":["defer","isXml","parse","request","mime","Path","JSZip","Archive","constructor","zip","undefined","urlCache","checkRequirements","e","Error","open","input","isBase64","loadAsync","openUrl","zipUrl","then","data","bind","url","type","deferred","response","path","extension","getBlob","getText","r","result","handleResponse","resolve","reject","message","stack","promise","JSON","mimeType","decodededUrl","window","decodeURIComponent","substr","entry","file","lookup","name","async","uint8array","Blob","encoding","text","getBase64","createUrl","options","_URL","URL","webkitURL","mozURL","tempUrl","useBase64","base64","blob","createObjectURL","revokeUrl","fromCache","revokeObjectURL","destroy"],"sources":["/home/parallels/Downloads/react-epub-viewer-demo/node_modules/epubjs/src/archive.js"],"sourcesContent":["import {defer, isXml, parse} from \"./utils/core\";\nimport request from \"./utils/request\";\nimport mime from \"./utils/mime\";\nimport Path from \"./utils/path\";\nimport JSZip from \"jszip/dist/jszip\";\n\n/**\n * Handles Unzipping a requesting files from an Epub Archive\n * @class\n */\nclass Archive {\n\n\tconstructor() {\n\t\tthis.zip = undefined;\n\t\tthis.urlCache = {};\n\n\t\tthis.checkRequirements();\n\n\t}\n\n\t/**\n\t * Checks to see if JSZip exists in global namspace,\n\t * Requires JSZip if it isn't there\n\t * @private\n\t */\n\tcheckRequirements(){\n\t\ttry {\n\t\t\tthis.zip = new JSZip();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"JSZip lib not loaded\");\n\t\t}\n\t}\n\n\t/**\n\t * Open an archive\n\t * @param  {binary} input\n\t * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded\n\t * @return {Promise} zipfile\n\t */\n\topen(input, isBase64){\n\t\treturn this.zip.loadAsync(input, {\"base64\": isBase64});\n\t}\n\n\t/**\n\t * Load and Open an archive\n\t * @param  {string} zipUrl\n\t * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded\n\t * @return {Promise} zipfile\n\t */\n\topenUrl(zipUrl, isBase64){\n\t\treturn request(zipUrl, \"binary\")\n\t\t\t.then(function(data){\n\t\t\t\treturn this.zip.loadAsync(data, {\"base64\": isBase64});\n\t\t\t}.bind(this));\n\t}\n\n\t/**\n\t * Request a url from the archive\n\t * @param  {string} url  a url to request from the archive\n\t * @param  {string} [type] specify the type of the returned result\n\t * @return {Promise<Blob | string | JSON | Document | XMLDocument>}\n\t */\n\trequest(url, type){\n\t\tvar deferred = new defer();\n\t\tvar response;\n\t\tvar path = new Path(url);\n\n\t\t// If type isn't set, determine it from the file extension\n\t\tif(!type) {\n\t\t\ttype = path.extension;\n\t\t}\n\n\t\tif(type == \"blob\"){\n\t\t\tresponse = this.getBlob(url);\n\t\t} else {\n\t\t\tresponse = this.getText(url);\n\t\t}\n\n\t\tif (response) {\n\t\t\tresponse.then(function (r) {\n\t\t\t\tlet result = this.handleResponse(r, type);\n\t\t\t\tdeferred.resolve(result);\n\t\t\t}.bind(this));\n\t\t} else {\n\t\t\tdeferred.reject({\n\t\t\t\tmessage : \"File not found in the epub: \" + url,\n\t\t\t\tstack : new Error().stack\n\t\t\t});\n\t\t}\n\t\treturn deferred.promise;\n\t}\n\n\t/**\n\t * Handle the response from request\n\t * @private\n\t * @param  {any} response\n\t * @param  {string} [type]\n\t * @return {any} the parsed result\n\t */\n\thandleResponse(response, type){\n\t\tvar r;\n\n\t\tif(type == \"json\") {\n\t\t\tr = JSON.parse(response);\n\t\t}\n\t\telse\n\t\tif(isXml(type)) {\n\t\t\tr = parse(response, \"text/xml\");\n\t\t}\n\t\telse\n\t\tif(type == \"xhtml\") {\n\t\t\tr = parse(response, \"application/xhtml+xml\");\n\t\t}\n\t\telse\n\t\tif(type == \"html\" || type == \"htm\") {\n\t\t\tr = parse(response, \"text/html\");\n\t\t } else {\n\t\t\t r = response;\n\t\t }\n\n\t\treturn r;\n\t}\n\n\t/**\n\t * Get a Blob from Archive by Url\n\t * @param  {string} url\n\t * @param  {string} [mimeType]\n\t * @return {Blob}\n\t */\n\tgetBlob(url, mimeType){\n\t\tvar decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n\t\tvar entry = this.zip.file(decodededUrl);\n\n\t\tif(entry) {\n\t\t\tmimeType = mimeType || mime.lookup(entry.name);\n\t\t\treturn entry.async(\"uint8array\").then(function(uint8array) {\n\t\t\t\treturn new Blob([uint8array], {type : mimeType});\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get Text from Archive by Url\n\t * @param  {string} url\n\t * @param  {string} [encoding]\n\t * @return {string}\n\t */\n\tgetText(url, encoding){\n\t\tvar decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n\t\tvar entry = this.zip.file(decodededUrl);\n\n\t\tif(entry) {\n\t\t\treturn entry.async(\"string\").then(function(text) {\n\t\t\t\treturn text;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get a base64 encoded result from Archive by Url\n\t * @param  {string} url\n\t * @param  {string} [mimeType]\n\t * @return {string} base64 encoded\n\t */\n\tgetBase64(url, mimeType){\n\t\tvar decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n\t\tvar entry = this.zip.file(decodededUrl);\n\n\t\tif(entry) {\n\t\t\tmimeType = mimeType || mime.lookup(entry.name);\n\t\t\treturn entry.async(\"base64\").then(function(data) {\n\t\t\t\treturn \"data:\" + mimeType + \";base64,\" + data;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create a Url from an unarchived item\n\t * @param  {string} url\n\t * @param  {object} [options.base64] use base64 encoding or blob url\n\t * @return {Promise} url promise with Url string\n\t */\n\tcreateUrl(url, options){\n\t\tvar deferred = new defer();\n\t\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\t\tvar tempUrl;\n\t\tvar response;\n\t\tvar useBase64 = options && options.base64;\n\n\t\tif(url in this.urlCache) {\n\t\t\tdeferred.resolve(this.urlCache[url]);\n\t\t\treturn deferred.promise;\n\t\t}\n\n\t\tif (useBase64) {\n\t\t\tresponse = this.getBase64(url);\n\n\t\t\tif (response) {\n\t\t\t\tresponse.then(function(tempUrl) {\n\n\t\t\t\t\tthis.urlCache[url] = tempUrl;\n\t\t\t\t\tdeferred.resolve(tempUrl);\n\n\t\t\t\t}.bind(this));\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tresponse = this.getBlob(url);\n\n\t\t\tif (response) {\n\t\t\t\tresponse.then(function(blob) {\n\n\t\t\t\t\ttempUrl = _URL.createObjectURL(blob);\n\t\t\t\t\tthis.urlCache[url] = tempUrl;\n\t\t\t\t\tdeferred.resolve(tempUrl);\n\n\t\t\t\t}.bind(this));\n\n\t\t\t}\n\t\t}\n\n\n\t\tif (!response) {\n\t\t\tdeferred.reject({\n\t\t\t\tmessage : \"File not found in the epub: \" + url,\n\t\t\t\tstack : new Error().stack\n\t\t\t});\n\t\t}\n\n\t\treturn deferred.promise;\n\t}\n\n\t/**\n\t * Revoke Temp Url for a archive item\n\t * @param  {string} url url of the item in the archive\n\t */\n\trevokeUrl(url){\n\t\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\t\tvar fromCache = this.urlCache[url];\n\t\tif(fromCache) _URL.revokeObjectURL(fromCache);\n\t}\n\n\tdestroy() {\n\t\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\t\tfor (let fromCache in this.urlCache) {\n\t\t\t_URL.revokeObjectURL(fromCache);\n\t\t}\n\t\tthis.zip = undefined;\n\t\tthis.urlCache = {};\n\t}\n}\n\nexport default Archive;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}