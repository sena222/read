{"ast":null,"code":"import _classCallCheck from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport EpubCFI from \"./epubcfi\";\nimport { nodeBounds } from \"./utils/core\";\n\n/**\n * Map text locations to CFI ranges\n * @class\n * @param {Layout} layout Layout to apply\n * @param {string} [direction=\"ltr\"] Text direction\n * @param {string} [axis=\"horizontal\"] vertical or horizontal axis\n * @param {boolean} [dev] toggle developer highlighting\n */\nvar Mapping = /*#__PURE__*/function () {\n  function Mapping(layout, direction, axis) {\n    var dev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    _classCallCheck(this, Mapping);\n    this.layout = layout;\n    this.horizontal = axis === \"horizontal\" ? true : false;\n    this.direction = direction || \"ltr\";\n    this._dev = dev;\n  }\n\n  /**\n   * Find CFI pairs for entire section at once\n   */\n  _createClass(Mapping, [{\n    key: \"section\",\n    value: function section(view) {\n      var ranges = this.findRanges(view);\n      var map = this.rangeListToCfiList(view.section.cfiBase, ranges);\n      return map;\n    }\n\n    /**\n     * Find CFI pairs for a page\n     * @param {Contents} contents Contents from view\n     * @param {string} cfiBase string of the base for a cfi\n     * @param {number} start position to start at\n     * @param {number} end position to end at\n     */\n  }, {\n    key: \"page\",\n    value: function page(contents, cfiBase, start, end) {\n      var root = contents && contents.document ? contents.document.body : false;\n      var result;\n      if (!root) {\n        return;\n      }\n      result = this.rangePairToCfiPair(cfiBase, {\n        start: this.findStart(root, start, end),\n        end: this.findEnd(root, start, end)\n      });\n      if (this._dev === true) {\n        var doc = contents.document;\n        var startRange = new EpubCFI(result.start).toRange(doc);\n        var endRange = new EpubCFI(result.end).toRange(doc);\n        var selection = doc.defaultView.getSelection();\n        var r = doc.createRange();\n        selection.removeAllRanges();\n        r.setStart(startRange.startContainer, startRange.startOffset);\n        r.setEnd(endRange.endContainer, endRange.endOffset);\n        selection.addRange(r);\n      }\n      return result;\n    }\n\n    /**\n     * Walk a node, preforming a function on each node it finds\n     * @private\n     * @param {Node} root Node to walkToNode\n     * @param {function} func walk function\n     * @return {*} returns the result of the walk function\n     */\n  }, {\n    key: \"walk\",\n    value: function walk(root, func) {\n      // IE11 has strange issue, if root is text node IE throws exception on\n      // calling treeWalker.nextNode(), saying\n      // Unexpected call to method or property access instead of returning null value\n      if (root && root.nodeType === Node.TEXT_NODE) {\n        return;\n      }\n      // safeFilter is required so that it can work in IE as filter is a function for IE\n      // and for other browser filter is an object.\n      var filter = {\n        acceptNode: function acceptNode(node) {\n          if (node.data.trim().length > 0) {\n            return NodeFilter.FILTER_ACCEPT;\n          } else {\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n      };\n      var safeFilter = filter.acceptNode;\n      safeFilter.acceptNode = filter.acceptNode;\n      var treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, safeFilter, false);\n      var node;\n      var result;\n      while (node = treeWalker.nextNode()) {\n        result = func(node);\n        if (result) break;\n      }\n      return result;\n    }\n  }, {\n    key: \"findRanges\",\n    value: function findRanges(view) {\n      var columns = [];\n      var scrollWidth = view.contents.scrollWidth();\n      var spreads = Math.ceil(scrollWidth / this.layout.spreadWidth);\n      var count = spreads * this.layout.divisor;\n      var columnWidth = this.layout.columnWidth;\n      var gap = this.layout.gap;\n      var start, end;\n      for (var i = 0; i < count.pages; i++) {\n        start = (columnWidth + gap) * i;\n        end = columnWidth * (i + 1) + gap * i;\n        columns.push({\n          start: this.findStart(view.document.body, start, end),\n          end: this.findEnd(view.document.body, start, end)\n        });\n      }\n      return columns;\n    }\n\n    /**\n     * Find Start Range\n     * @private\n     * @param {Node} root root node\n     * @param {number} start position to start at\n     * @param {number} end position to end at\n     * @return {Range}\n     */\n  }, {\n    key: \"findStart\",\n    value: function findStart(root, start, end) {\n      var _this = this;\n      var stack = [root];\n      var $el;\n      var found;\n      var $prev = root;\n      while (stack.length) {\n        $el = stack.shift();\n        found = this.walk($el, function (node) {\n          var left, right, top, bottom;\n          var elPos;\n          var elRange;\n          elPos = nodeBounds(node);\n          if (_this.horizontal && _this.direction === \"ltr\") {\n            left = _this.horizontal ? elPos.left : elPos.top;\n            right = _this.horizontal ? elPos.right : elPos.bottom;\n            if (left >= start && left <= end) {\n              return node;\n            } else if (right > start) {\n              return node;\n            } else {\n              $prev = node;\n              stack.push(node);\n            }\n          } else if (_this.horizontal && _this.direction === \"rtl\") {\n            left = elPos.left;\n            right = elPos.right;\n            if (right <= end && right >= start) {\n              return node;\n            } else if (left < end) {\n              return node;\n            } else {\n              $prev = node;\n              stack.push(node);\n            }\n          } else {\n            top = elPos.top;\n            bottom = elPos.bottom;\n            if (top >= start && top <= end) {\n              return node;\n            } else if (bottom > start) {\n              return node;\n            } else {\n              $prev = node;\n              stack.push(node);\n            }\n          }\n        });\n        if (found) {\n          return this.findTextStartRange(found, start, end);\n        }\n      }\n\n      // Return last element\n      return this.findTextStartRange($prev, start, end);\n    }\n\n    /**\n     * Find End Range\n     * @private\n     * @param {Node} root root node\n     * @param {number} start position to start at\n     * @param {number} end position to end at\n     * @return {Range}\n     */\n  }, {\n    key: \"findEnd\",\n    value: function findEnd(root, start, end) {\n      var _this2 = this;\n      var stack = [root];\n      var $el;\n      var $prev = root;\n      var found;\n      while (stack.length) {\n        $el = stack.shift();\n        found = this.walk($el, function (node) {\n          var left, right, top, bottom;\n          var elPos;\n          var elRange;\n          elPos = nodeBounds(node);\n          if (_this2.horizontal && _this2.direction === \"ltr\") {\n            left = Math.round(elPos.left);\n            right = Math.round(elPos.right);\n            if (left > end && $prev) {\n              return $prev;\n            } else if (right > end) {\n              return node;\n            } else {\n              $prev = node;\n              stack.push(node);\n            }\n          } else if (_this2.horizontal && _this2.direction === \"rtl\") {\n            left = Math.round(_this2.horizontal ? elPos.left : elPos.top);\n            right = Math.round(_this2.horizontal ? elPos.right : elPos.bottom);\n            if (right < start && $prev) {\n              return $prev;\n            } else if (left < start) {\n              return node;\n            } else {\n              $prev = node;\n              stack.push(node);\n            }\n          } else {\n            top = Math.round(elPos.top);\n            bottom = Math.round(elPos.bottom);\n            if (top > end && $prev) {\n              return $prev;\n            } else if (bottom > end) {\n              return node;\n            } else {\n              $prev = node;\n              stack.push(node);\n            }\n          }\n        });\n        if (found) {\n          return this.findTextEndRange(found, start, end);\n        }\n      }\n\n      // end of chapter\n      return this.findTextEndRange($prev, start, end);\n    }\n\n    /**\n     * Find Text Start Range\n     * @private\n     * @param {Node} root root node\n     * @param {number} start position to start at\n     * @param {number} end position to end at\n     * @return {Range}\n     */\n  }, {\n    key: \"findTextStartRange\",\n    value: function findTextStartRange(node, start, end) {\n      var ranges = this.splitTextNodeIntoRanges(node);\n      var range;\n      var pos;\n      var left, top, right;\n      for (var i = 0; i < ranges.length; i++) {\n        range = ranges[i];\n        pos = range.getBoundingClientRect();\n        if (this.horizontal && this.direction === \"ltr\") {\n          left = pos.left;\n          if (left >= start) {\n            return range;\n          }\n        } else if (this.horizontal && this.direction === \"rtl\") {\n          right = pos.right;\n          if (right <= end) {\n            return range;\n          }\n        } else {\n          top = pos.top;\n          if (top >= start) {\n            return range;\n          }\n        }\n\n        // prev = range;\n      }\n\n      return ranges[0];\n    }\n\n    /**\n     * Find Text End Range\n     * @private\n     * @param {Node} root root node\n     * @param {number} start position to start at\n     * @param {number} end position to end at\n     * @return {Range}\n     */\n  }, {\n    key: \"findTextEndRange\",\n    value: function findTextEndRange(node, start, end) {\n      var ranges = this.splitTextNodeIntoRanges(node);\n      var prev;\n      var range;\n      var pos;\n      var left, right, top, bottom;\n      for (var i = 0; i < ranges.length; i++) {\n        range = ranges[i];\n        pos = range.getBoundingClientRect();\n        if (this.horizontal && this.direction === \"ltr\") {\n          left = pos.left;\n          right = pos.right;\n          if (left > end && prev) {\n            return prev;\n          } else if (right > end) {\n            return range;\n          }\n        } else if (this.horizontal && this.direction === \"rtl\") {\n          left = pos.left;\n          right = pos.right;\n          if (right < start && prev) {\n            return prev;\n          } else if (left < start) {\n            return range;\n          }\n        } else {\n          top = pos.top;\n          bottom = pos.bottom;\n          if (top > end && prev) {\n            return prev;\n          } else if (bottom > end) {\n            return range;\n          }\n        }\n        prev = range;\n      }\n\n      // Ends before limit\n      return ranges[ranges.length - 1];\n    }\n\n    /**\n     * Split up a text node into ranges for each word\n     * @private\n     * @param {Node} root root node\n     * @param {string} [_splitter] what to split on\n     * @return {Range[]}\n     */\n  }, {\n    key: \"splitTextNodeIntoRanges\",\n    value: function splitTextNodeIntoRanges(node, _splitter) {\n      var ranges = [];\n      var textContent = node.textContent || \"\";\n      var text = textContent.trim();\n      var range;\n      var doc = node.ownerDocument;\n      var splitter = _splitter || \" \";\n      var pos = text.indexOf(splitter);\n      if (pos === -1 || node.nodeType != Node.TEXT_NODE) {\n        range = doc.createRange();\n        range.selectNodeContents(node);\n        return [range];\n      }\n      range = doc.createRange();\n      range.setStart(node, 0);\n      range.setEnd(node, pos);\n      ranges.push(range);\n      range = false;\n      while (pos != -1) {\n        pos = text.indexOf(splitter, pos + 1);\n        if (pos > 0) {\n          if (range) {\n            range.setEnd(node, pos);\n            ranges.push(range);\n          }\n          range = doc.createRange();\n          range.setStart(node, pos + 1);\n        }\n      }\n      if (range) {\n        range.setEnd(node, text.length);\n        ranges.push(range);\n      }\n      return ranges;\n    }\n\n    /**\n     * Turn a pair of ranges into a pair of CFIs\n     * @private\n     * @param {string} cfiBase base string for an EpubCFI\n     * @param {object} rangePair { start: Range, end: Range }\n     * @return {object} { start: \"epubcfi(...)\", end: \"epubcfi(...)\" }\n     */\n  }, {\n    key: \"rangePairToCfiPair\",\n    value: function rangePairToCfiPair(cfiBase, rangePair) {\n      var startRange = rangePair.start;\n      var endRange = rangePair.end;\n      startRange.collapse(true);\n      endRange.collapse(false);\n      var startCfi = new EpubCFI(startRange, cfiBase).toString();\n      var endCfi = new EpubCFI(endRange, cfiBase).toString();\n      return {\n        start: startCfi,\n        end: endCfi\n      };\n    }\n  }, {\n    key: \"rangeListToCfiList\",\n    value: function rangeListToCfiList(cfiBase, columns) {\n      var map = [];\n      var cifPair;\n      for (var i = 0; i < columns.length; i++) {\n        cifPair = this.rangePairToCfiPair(cfiBase, columns[i]);\n        map.push(cifPair);\n      }\n      return map;\n    }\n\n    /**\n     * Set the axis for mapping\n     * @param {string} axis horizontal | vertical\n     * @return {boolean} is it horizontal?\n     */\n  }, {\n    key: \"axis\",\n    value: function axis(_axis) {\n      if (_axis) {\n        this.horizontal = _axis === \"horizontal\" ? true : false;\n      }\n      return this.horizontal;\n    }\n  }]);\n  return Mapping;\n}();\nexport default Mapping;","map":{"version":3,"names":["EpubCFI","nodeBounds","Mapping","layout","direction","axis","dev","horizontal","_dev","view","ranges","findRanges","map","rangeListToCfiList","section","cfiBase","contents","start","end","root","document","body","result","rangePairToCfiPair","findStart","findEnd","doc","startRange","toRange","endRange","selection","defaultView","getSelection","r","createRange","removeAllRanges","setStart","startContainer","startOffset","setEnd","endContainer","endOffset","addRange","func","nodeType","Node","TEXT_NODE","filter","acceptNode","node","data","trim","length","NodeFilter","FILTER_ACCEPT","FILTER_REJECT","safeFilter","treeWalker","createTreeWalker","SHOW_TEXT","nextNode","columns","scrollWidth","spreads","Math","ceil","spreadWidth","count","divisor","columnWidth","gap","i","pages","push","stack","$el","found","$prev","shift","walk","left","right","top","bottom","elPos","elRange","findTextStartRange","round","findTextEndRange","splitTextNodeIntoRanges","range","pos","getBoundingClientRect","prev","_splitter","textContent","text","ownerDocument","splitter","indexOf","selectNodeContents","rangePair","collapse","startCfi","toString","endCfi","cifPair"],"sources":["/home/parallels/Downloads/read/node_modules/epubjs/src/mapping.js"],"sourcesContent":["import EpubCFI from \"./epubcfi\";\nimport { nodeBounds } from \"./utils/core\";\n\n/**\n * Map text locations to CFI ranges\n * @class\n * @param {Layout} layout Layout to apply\n * @param {string} [direction=\"ltr\"] Text direction\n * @param {string} [axis=\"horizontal\"] vertical or horizontal axis\n * @param {boolean} [dev] toggle developer highlighting\n */\nclass Mapping {\n\tconstructor(layout, direction, axis, dev=false) {\n\t\tthis.layout = layout;\n\t\tthis.horizontal = (axis === \"horizontal\") ? true : false;\n\t\tthis.direction = direction || \"ltr\";\n\t\tthis._dev = dev;\n\t}\n\n\t/**\n\t * Find CFI pairs for entire section at once\n\t */\n\tsection(view) {\n\t\tvar ranges = this.findRanges(view);\n\t\tvar map = this.rangeListToCfiList(view.section.cfiBase, ranges);\n\n\t\treturn map;\n\t}\n\n\t/**\n\t * Find CFI pairs for a page\n\t * @param {Contents} contents Contents from view\n\t * @param {string} cfiBase string of the base for a cfi\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t */\n\tpage(contents, cfiBase, start, end) {\n\t\tvar root = contents && contents.document ? contents.document.body : false;\n\t\tvar result;\n\n\t\tif (!root) {\n\t\t\treturn;\n\t\t}\n\n\t\tresult = this.rangePairToCfiPair(cfiBase, {\n\t\t\tstart: this.findStart(root, start, end),\n\t\t\tend: this.findEnd(root, start, end)\n\t\t});\n\n\t\tif (this._dev === true) {\n\t\t\tlet doc = contents.document;\n\t\t\tlet startRange = new EpubCFI(result.start).toRange(doc);\n\t\t\tlet endRange = new EpubCFI(result.end).toRange(doc);\n\n\t\t\tlet selection = doc.defaultView.getSelection();\n\t\t\tlet r = doc.createRange();\n\t\t\tselection.removeAllRanges();\n\t\t\tr.setStart(startRange.startContainer, startRange.startOffset);\n\t\t\tr.setEnd(endRange.endContainer, endRange.endOffset);\n\t\t\tselection.addRange(r);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Walk a node, preforming a function on each node it finds\n\t * @private\n\t * @param {Node} root Node to walkToNode\n\t * @param {function} func walk function\n\t * @return {*} returns the result of the walk function\n\t */\n\twalk(root, func) {\n\t\t// IE11 has strange issue, if root is text node IE throws exception on\n\t\t// calling treeWalker.nextNode(), saying\n\t\t// Unexpected call to method or property access instead of returning null value\n\t\tif(root && root.nodeType === Node.TEXT_NODE) {\n\t\t\treturn;\n\t\t}\n\t\t// safeFilter is required so that it can work in IE as filter is a function for IE\n\t\t// and for other browser filter is an object.\n\t\tvar filter = {\n\t\t\tacceptNode: function(node) {\n\t\t\t\tif (node.data.trim().length > 0) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t} else {\n\t\t\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tvar safeFilter = filter.acceptNode;\n\t\tsafeFilter.acceptNode = filter.acceptNode;\n\n\t\tvar treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, safeFilter, false);\n\t\tvar node;\n\t\tvar result;\n\t\twhile ((node = treeWalker.nextNode())) {\n\t\t\tresult = func(node);\n\t\t\tif(result) break;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfindRanges(view){\n\t\tvar columns = [];\n\t\tvar scrollWidth = view.contents.scrollWidth();\n\t\tvar spreads = Math.ceil( scrollWidth / this.layout.spreadWidth);\n\t\tvar count = spreads * this.layout.divisor;\n\t\tvar columnWidth = this.layout.columnWidth;\n\t\tvar gap = this.layout.gap;\n\t\tvar start, end;\n\n\t\tfor (var i = 0; i < count.pages; i++) {\n\t\t\tstart = (columnWidth + gap) * i;\n\t\t\tend = (columnWidth * (i+1)) + (gap * i);\n\t\t\tcolumns.push({\n\t\t\t\tstart: this.findStart(view.document.body, start, end),\n\t\t\t\tend: this.findEnd(view.document.body, start, end)\n\t\t\t});\n\t\t}\n\n\t\treturn columns;\n\t}\n\n\t/**\n\t * Find Start Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindStart(root, start, end){\n\t\tvar stack = [root];\n\t\tvar $el;\n\t\tvar found;\n\t\tvar $prev = root;\n\n\t\twhile (stack.length) {\n\n\t\t\t$el = stack.shift();\n\n\t\t\tfound = this.walk($el, (node) => {\n\t\t\t\tvar left, right, top, bottom;\n\t\t\t\tvar elPos;\n\t\t\t\tvar elRange;\n\n\n\t\t\t\telPos = nodeBounds(node);\n\n\t\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\t\tleft = this.horizontal ? elPos.left : elPos.top;\n\t\t\t\t\tright = this.horizontal ? elPos.right : elPos.bottom;\n\n\t\t\t\t\tif( left >= start && left <= end ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else if (right > start) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\t\tleft = elPos.left;\n\t\t\t\t\tright = elPos.right;\n\n\t\t\t\t\tif( right <= end && right >= start ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else if (left < end) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttop = elPos.top;\n\t\t\t\t\tbottom = elPos.bottom;\n\n\t\t\t\t\tif( top >= start && top <= end ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else if (bottom > start) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t});\n\n\t\t\tif(found) {\n\t\t\t\treturn this.findTextStartRange(found, start, end);\n\t\t\t}\n\n\t\t}\n\n\t\t// Return last element\n\t\treturn this.findTextStartRange($prev, start, end);\n\t}\n\n\t/**\n\t * Find End Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindEnd(root, start, end){\n\t\tvar stack = [root];\n\t\tvar $el;\n\t\tvar $prev = root;\n\t\tvar found;\n\n\t\twhile (stack.length) {\n\n\t\t\t$el = stack.shift();\n\n\t\t\tfound = this.walk($el, (node) => {\n\n\t\t\t\tvar left, right, top, bottom;\n\t\t\t\tvar elPos;\n\t\t\t\tvar elRange;\n\n\t\t\t\telPos = nodeBounds(node);\n\n\t\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\t\tleft = Math.round(elPos.left);\n\t\t\t\t\tright = Math.round(elPos.right);\n\n\t\t\t\t\tif(left > end && $prev) {\n\t\t\t\t\t\treturn $prev;\n\t\t\t\t\t} else if(right > end) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\t\tleft = Math.round(this.horizontal ? elPos.left : elPos.top);\n\t\t\t\t\tright = Math.round(this.horizontal ? elPos.right : elPos.bottom);\n\n\t\t\t\t\tif(right < start && $prev) {\n\t\t\t\t\t\treturn $prev;\n\t\t\t\t\t} else if(left < start) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttop = Math.round(elPos.top);\n\t\t\t\t\tbottom = Math.round(elPos.bottom);\n\n\t\t\t\t\tif(top > end && $prev) {\n\t\t\t\t\t\treturn $prev;\n\t\t\t\t\t} else if(bottom > end) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t});\n\n\n\t\t\tif(found){\n\t\t\t\treturn this.findTextEndRange(found, start, end);\n\t\t\t}\n\n\t\t}\n\n\t\t// end of chapter\n\t\treturn this.findTextEndRange($prev, start, end);\n\t}\n\n\t/**\n\t * Find Text Start Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindTextStartRange(node, start, end){\n\t\tvar ranges = this.splitTextNodeIntoRanges(node);\n\t\tvar range;\n\t\tvar pos;\n\t\tvar left, top, right;\n\n\t\tfor (var i = 0; i < ranges.length; i++) {\n\t\t\trange = ranges[i];\n\n\t\t\tpos = range.getBoundingClientRect();\n\n\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\tleft = pos.left;\n\t\t\t\tif( left >= start ) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\tright = pos.right;\n\t\t\t\tif( right <= end ) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttop = pos.top;\n\t\t\t\tif( top >= start ) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// prev = range;\n\n\t\t}\n\n\t\treturn ranges[0];\n\t}\n\n\t/**\n\t * Find Text End Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindTextEndRange(node, start, end){\n\t\tvar ranges = this.splitTextNodeIntoRanges(node);\n\t\tvar prev;\n\t\tvar range;\n\t\tvar pos;\n\t\tvar left, right, top, bottom;\n\n\t\tfor (var i = 0; i < ranges.length; i++) {\n\t\t\trange = ranges[i];\n\n\t\t\tpos = range.getBoundingClientRect();\n\n\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\tleft = pos.left;\n\t\t\t\tright = pos.right;\n\n\t\t\t\tif(left > end && prev) {\n\t\t\t\t\treturn prev;\n\t\t\t\t} else if(right > end) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\tleft = pos.left\n\t\t\t\tright = pos.right;\n\n\t\t\t\tif(right < start && prev) {\n\t\t\t\t\treturn prev;\n\t\t\t\t} else if(left < start) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttop = pos.top;\n\t\t\t\tbottom = pos.bottom;\n\n\t\t\t\tif(top > end && prev) {\n\t\t\t\t\treturn prev;\n\t\t\t\t} else if(bottom > end) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tprev = range;\n\n\t\t}\n\n\t\t// Ends before limit\n\t\treturn ranges[ranges.length-1];\n\n\t}\n\n\t/**\n\t * Split up a text node into ranges for each word\n\t * @private\n\t * @param {Node} root root node\n\t * @param {string} [_splitter] what to split on\n\t * @return {Range[]}\n\t */\n\tsplitTextNodeIntoRanges(node, _splitter){\n\t\tvar ranges = [];\n\t\tvar textContent = node.textContent || \"\";\n\t\tvar text = textContent.trim();\n\t\tvar range;\n\t\tvar doc = node.ownerDocument;\n\t\tvar splitter = _splitter || \" \";\n\n\t\tvar pos = text.indexOf(splitter);\n\n\t\tif(pos === -1 || node.nodeType != Node.TEXT_NODE) {\n\t\t\trange = doc.createRange();\n\t\t\trange.selectNodeContents(node);\n\t\t\treturn [range];\n\t\t}\n\n\t\trange = doc.createRange();\n\t\trange.setStart(node, 0);\n\t\trange.setEnd(node, pos);\n\t\tranges.push(range);\n\t\trange = false;\n\n\t\twhile ( pos != -1 ) {\n\n\t\t\tpos = text.indexOf(splitter, pos + 1);\n\t\t\tif(pos > 0) {\n\n\t\t\t\tif(range) {\n\t\t\t\t\trange.setEnd(node, pos);\n\t\t\t\t\tranges.push(range);\n\t\t\t\t}\n\n\t\t\t\trange = doc.createRange();\n\t\t\t\trange.setStart(node, pos+1);\n\t\t\t}\n\t\t}\n\n\t\tif(range) {\n\t\t\trange.setEnd(node, text.length);\n\t\t\tranges.push(range);\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\n\t/**\n\t * Turn a pair of ranges into a pair of CFIs\n\t * @private\n\t * @param {string} cfiBase base string for an EpubCFI\n\t * @param {object} rangePair { start: Range, end: Range }\n\t * @return {object} { start: \"epubcfi(...)\", end: \"epubcfi(...)\" }\n\t */\n\trangePairToCfiPair(cfiBase, rangePair){\n\n\t\tvar startRange = rangePair.start;\n\t\tvar endRange = rangePair.end;\n\n\t\tstartRange.collapse(true);\n\t\tendRange.collapse(false);\n\n\t\tlet startCfi = new EpubCFI(startRange, cfiBase).toString();\n\t\tlet endCfi = new EpubCFI(endRange, cfiBase).toString();\n\n\t\treturn {\n\t\t\tstart: startCfi,\n\t\t\tend: endCfi\n\t\t};\n\n\t}\n\n\trangeListToCfiList(cfiBase, columns){\n\t\tvar map = [];\n\t\tvar cifPair;\n\n\t\tfor (var i = 0; i < columns.length; i++) {\n\t\t\tcifPair = this.rangePairToCfiPair(cfiBase, columns[i]);\n\n\t\t\tmap.push(cifPair);\n\n\t\t}\n\n\t\treturn map;\n\t}\n\n\t/**\n\t * Set the axis for mapping\n\t * @param {string} axis horizontal | vertical\n\t * @return {boolean} is it horizontal?\n\t */\n\taxis(axis) {\n\t\tif (axis) {\n\t\t\tthis.horizontal = (axis === \"horizontal\") ? true : false;\n\t\t}\n\t\treturn this.horizontal;\n\t}\n}\n\nexport default Mapping;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}