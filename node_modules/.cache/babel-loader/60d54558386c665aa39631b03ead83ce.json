{"ast":null,"code":"import { qs, qsa, querySelectorByType, filterChildren, getParentByTagName } from \"./utils/core\";\n\n/**\n * Navigation Parser\n * @param {document} xml navigation html / xhtml / ncx\n */\nclass Navigation {\n  constructor(xml) {\n    this.toc = [];\n    this.tocByHref = {};\n    this.tocById = {};\n    this.landmarks = [];\n    this.landmarksByType = {};\n    this.length = 0;\n    if (xml) {\n      this.parse(xml);\n    }\n  }\n\n  /**\n   * Parse out the navigation items\n   * @param {document} xml navigation html / xhtml / ncx\n   */\n  parse(xml) {\n    let isXml = xml.nodeType;\n    let html;\n    let ncx;\n    if (isXml) {\n      html = qs(xml, \"html\");\n      ncx = qs(xml, \"ncx\");\n    }\n    if (!isXml) {\n      this.toc = this.load(xml);\n    } else if (html) {\n      this.toc = this.parseNav(xml);\n      this.landmarks = this.parseLandmarks(xml);\n    } else if (ncx) {\n      this.toc = this.parseNcx(xml);\n    }\n    this.length = 0;\n    this.unpack(this.toc);\n  }\n\n  /**\n   * Unpack navigation items\n   * @private\n   * @param  {array} toc\n   */\n  unpack(toc) {\n    var item;\n    for (var i = 0; i < toc.length; i++) {\n      item = toc[i];\n      if (item.href) {\n        this.tocByHref[item.href] = i;\n      }\n      if (item.id) {\n        this.tocById[item.id] = i;\n      }\n      this.length++;\n      if (item.subitems.length) {\n        this.unpack(item.subitems);\n      }\n    }\n  }\n\n  /**\n   * Get an item from the navigation\n   * @param  {string} target\n   * @return {object} navItem\n   */\n  get(target) {\n    var index;\n    if (!target) {\n      return this.toc;\n    }\n    if (target.indexOf(\"#\") === 0) {\n      index = this.tocById[target.substring(1)];\n    } else if (target in this.tocByHref) {\n      index = this.tocByHref[target];\n    }\n    return this.getByIndex(target, index, this.toc);\n  }\n\n  /**\n   * Get an item from navigation subitems recursively by index\n   * @param  {string} target\n   * @param  {number} index\n   * @param  {array} navItems\n   * @return {object} navItem\n   */\n  getByIndex(target, index, navItems) {\n    if (navItems.length === 0) {\n      return;\n    }\n    const item = navItems[index];\n    if (item && (target === item.id || target === item.href)) {\n      return item;\n    } else {\n      let result;\n      for (let i = 0; i < navItems.length; ++i) {\n        result = this.getByIndex(target, index, navItems[i].subitems);\n        if (result) {\n          break;\n        }\n      }\n      return result;\n    }\n  }\n\n  /**\n   * Get a landmark by type\n   * List of types: https://idpf.github.io/epub-vocabs/structure/\n   * @param  {string} type\n   * @return {object} landmarkItem\n   */\n  landmark(type) {\n    var index;\n    if (!type) {\n      return this.landmarks;\n    }\n    index = this.landmarksByType[type];\n    return this.landmarks[index];\n  }\n\n  /**\n   * Parse toc from a Epub > 3.0 Nav\n   * @private\n   * @param  {document} navHtml\n   * @return {array} navigation list\n   */\n  parseNav(navHtml) {\n    var navElement = querySelectorByType(navHtml, \"nav\", \"toc\");\n    var list = [];\n    if (!navElement) return list;\n    let navList = filterChildren(navElement, \"ol\", true);\n    if (!navList) return list;\n    list = this.parseNavList(navList);\n    return list;\n  }\n\n  /**\n   * Parses lists in the toc\n   * @param  {document} navListHtml\n   * @param  {string} parent id\n   * @return {array} navigation list\n   */\n  parseNavList(navListHtml, parent) {\n    const result = [];\n    if (!navListHtml) return result;\n    if (!navListHtml.children) return result;\n    for (let i = 0; i < navListHtml.children.length; i++) {\n      const item = this.navItem(navListHtml.children[i], parent);\n      if (item) {\n        result.push(item);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Create a navItem\n   * @private\n   * @param  {element} item\n   * @return {object} navItem\n   */\n  navItem(item, parent) {\n    let id = item.getAttribute(\"id\") || undefined;\n    let content = filterChildren(item, \"a\", true) || filterChildren(item, \"span\", true);\n    if (!content) {\n      return;\n    }\n    let src = content.getAttribute(\"href\") || \"\";\n    if (!id) {\n      id = src;\n    }\n    let text = content.textContent || \"\";\n    let subitems = [];\n    let nested = filterChildren(item, \"ol\", true);\n    if (nested) {\n      subitems = this.parseNavList(nested, id);\n    }\n    return {\n      \"id\": id,\n      \"href\": src,\n      \"label\": text,\n      \"subitems\": subitems,\n      \"parent\": parent\n    };\n  }\n\n  /**\n   * Parse landmarks from a Epub > 3.0 Nav\n   * @private\n   * @param  {document} navHtml\n   * @return {array} landmarks list\n   */\n  parseLandmarks(navHtml) {\n    var navElement = querySelectorByType(navHtml, \"nav\", \"landmarks\");\n    var navItems = navElement ? qsa(navElement, \"li\") : [];\n    var length = navItems.length;\n    var i;\n    var list = [];\n    var item;\n    if (!navItems || length === 0) return list;\n    for (i = 0; i < length; ++i) {\n      item = this.landmarkItem(navItems[i]);\n      if (item) {\n        list.push(item);\n        this.landmarksByType[item.type] = i;\n      }\n    }\n    return list;\n  }\n\n  /**\n   * Create a landmarkItem\n   * @private\n   * @param  {element} item\n   * @return {object} landmarkItem\n   */\n  landmarkItem(item) {\n    let content = filterChildren(item, \"a\", true);\n    if (!content) {\n      return;\n    }\n    let type = content.getAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\") || undefined;\n    let href = content.getAttribute(\"href\") || \"\";\n    let text = content.textContent || \"\";\n    return {\n      \"href\": href,\n      \"label\": text,\n      \"type\": type\n    };\n  }\n\n  /**\n   * Parse from a Epub > 3.0 NC\n   * @private\n   * @param  {document} navHtml\n   * @return {array} navigation list\n   */\n  parseNcx(tocXml) {\n    var navPoints = qsa(tocXml, \"navPoint\");\n    var length = navPoints.length;\n    var i;\n    var toc = {};\n    var list = [];\n    var item, parent;\n    if (!navPoints || length === 0) return list;\n    for (i = 0; i < length; ++i) {\n      item = this.ncxItem(navPoints[i]);\n      toc[item.id] = item;\n      if (!item.parent) {\n        list.push(item);\n      } else {\n        parent = toc[item.parent];\n        parent.subitems.push(item);\n      }\n    }\n    return list;\n  }\n\n  /**\n   * Create a ncxItem\n   * @private\n   * @param  {element} item\n   * @return {object} ncxItem\n   */\n  ncxItem(item) {\n    var id = item.getAttribute(\"id\") || false,\n      content = qs(item, \"content\"),\n      src = content.getAttribute(\"src\"),\n      navLabel = qs(item, \"navLabel\"),\n      text = navLabel.textContent ? navLabel.textContent : \"\",\n      subitems = [],\n      parentNode = item.parentNode,\n      parent;\n    if (parentNode && (parentNode.nodeName === \"navPoint\" || parentNode.nodeName.split(':').slice(-1)[0] === \"navPoint\")) {\n      parent = parentNode.getAttribute(\"id\");\n    }\n    return {\n      \"id\": id,\n      \"href\": src,\n      \"label\": text,\n      \"subitems\": subitems,\n      \"parent\": parent\n    };\n  }\n\n  /**\n   * Load Spine Items\n   * @param  {object} json the items to be loaded\n   * @return {Array} navItems\n   */\n  load(json) {\n    return json.map(item => {\n      item.label = item.title;\n      item.subitems = item.children ? this.load(item.children) : [];\n      return item;\n    });\n  }\n\n  /**\n   * forEach pass through\n   * @param  {Function} fn function to run on each item\n   * @return {method} forEach loop\n   */\n  forEach(fn) {\n    return this.toc.forEach(fn);\n  }\n}\nexport default Navigation;","map":{"version":3,"names":["qs","qsa","querySelectorByType","filterChildren","getParentByTagName","Navigation","constructor","xml","toc","tocByHref","tocById","landmarks","landmarksByType","length","parse","isXml","nodeType","html","ncx","load","parseNav","parseLandmarks","parseNcx","unpack","item","i","href","id","subitems","get","target","index","indexOf","substring","getByIndex","navItems","result","landmark","type","navHtml","navElement","list","navList","parseNavList","navListHtml","parent","children","navItem","push","getAttribute","undefined","content","src","text","textContent","nested","landmarkItem","getAttributeNS","tocXml","navPoints","ncxItem","navLabel","parentNode","nodeName","split","slice","json","map","label","title","forEach","fn"],"sources":["/home/parallels/Downloads/react-epub-viewer-demo/node_modules/epubjs/src/navigation.js"],"sourcesContent":["import {qs, qsa, querySelectorByType, filterChildren, getParentByTagName} from \"./utils/core\";\n\n/**\n * Navigation Parser\n * @param {document} xml navigation html / xhtml / ncx\n */\nclass Navigation {\n\tconstructor(xml) {\n\t\tthis.toc = [];\n\t\tthis.tocByHref = {};\n\t\tthis.tocById = {};\n\n\t\tthis.landmarks = [];\n\t\tthis.landmarksByType = {};\n\n\t\tthis.length = 0;\n\t\tif (xml) {\n\t\t\tthis.parse(xml);\n\t\t}\n\t}\n\n\t/**\n\t * Parse out the navigation items\n\t * @param {document} xml navigation html / xhtml / ncx\n\t */\n\tparse(xml) {\n\t\tlet isXml = xml.nodeType;\n\t\tlet html;\n\t\tlet ncx;\n\n\t\tif (isXml) {\n\t\t\thtml = qs(xml, \"html\");\n\t\t\tncx = qs(xml, \"ncx\");\n\t\t}\n\n\t\tif (!isXml) {\n\t\t\tthis.toc = this.load(xml);\n\t\t} else if(html) {\n\t\t\tthis.toc = this.parseNav(xml);\n\t\t\tthis.landmarks = this.parseLandmarks(xml);\n\t\t} else if(ncx){\n\t\t\tthis.toc = this.parseNcx(xml);\n\t\t}\n\n\t\tthis.length = 0;\n\n\t\tthis.unpack(this.toc);\n\t}\n\n\t/**\n\t * Unpack navigation items\n\t * @private\n\t * @param  {array} toc\n\t */\n\tunpack(toc) {\n\t\tvar item;\n\n\t\tfor (var i = 0; i < toc.length; i++) {\n\t\t\titem = toc[i];\n\n\t\t\tif (item.href) {\n\t\t\t\tthis.tocByHref[item.href] = i;\n\t\t\t}\n\n\t\t\tif (item.id) {\n\t\t\t\tthis.tocById[item.id] = i;\n\t\t\t}\n\n\t\t\tthis.length++;\n\n\t\t\tif (item.subitems.length) {\n\t\t\t\tthis.unpack(item.subitems);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Get an item from the navigation\n\t * @param  {string} target\n\t * @return {object} navItem\n\t */\n\tget(target) {\n\t\tvar index;\n\n\t\tif(!target) {\n\t\t\treturn this.toc;\n\t\t}\n\n\t\tif(target.indexOf(\"#\") === 0) {\n\t\t\tindex = this.tocById[target.substring(1)];\n\t\t} else if(target in this.tocByHref){\n\t\t\tindex = this.tocByHref[target];\n\t\t}\n\n\t\treturn this.getByIndex(target, index, this.toc);\n\t}\n\n\t/**\n\t * Get an item from navigation subitems recursively by index\n\t * @param  {string} target\n\t * @param  {number} index\n\t * @param  {array} navItems\n\t * @return {object} navItem\n\t */\n\tgetByIndex(target, index, navItems) {\n\t\tif (navItems.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst item = navItems[index];\n\t\tif (item && (target === item.id || target === item.href)) {\n\t\t\treturn item;\n\t\t} else {\n\t\t\tlet result;\n\t\t\tfor (let i = 0; i < navItems.length; ++i) {\n\t\t\t\tresult = this.getByIndex(target, index, navItems[i].subitems);\n\t\t\t\tif (result) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Get a landmark by type\n\t * List of types: https://idpf.github.io/epub-vocabs/structure/\n\t * @param  {string} type\n\t * @return {object} landmarkItem\n\t */\n\tlandmark(type) {\n\t\tvar index;\n\n\t\tif(!type) {\n\t\t\treturn this.landmarks;\n\t\t}\n\n\t\tindex = this.landmarksByType[type];\n\n\t\treturn this.landmarks[index];\n\t}\n\n\t/**\n\t * Parse toc from a Epub > 3.0 Nav\n\t * @private\n\t * @param  {document} navHtml\n\t * @return {array} navigation list\n\t */\n\tparseNav(navHtml){\n\t\tvar navElement = querySelectorByType(navHtml, \"nav\", \"toc\");\n\t\tvar list = [];\n\n\t\tif (!navElement) return list;\n\n\t\tlet navList = filterChildren(navElement, \"ol\", true);\n\t\tif (!navList) return list;\n\n\t\tlist = this.parseNavList(navList);\n\t\treturn list;\n\t}\n\n\t/**\n\t * Parses lists in the toc\n\t * @param  {document} navListHtml\n\t * @param  {string} parent id\n\t * @return {array} navigation list\n\t */\n\tparseNavList(navListHtml, parent) {\n\t\tconst result = [];\n\n\t\tif (!navListHtml) return result;\n\t\tif (!navListHtml.children) return result;\n\t\t\n\t\tfor (let i = 0; i < navListHtml.children.length; i++) {\n\t\t\tconst item = this.navItem(navListHtml.children[i], parent);\n\n\t\t\tif (item) {\n\t\t\t\tresult.push(item);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Create a navItem\n\t * @private\n\t * @param  {element} item\n\t * @return {object} navItem\n\t */\n\tnavItem(item, parent) {\n\t\tlet id = item.getAttribute(\"id\") || undefined;\n\t\tlet content = filterChildren(item, \"a\", true)\n\t\t\t|| filterChildren(item, \"span\", true);\n\n\t\tif (!content) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet src = content.getAttribute(\"href\") || \"\";\n\t\t\n\t\tif (!id) {\n\t\t\tid = src;\n\t\t}\n\t\tlet text = content.textContent || \"\";\n\n\t\tlet subitems = [];\n\t\tlet nested = filterChildren(item, \"ol\", true);\n\t\tif (nested) {\n\t\t\tsubitems = \tthis.parseNavList(nested, id);\n\t\t}\n\n\t\treturn {\n\t\t\t\"id\": id,\n\t\t\t\"href\": src,\n\t\t\t\"label\": text,\n\t\t\t\"subitems\" : subitems,\n\t\t\t\"parent\" : parent\n\t\t};\n\t}\n\n\t/**\n\t * Parse landmarks from a Epub > 3.0 Nav\n\t * @private\n\t * @param  {document} navHtml\n\t * @return {array} landmarks list\n\t */\n\tparseLandmarks(navHtml){\n\t\tvar navElement = querySelectorByType(navHtml, \"nav\", \"landmarks\");\n\t\tvar navItems = navElement ? qsa(navElement, \"li\") : [];\n\t\tvar length = navItems.length;\n\t\tvar i;\n\t\tvar list = [];\n\t\tvar item;\n\n\t\tif(!navItems || length === 0) return list;\n\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\titem = this.landmarkItem(navItems[i]);\n\t\t\tif (item) {\n\t\t\t\tlist.push(item);\n\t\t\t\tthis.landmarksByType[item.type] = i;\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}\n\n\t/**\n\t * Create a landmarkItem\n\t * @private\n\t * @param  {element} item\n\t * @return {object} landmarkItem\n\t */\n\tlandmarkItem(item){\n\t\tlet content = filterChildren(item, \"a\", true);\n\n\t\tif (!content) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet type = content.getAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\") || undefined;\n\t\tlet href = content.getAttribute(\"href\") || \"\";\n\t\tlet text = content.textContent || \"\";\n\n\t\treturn {\n\t\t\t\"href\": href,\n\t\t\t\"label\": text,\n\t\t\t\"type\" : type\n\t\t};\n\t}\n\n\t/**\n\t * Parse from a Epub > 3.0 NC\n\t * @private\n\t * @param  {document} navHtml\n\t * @return {array} navigation list\n\t */\n\tparseNcx(tocXml){\n\t\tvar navPoints = qsa(tocXml, \"navPoint\");\n\t\tvar length = navPoints.length;\n\t\tvar i;\n\t\tvar toc = {};\n\t\tvar list = [];\n\t\tvar item, parent;\n\n\t\tif(!navPoints || length === 0) return list;\n\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\titem = this.ncxItem(navPoints[i]);\n\t\t\ttoc[item.id] = item;\n\t\t\tif(!item.parent) {\n\t\t\t\tlist.push(item);\n\t\t\t} else {\n\t\t\t\tparent = toc[item.parent];\n\t\t\t\tparent.subitems.push(item);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}\n\n\t/**\n\t * Create a ncxItem\n\t * @private\n\t * @param  {element} item\n\t * @return {object} ncxItem\n\t */\n\tncxItem(item){\n\t\tvar id = item.getAttribute(\"id\") || false,\n\t\t\t\tcontent = qs(item, \"content\"),\n\t\t\t\tsrc = content.getAttribute(\"src\"),\n\t\t\t\tnavLabel = qs(item, \"navLabel\"),\n\t\t\t\ttext = navLabel.textContent ? navLabel.textContent : \"\",\n\t\t\t\tsubitems = [],\n\t\t\t\tparentNode = item.parentNode,\n\t\t\t\tparent;\n\n\t\tif(parentNode && (parentNode.nodeName === \"navPoint\" || parentNode.nodeName.split(':').slice(-1)[0] === \"navPoint\")) {\n\t\t\tparent = parentNode.getAttribute(\"id\");\n\t\t}\n\n\n\t\treturn {\n\t\t\t\"id\": id,\n\t\t\t\"href\": src,\n\t\t\t\"label\": text,\n\t\t\t\"subitems\" : subitems,\n\t\t\t\"parent\" : parent\n\t\t};\n\t}\n\n\t/**\n\t * Load Spine Items\n\t * @param  {object} json the items to be loaded\n\t * @return {Array} navItems\n\t */\n\tload(json) {\n\t\treturn json.map(item => {\n\t\t\titem.label = item.title;\n\t\t\titem.subitems = item.children ? this.load(item.children) : [];\n\t\t\treturn item;\n\t\t});\n\t}\n\n\t/**\n\t * forEach pass through\n\t * @param  {Function} fn function to run on each item\n\t * @return {method} forEach loop\n\t */\n\tforEach(fn) {\n\t\treturn this.toc.forEach(fn);\n\t}\n}\n\nexport default Navigation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}