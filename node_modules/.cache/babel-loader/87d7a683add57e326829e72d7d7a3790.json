{"ast":null,"code":"import Path from \"./path\";\nimport path from \"path-webpack\";\n\n/**\n * creates a Url object for parsing and manipulation of a url string\n * @param\t{string} urlString\ta url string (relative or absolute)\n * @param\t{string} [baseString] optional base for the url,\n * default to window.location.href\n */\nclass Url {\n  constructor(urlString, baseString) {\n    var absolute = urlString.indexOf(\"://\") > -1;\n    var pathname = urlString;\n    var basePath;\n    this.Url = undefined;\n    this.href = urlString;\n    this.protocol = \"\";\n    this.origin = \"\";\n    this.hash = \"\";\n    this.hash = \"\";\n    this.search = \"\";\n    this.base = baseString;\n    if (!absolute && baseString !== false && typeof baseString !== \"string\" && window && window.location) {\n      this.base = window.location.href;\n    }\n\n    // URL Polyfill doesn't throw an error if base is empty\n    if (absolute || this.base) {\n      try {\n        if (this.base) {\n          // Safari doesn't like an undefined base\n          this.Url = new URL(urlString, this.base);\n        } else {\n          this.Url = new URL(urlString);\n        }\n        this.href = this.Url.href;\n        this.protocol = this.Url.protocol;\n        this.origin = this.Url.origin;\n        this.hash = this.Url.hash;\n        this.search = this.Url.search;\n        pathname = this.Url.pathname + (this.Url.search ? this.Url.search : '');\n      } catch (e) {\n        // Skip URL parsing\n        this.Url = undefined;\n        // resolve the pathname from the base\n        if (this.base) {\n          basePath = new Path(this.base);\n          pathname = basePath.resolve(pathname);\n        }\n      }\n    }\n    this.Path = new Path(pathname);\n    this.directory = this.Path.directory;\n    this.filename = this.Path.filename;\n    this.extension = this.Path.extension;\n  }\n\n  /**\n   * @returns {Path}\n   */\n  path() {\n    return this.Path;\n  }\n\n  /**\n   * Resolves a relative path to a absolute url\n   * @param {string} what\n   * @returns {string} url\n   */\n  resolve(what) {\n    var isAbsolute = what.indexOf(\"://\") > -1;\n    var fullpath;\n    if (isAbsolute) {\n      return what;\n    }\n    fullpath = path.resolve(this.directory, what);\n    return this.origin + fullpath;\n  }\n\n  /**\n   * Resolve a path relative to the url\n   * @param {string} what\n   * @returns {string} path\n   */\n  relative(what) {\n    return path.relative(what, this.directory);\n  }\n\n  /**\n   * @returns {string}\n   */\n  toString() {\n    return this.href;\n  }\n}\nexport default Url;","map":{"version":3,"names":["Path","path","Url","constructor","urlString","baseString","absolute","indexOf","pathname","basePath","undefined","href","protocol","origin","hash","search","base","window","location","URL","e","resolve","directory","filename","extension","what","isAbsolute","fullpath","relative","toString"],"sources":["/home/parallels/Downloads/react-epub-viewer-demo/node_modules/epubjs/src/utils/url.js"],"sourcesContent":["import Path from \"./path\";\nimport path from \"path-webpack\";\n\n/**\n * creates a Url object for parsing and manipulation of a url string\n * @param\t{string} urlString\ta url string (relative or absolute)\n * @param\t{string} [baseString] optional base for the url,\n * default to window.location.href\n */\nclass Url {\n\tconstructor(urlString, baseString) {\n\t\tvar absolute = (urlString.indexOf(\"://\") > -1);\n\t\tvar pathname = urlString;\n\t\tvar basePath;\n\n\t\tthis.Url = undefined;\n\t\tthis.href = urlString;\n\t\tthis.protocol = \"\";\n\t\tthis.origin = \"\";\n\t\tthis.hash = \"\";\n\t\tthis.hash = \"\";\n\t\tthis.search = \"\";\n\t\tthis.base = baseString;\n\n\t\tif (!absolute &&\n\t\t\t\tbaseString !== false &&\n\t\t\t\ttypeof(baseString) !== \"string\" &&\n\t\t\t\twindow && window.location) {\n\t\t\tthis.base = window.location.href;\n\t\t}\n\n\t\t// URL Polyfill doesn't throw an error if base is empty\n\t\tif (absolute || this.base) {\n\t\t\ttry {\n\t\t\t\tif (this.base) { // Safari doesn't like an undefined base\n\t\t\t\t\tthis.Url = new URL(urlString, this.base);\n\t\t\t\t} else {\n\t\t\t\t\tthis.Url = new URL(urlString);\n\t\t\t\t}\n\t\t\t\tthis.href = this.Url.href;\n\n\t\t\t\tthis.protocol = this.Url.protocol;\n\t\t\t\tthis.origin = this.Url.origin;\n\t\t\t\tthis.hash = this.Url.hash;\n\t\t\t\tthis.search = this.Url.search;\n\n\t\t\t\tpathname = this.Url.pathname + (this.Url.search ? this.Url.search : '');\n\t\t\t} catch (e) {\n\t\t\t\t// Skip URL parsing\n\t\t\t\tthis.Url = undefined;\n\t\t\t\t// resolve the pathname from the base\n\t\t\t\tif (this.base) {\n\t\t\t\t\tbasePath = new Path(this.base);\n\t\t\t\t\tpathname = basePath.resolve(pathname);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.Path = new Path(pathname);\n\n\t\tthis.directory = this.Path.directory;\n\t\tthis.filename = this.Path.filename;\n\t\tthis.extension = this.Path.extension;\n\n\t}\n\n\t/**\n\t * @returns {Path}\n\t */\n\tpath () {\n\t\treturn this.Path;\n\t}\n\n\t/**\n\t * Resolves a relative path to a absolute url\n\t * @param {string} what\n\t * @returns {string} url\n\t */\n\tresolve (what) {\n\t\tvar isAbsolute = (what.indexOf(\"://\") > -1);\n\t\tvar fullpath;\n\n\t\tif (isAbsolute) {\n\t\t\treturn what;\n\t\t}\n\n\t\tfullpath = path.resolve(this.directory, what);\n\t\treturn this.origin + fullpath;\n\t}\n\n\t/**\n\t * Resolve a path relative to the url\n\t * @param {string} what\n\t * @returns {string} path\n\t */\n\trelative (what) {\n\t\treturn path.relative(what, this.directory);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString () {\n\t\treturn this.href;\n\t}\n}\n\nexport default Url;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}