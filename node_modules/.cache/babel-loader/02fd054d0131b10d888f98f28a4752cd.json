{"ast":null,"code":"import _classCallCheck from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/parallels/Downloads/read/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { qs, sprint, locationOf, defer } from \"./utils/core\";\nimport Queue from \"./utils/queue\";\nimport EpubCFI from \"./epubcfi\";\nimport { EVENTS } from \"./utils/constants\";\nimport EventEmitter from \"event-emitter\";\n\n/**\n * Find Locations for a Book\n * @param {Spine} spine\n * @param {request} request\n * @param {number} [pause=100]\n */\nvar Locations = /*#__PURE__*/function () {\n  function Locations(spine, request, pause) {\n    _classCallCheck(this, Locations);\n    this.spine = spine;\n    this.request = request;\n    this.pause = pause || 100;\n    this.q = new Queue(this);\n    this.epubcfi = new EpubCFI();\n    this._locations = [];\n    this._locationsWords = [];\n    this.total = 0;\n    this.break = 150;\n    this._current = 0;\n    this._wordCounter = 0;\n    this.currentLocation = '';\n    this._currentCfi = '';\n    this.processingTimeout = undefined;\n  }\n\n  /**\n   * Load all of sections in the book to generate locations\n   * @param  {int} chars how many chars to split on\n   * @return {Promise<Array<string>>} locations\n   */\n  _createClass(Locations, [{\n    key: \"generate\",\n    value: function generate(chars) {\n      if (chars) {\n        this.break = chars;\n      }\n      this.q.pause();\n      this.spine.each(function (section) {\n        if (section.linear) {\n          this.q.enqueue(this.process.bind(this), section);\n        }\n      }.bind(this));\n      return this.q.run().then(function () {\n        this.total = this._locations.length - 1;\n        if (this._currentCfi) {\n          this.currentLocation = this._currentCfi;\n        }\n        return this._locations;\n        // console.log(this.percentage(this.book.rendition.location.start), this.percentage(this.book.rendition.location.end));\n      }.bind(this));\n    }\n  }, {\n    key: \"createRange\",\n    value: function createRange() {\n      return {\n        startContainer: undefined,\n        startOffset: undefined,\n        endContainer: undefined,\n        endOffset: undefined\n      };\n    }\n  }, {\n    key: \"process\",\n    value: function process(section) {\n      return section.load(this.request).then(function (contents) {\n        var completed = new defer();\n        var locations = this.parse(contents, section.cfiBase);\n        this._locations = this._locations.concat(locations);\n        section.unload();\n        this.processingTimeout = setTimeout(function () {\n          return completed.resolve(locations);\n        }, this.pause);\n        return completed.promise;\n      }.bind(this));\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(contents, cfiBase, chars) {\n      var locations = [];\n      var range;\n      var doc = contents.ownerDocument;\n      var body = qs(doc, \"body\");\n      var counter = 0;\n      var prev;\n      var _break = chars || this.break;\n      var parser = function parser(node) {\n        var len = node.length;\n        var dist;\n        var pos = 0;\n        if (node.textContent.trim().length === 0) {\n          return false; // continue\n        }\n\n        // Start range\n        if (counter == 0) {\n          range = this.createRange();\n          range.startContainer = node;\n          range.startOffset = 0;\n        }\n        dist = _break - counter;\n\n        // Node is smaller than a break,\n        // skip over it\n        if (dist > len) {\n          counter += len;\n          pos = len;\n        }\n        while (pos < len) {\n          dist = _break - counter;\n          if (counter === 0) {\n            // Start new range\n            pos += 1;\n            range = this.createRange();\n            range.startContainer = node;\n            range.startOffset = pos;\n          }\n\n          // pos += dist;\n\n          // Gone over\n          if (pos + dist >= len) {\n            // Continue counter for next node\n            counter += len - pos;\n            // break\n            pos = len;\n            // At End\n          } else {\n            // Advance pos\n            pos += dist;\n\n            // End the previous range\n            range.endContainer = node;\n            range.endOffset = pos;\n            // cfi = section.cfiFromRange(range);\n            var cfi = new EpubCFI(range, cfiBase).toString();\n            locations.push(cfi);\n            counter = 0;\n          }\n        }\n        prev = node;\n      };\n      sprint(body, parser.bind(this));\n\n      // Close remaining\n      if (range && range.startContainer && prev) {\n        range.endContainer = prev;\n        range.endOffset = prev.length;\n        var cfi = new EpubCFI(range, cfiBase).toString();\n        locations.push(cfi);\n        counter = 0;\n      }\n      return locations;\n    }\n\n    /**\n     * Load all of sections in the book to generate locations\n     * @param  {string} startCfi start position\n     * @param  {int} wordCount how many words to split on\n     * @param  {int} count result count\n     * @return {object} locations\n     */\n  }, {\n    key: \"generateFromWords\",\n    value: function generateFromWords(startCfi, wordCount, count) {\n      var start = startCfi ? new EpubCFI(startCfi) : undefined;\n      this.q.pause();\n      this._locationsWords = [];\n      this._wordCounter = 0;\n      this.spine.each(function (section) {\n        if (section.linear) {\n          if (start) {\n            if (section.index >= start.spinePos) {\n              this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n            }\n          } else {\n            this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n          }\n        }\n      }.bind(this));\n      return this.q.run().then(function () {\n        if (this._currentCfi) {\n          this.currentLocation = this._currentCfi;\n        }\n        return this._locationsWords;\n      }.bind(this));\n    }\n  }, {\n    key: \"processWords\",\n    value: function processWords(section, wordCount, startCfi, count) {\n      if (count && this._locationsWords.length >= count) {\n        return Promise.resolve();\n      }\n      return section.load(this.request).then(function (contents) {\n        var completed = new defer();\n        var locations = this.parseWords(contents, section, wordCount, startCfi);\n        var remainingCount = count - this._locationsWords.length;\n        this._locationsWords = this._locationsWords.concat(locations.length >= count ? locations.slice(0, remainingCount) : locations);\n        section.unload();\n        this.processingTimeout = setTimeout(function () {\n          return completed.resolve(locations);\n        }, this.pause);\n        return completed.promise;\n      }.bind(this));\n    }\n\n    //http://stackoverflow.com/questions/18679576/counting-words-in-string\n  }, {\n    key: \"countWords\",\n    value: function countWords(s) {\n      s = s.replace(/(^\\s*)|(\\s*$)/gi, \"\"); //exclude  start and end white-space\n      s = s.replace(/[ ]{2,}/gi, \" \"); //2 or more space to 1\n      s = s.replace(/\\n /, \"\\n\"); // exclude newline with a start spacing\n      return s.split(\" \").length;\n    }\n  }, {\n    key: \"parseWords\",\n    value: function parseWords(contents, section, wordCount, startCfi) {\n      var cfiBase = section.cfiBase;\n      var locations = [];\n      var doc = contents.ownerDocument;\n      var body = qs(doc, \"body\");\n      var prev;\n      var _break = wordCount;\n      var foundStartNode = startCfi ? startCfi.spinePos !== section.index : true;\n      var startNode;\n      if (startCfi && section.index === startCfi.spinePos) {\n        startNode = startCfi.findNode(startCfi.range ? startCfi.path.steps.concat(startCfi.start.steps) : startCfi.path.steps, contents.ownerDocument);\n      }\n      var parser = function parser(node) {\n        if (!foundStartNode) {\n          if (node === startNode) {\n            foundStartNode = true;\n          } else {\n            return false;\n          }\n        }\n        if (node.textContent.length < 10) {\n          if (node.textContent.trim().length === 0) {\n            return false;\n          }\n        }\n        var len = this.countWords(node.textContent);\n        var dist;\n        var pos = 0;\n        if (len === 0) {\n          return false; // continue\n        }\n\n        dist = _break - this._wordCounter;\n\n        // Node is smaller than a break,\n        // skip over it\n        if (dist > len) {\n          this._wordCounter += len;\n          pos = len;\n        }\n        while (pos < len) {\n          dist = _break - this._wordCounter;\n\n          // Gone over\n          if (pos + dist >= len) {\n            // Continue counter for next node\n            this._wordCounter += len - pos;\n            // break\n            pos = len;\n            // At End\n          } else {\n            // Advance pos\n            pos += dist;\n            var cfi = new EpubCFI(node, cfiBase);\n            locations.push({\n              cfi: cfi.toString(),\n              wordCount: this._wordCounter\n            });\n            this._wordCounter = 0;\n          }\n        }\n        prev = node;\n      };\n      sprint(body, parser.bind(this));\n      return locations;\n    }\n\n    /**\n     * Get a location from an EpubCFI\n     * @param {EpubCFI} cfi\n     * @return {number}\n     */\n  }, {\n    key: \"locationFromCfi\",\n    value: function locationFromCfi(cfi) {\n      var loc;\n      if (EpubCFI.prototype.isCfiString(cfi)) {\n        cfi = new EpubCFI(cfi);\n      }\n      // Check if the location has not been set yet\n      if (this._locations.length === 0) {\n        return -1;\n      }\n      loc = locationOf(cfi, this._locations, this.epubcfi.compare);\n      if (loc > this.total) {\n        return this.total;\n      }\n      return loc;\n    }\n\n    /**\n     * Get a percentage position in locations from an EpubCFI\n     * @param {EpubCFI} cfi\n     * @return {number}\n     */\n  }, {\n    key: \"percentageFromCfi\",\n    value: function percentageFromCfi(cfi) {\n      if (this._locations.length === 0) {\n        return null;\n      }\n      // Find closest cfi\n      var loc = this.locationFromCfi(cfi);\n      // Get percentage in total\n      return this.percentageFromLocation(loc);\n    }\n\n    /**\n     * Get a percentage position from a location index\n     * @param {number} location\n     * @return {number}\n     */\n  }, {\n    key: \"percentageFromLocation\",\n    value: function percentageFromLocation(loc) {\n      if (!loc || !this.total) {\n        return 0;\n      }\n      return loc / this.total;\n    }\n\n    /**\n     * Get an EpubCFI from location index\n     * @param {number} loc\n     * @return {EpubCFI} cfi\n     */\n  }, {\n    key: \"cfiFromLocation\",\n    value: function cfiFromLocation(loc) {\n      var cfi = -1;\n      // check that pg is an int\n      if (typeof loc != \"number\") {\n        loc = parseInt(loc);\n      }\n      if (loc >= 0 && loc < this._locations.length) {\n        cfi = this._locations[loc];\n      }\n      return cfi;\n    }\n\n    /**\n     * Get an EpubCFI from location percentage\n     * @param {number} percentage\n     * @return {EpubCFI} cfi\n     */\n  }, {\n    key: \"cfiFromPercentage\",\n    value: function cfiFromPercentage(percentage) {\n      var loc;\n      if (percentage > 1) {\n        console.warn(\"Normalize cfiFromPercentage value to between 0 - 1\");\n      }\n\n      // Make sure 1 goes to very end\n      if (percentage >= 1) {\n        var cfi = new EpubCFI(this._locations[this.total]);\n        cfi.collapse();\n        return cfi.toString();\n      }\n      loc = Math.ceil(this.total * percentage);\n      return this.cfiFromLocation(loc);\n    }\n\n    /**\n     * Load locations from JSON\n     * @param {json} locations\n     */\n  }, {\n    key: \"load\",\n    value: function load(locations) {\n      if (typeof locations === \"string\") {\n        this._locations = JSON.parse(locations);\n      } else {\n        this._locations = locations;\n      }\n      this.total = this._locations.length - 1;\n      return this._locations;\n    }\n\n    /**\n     * Save locations to JSON\n     * @return {json}\n     */\n  }, {\n    key: \"save\",\n    value: function save() {\n      return JSON.stringify(this._locations);\n    }\n  }, {\n    key: \"getCurrent\",\n    value: function getCurrent() {\n      return this._current;\n    }\n  }, {\n    key: \"setCurrent\",\n    value: function setCurrent(curr) {\n      var loc;\n      if (typeof curr == \"string\") {\n        this._currentCfi = curr;\n      } else if (typeof curr == \"number\") {\n        this._current = curr;\n      } else {\n        return;\n      }\n      if (this._locations.length === 0) {\n        return;\n      }\n      if (typeof curr == \"string\") {\n        loc = this.locationFromCfi(curr);\n        this._current = loc;\n      } else {\n        loc = curr;\n      }\n      this.emit(EVENTS.LOCATIONS.CHANGED, {\n        percentage: this.percentageFromLocation(loc)\n      });\n    }\n\n    /**\n     * Get the current location\n     */\n  }, {\n    key: \"currentLocation\",\n    get: function get() {\n      return this._current;\n    }\n\n    /**\n     * Set the current location\n     */,\n    set: function set(curr) {\n      this.setCurrent(curr);\n    }\n\n    /**\n     * Locations length\n     */\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this._locations.length;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.spine = undefined;\n      this.request = undefined;\n      this.pause = undefined;\n      this.q.stop();\n      this.q = undefined;\n      this.epubcfi = undefined;\n      this._locations = undefined;\n      this.total = undefined;\n      this.break = undefined;\n      this._current = undefined;\n      this.currentLocation = undefined;\n      this._currentCfi = undefined;\n      clearTimeout(this.processingTimeout);\n    }\n  }]);\n  return Locations;\n}();\nEventEmitter(Locations.prototype);\nexport default Locations;","map":{"version":3,"names":["qs","sprint","locationOf","defer","Queue","EpubCFI","EVENTS","EventEmitter","Locations","spine","request","pause","q","epubcfi","_locations","_locationsWords","total","break","_current","_wordCounter","currentLocation","_currentCfi","processingTimeout","undefined","chars","each","section","linear","enqueue","process","bind","run","then","length","startContainer","startOffset","endContainer","endOffset","load","contents","completed","locations","parse","cfiBase","concat","unload","setTimeout","resolve","promise","range","doc","ownerDocument","body","counter","prev","_break","parser","node","len","dist","pos","textContent","trim","createRange","cfi","toString","push","startCfi","wordCount","count","start","index","spinePos","processWords","Promise","parseWords","remainingCount","slice","s","replace","split","foundStartNode","startNode","findNode","path","steps","countWords","loc","prototype","isCfiString","compare","locationFromCfi","percentageFromLocation","parseInt","percentage","console","warn","collapse","Math","ceil","cfiFromLocation","JSON","stringify","curr","emit","LOCATIONS","CHANGED","setCurrent","stop","clearTimeout"],"sources":["/home/parallels/Downloads/read/node_modules/epubjs/src/locations.js"],"sourcesContent":["import {qs, sprint, locationOf, defer} from \"./utils/core\";\nimport Queue from \"./utils/queue\";\nimport EpubCFI from \"./epubcfi\";\nimport { EVENTS } from \"./utils/constants\";\nimport EventEmitter from \"event-emitter\";\n\n/**\n * Find Locations for a Book\n * @param {Spine} spine\n * @param {request} request\n * @param {number} [pause=100]\n */\nclass Locations {\n\tconstructor(spine, request, pause) {\n\t\tthis.spine = spine;\n\t\tthis.request = request;\n\t\tthis.pause = pause || 100;\n\n\t\tthis.q = new Queue(this);\n\t\tthis.epubcfi = new EpubCFI();\n\n\t\tthis._locations = [];\n\t\tthis._locationsWords = [];\n\t\tthis.total = 0;\n\n\t\tthis.break = 150;\n\n\t\tthis._current = 0;\n\n\t\tthis._wordCounter = 0;\n\n\t\tthis.currentLocation = '';\n\t\tthis._currentCfi ='';\n\t\tthis.processingTimeout = undefined;\n\t}\n\n\t/**\n\t * Load all of sections in the book to generate locations\n\t * @param  {int} chars how many chars to split on\n\t * @return {Promise<Array<string>>} locations\n\t */\n\tgenerate(chars) {\n\n\t\tif (chars) {\n\t\t\tthis.break = chars;\n\t\t}\n\n\t\tthis.q.pause();\n\n\t\tthis.spine.each(function(section) {\n\t\t\tif (section.linear) {\n\t\t\t\tthis.q.enqueue(this.process.bind(this), section);\n\t\t\t}\n\t\t}.bind(this));\n\n\t\treturn this.q.run().then(function() {\n\t\t\tthis.total = this._locations.length - 1;\n\n\t\t\tif (this._currentCfi) {\n\t\t\t\tthis.currentLocation = this._currentCfi;\n\t\t\t}\n\n\t\t\treturn this._locations;\n\t\t\t// console.log(this.percentage(this.book.rendition.location.start), this.percentage(this.book.rendition.location.end));\n\t\t}.bind(this));\n\n\t}\n\n\tcreateRange () {\n\t\treturn {\n\t\t\tstartContainer: undefined,\n\t\t\tstartOffset: undefined,\n\t\t\tendContainer: undefined,\n\t\t\tendOffset: undefined\n\t\t};\n\t}\n\n\tprocess(section) {\n\n\t\treturn section.load(this.request)\n\t\t\t.then(function(contents) {\n\t\t\t\tvar completed = new defer();\n\t\t\t\tvar locations = this.parse(contents, section.cfiBase);\n\t\t\t\tthis._locations = this._locations.concat(locations);\n\n\t\t\t\tsection.unload();\n\n\t\t\t\tthis.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);\n\t\t\t\treturn completed.promise;\n\t\t\t}.bind(this));\n\n\t}\n\n\tparse(contents, cfiBase, chars) {\n\t\tvar locations = [];\n\t\tvar range;\n\t\tvar doc = contents.ownerDocument;\n\t\tvar body = qs(doc, \"body\");\n\t\tvar counter = 0;\n\t\tvar prev;\n\t\tvar _break = chars || this.break;\n\t\tvar parser = function(node) {\n\t\t\tvar len = node.length;\n\t\t\tvar dist;\n\t\t\tvar pos = 0;\n\n\t\t\tif (node.textContent.trim().length === 0) {\n\t\t\t\treturn false; // continue\n\t\t\t}\n\n\t\t\t// Start range\n\t\t\tif (counter == 0) {\n\t\t\t\trange = this.createRange();\n\t\t\t\trange.startContainer = node;\n\t\t\t\trange.startOffset = 0;\n\t\t\t}\n\n\t\t\tdist = _break - counter;\n\n\t\t\t// Node is smaller than a break,\n\t\t\t// skip over it\n\t\t\tif(dist > len){\n\t\t\t\tcounter += len;\n\t\t\t\tpos = len;\n\t\t\t}\n\n\n\t\t\twhile (pos < len) {\n\t\t\t\tdist = _break - counter;\n\n\t\t\t\tif (counter === 0) {\n\t\t\t\t\t// Start new range\n\t\t\t\t\tpos += 1;\n\t\t\t\t\trange = this.createRange();\n\t\t\t\t\trange.startContainer = node;\n\t\t\t\t\trange.startOffset = pos;\n\t\t\t\t}\n\n\t\t\t\t// pos += dist;\n\n\t\t\t\t// Gone over\n\t\t\t\tif(pos + dist >= len){\n\t\t\t\t\t// Continue counter for next node\n\t\t\t\t\tcounter += len - pos;\n\t\t\t\t\t// break\n\t\t\t\t\tpos = len;\n\t\t\t\t// At End\n\t\t\t\t} else {\n\t\t\t\t\t// Advance pos\n\t\t\t\t\tpos += dist;\n\n\t\t\t\t\t// End the previous range\n\t\t\t\t\trange.endContainer = node;\n\t\t\t\t\trange.endOffset = pos;\n\t\t\t\t\t// cfi = section.cfiFromRange(range);\n\t\t\t\t\tlet cfi = new EpubCFI(range, cfiBase).toString();\n\t\t\t\t\tlocations.push(cfi);\n\t\t\t\t\tcounter = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = node;\n\t\t};\n\n\t\tsprint(body, parser.bind(this));\n\n\t\t// Close remaining\n\t\tif (range && range.startContainer && prev) {\n\t\t\trange.endContainer = prev;\n\t\t\trange.endOffset = prev.length;\n\t\t\tlet cfi = new EpubCFI(range, cfiBase).toString();\n\t\t\tlocations.push(cfi);\n\t\t\tcounter = 0;\n\t\t}\n\n\t\treturn locations;\n\t}\n\n\n\t/**\n\t * Load all of sections in the book to generate locations\n\t * @param  {string} startCfi start position\n\t * @param  {int} wordCount how many words to split on\n\t * @param  {int} count result count\n\t * @return {object} locations\n\t */\n\tgenerateFromWords(startCfi, wordCount, count) {\n\t\tvar start = startCfi ? new EpubCFI(startCfi) : undefined;\n\t\tthis.q.pause();\n\t\tthis._locationsWords = [];\n\t\tthis._wordCounter = 0;\n\n\t\tthis.spine.each(function(section) {\n\t\t\tif (section.linear) {\n\t\t\t\tif (start) {\n\t\t\t\t\tif (section.index >= start.spinePos) {\n\t\t\t\t\t\tthis.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this));\n\n\t\treturn this.q.run().then(function() {\n\t\t\tif (this._currentCfi) {\n\t\t\t\tthis.currentLocation = this._currentCfi;\n\t\t\t}\n\n\t\t\treturn this._locationsWords;\n\t\t}.bind(this));\n\n\t}\n\n\tprocessWords(section, wordCount, startCfi, count) {\n\t\tif (count && this._locationsWords.length >= count) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn section.load(this.request)\n\t\t\t.then(function(contents) {\n\t\t\t\tvar completed = new defer();\n\t\t\t\tvar locations = this.parseWords(contents, section, wordCount, startCfi);\n\t\t\t\tvar remainingCount = count - this._locationsWords.length;\n\t\t\t\tthis._locationsWords = this._locationsWords.concat(locations.length >= count ? locations.slice(0, remainingCount) : locations);\n\n\t\t\t\tsection.unload();\n\n\t\t\t\tthis.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);\n\t\t\t\treturn completed.promise;\n\t\t\t}.bind(this));\n\t}\n\n\t//http://stackoverflow.com/questions/18679576/counting-words-in-string\n\tcountWords(s) {\n\t\ts = s.replace(/(^\\s*)|(\\s*$)/gi, \"\");//exclude  start and end white-space\n\t\ts = s.replace(/[ ]{2,}/gi, \" \");//2 or more space to 1\n\t\ts = s.replace(/\\n /, \"\\n\"); // exclude newline with a start spacing\n\t\treturn s.split(\" \").length;\n\t}\n\n\tparseWords(contents, section, wordCount, startCfi) {\n\t\tvar cfiBase = section.cfiBase;\n\t\tvar locations = [];\n\t\tvar doc = contents.ownerDocument;\n\t\tvar body = qs(doc, \"body\");\n\t\tvar prev;\n\t\tvar _break = wordCount;\n\t\tvar foundStartNode = startCfi ? startCfi.spinePos !== section.index : true;\n\t\tvar startNode;\n\t\tif (startCfi && section.index === startCfi.spinePos) {\n\t\t\tstartNode = startCfi.findNode(startCfi.range ? startCfi.path.steps.concat(startCfi.start.steps) : startCfi.path.steps, contents.ownerDocument);\n\t\t}\n\t\tvar parser = function(node) {\n\t\t\tif (!foundStartNode) {\n\t\t\t\tif (node === startNode) {\n\t\t\t\t\tfoundStartNode = true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.textContent.length < 10) {\n\t\t\t\tif (node.textContent.trim().length === 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar len  = this.countWords(node.textContent);\n\t\t\tvar dist;\n\t\t\tvar pos = 0;\n\n\t\t\tif (len === 0) {\n\t\t\t\treturn false; // continue\n\t\t\t}\n\n\t\t\tdist = _break - this._wordCounter;\n\n\t\t\t// Node is smaller than a break,\n\t\t\t// skip over it\n\t\t\tif (dist > len) {\n\t\t\t\tthis._wordCounter += len;\n\t\t\t\tpos = len;\n\t\t\t}\n\n\n\t\t\twhile (pos < len) {\n\t\t\t\tdist = _break - this._wordCounter;\n\n\t\t\t\t// Gone over\n\t\t\t\tif (pos + dist >= len) {\n\t\t\t\t\t// Continue counter for next node\n\t\t\t\t\tthis._wordCounter += len - pos;\n\t\t\t\t\t// break\n\t\t\t\t\tpos = len;\n\t\t\t\t\t// At End\n\t\t\t\t} else {\n\t\t\t\t\t// Advance pos\n\t\t\t\t\tpos += dist;\n\n\t\t\t\t\tlet cfi = new EpubCFI(node, cfiBase);\n\t\t\t\t\tlocations.push({ cfi: cfi.toString(), wordCount: this._wordCounter });\n\t\t\t\t\tthis._wordCounter = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = node;\n\t\t};\n\n\t\tsprint(body, parser.bind(this));\n\n\t\treturn locations;\n\t}\n\n\t/**\n\t * Get a location from an EpubCFI\n\t * @param {EpubCFI} cfi\n\t * @return {number}\n\t */\n\tlocationFromCfi(cfi){\n\t\tlet loc;\n\t\tif (EpubCFI.prototype.isCfiString(cfi)) {\n\t\t\tcfi = new EpubCFI(cfi);\n\t\t}\n\t\t// Check if the location has not been set yet\n\t\tif(this._locations.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tloc = locationOf(cfi, this._locations, this.epubcfi.compare);\n\n\t\tif (loc > this.total) {\n\t\t\treturn this.total;\n\t\t}\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * Get a percentage position in locations from an EpubCFI\n\t * @param {EpubCFI} cfi\n\t * @return {number}\n\t */\n\tpercentageFromCfi(cfi) {\n\t\tif(this._locations.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\t// Find closest cfi\n\t\tvar loc = this.locationFromCfi(cfi);\n\t\t// Get percentage in total\n\t\treturn this.percentageFromLocation(loc);\n\t}\n\n\t/**\n\t * Get a percentage position from a location index\n\t * @param {number} location\n\t * @return {number}\n\t */\n\tpercentageFromLocation(loc) {\n\t\tif (!loc || !this.total) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (loc / this.total);\n\t}\n\n\t/**\n\t * Get an EpubCFI from location index\n\t * @param {number} loc\n\t * @return {EpubCFI} cfi\n\t */\n\tcfiFromLocation(loc){\n\t\tvar cfi = -1;\n\t\t// check that pg is an int\n\t\tif(typeof loc != \"number\"){\n\t\t\tloc = parseInt(loc);\n\t\t}\n\n\t\tif(loc >= 0 && loc < this._locations.length) {\n\t\t\tcfi = this._locations[loc];\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Get an EpubCFI from location percentage\n\t * @param {number} percentage\n\t * @return {EpubCFI} cfi\n\t */\n\tcfiFromPercentage(percentage){\n\t\tlet loc;\n\t\tif (percentage > 1) {\n\t\t\tconsole.warn(\"Normalize cfiFromPercentage value to between 0 - 1\");\n\t\t}\n\n\t\t// Make sure 1 goes to very end\n\t\tif (percentage >= 1) {\n\t\t\tlet cfi = new EpubCFI(this._locations[this.total]);\n\t\t\tcfi.collapse();\n\t\t\treturn cfi.toString();\n\t\t}\n\n\t\tloc = Math.ceil(this.total * percentage);\n\t\treturn this.cfiFromLocation(loc);\n\t}\n\n\t/**\n\t * Load locations from JSON\n\t * @param {json} locations\n\t */\n\tload(locations){\n\t\tif (typeof locations === \"string\") {\n\t\t\tthis._locations = JSON.parse(locations);\n\t\t} else {\n\t\t\tthis._locations = locations;\n\t\t}\n\t\tthis.total = this._locations.length - 1;\n\t\treturn this._locations;\n\t}\n\n\t/**\n\t * Save locations to JSON\n\t * @return {json}\n\t */\n\tsave(){\n\t\treturn JSON.stringify(this._locations);\n\t}\n\n\tgetCurrent(){\n\t\treturn this._current;\n\t}\n\n\tsetCurrent(curr){\n\t\tvar loc;\n\n\t\tif(typeof curr == \"string\"){\n\t\t\tthis._currentCfi = curr;\n\t\t} else if (typeof curr == \"number\") {\n\t\t\tthis._current = curr;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tif(this._locations.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(typeof curr == \"string\"){\n\t\t\tloc = this.locationFromCfi(curr);\n\t\t\tthis._current = loc;\n\t\t} else {\n\t\t\tloc = curr;\n\t\t}\n\n\t\tthis.emit(EVENTS.LOCATIONS.CHANGED, {\n\t\t\tpercentage: this.percentageFromLocation(loc)\n\t\t});\n\t}\n\n\t/**\n\t * Get the current location\n\t */\n\tget currentLocation() {\n\t\treturn this._current;\n\t}\n\n\t/**\n\t * Set the current location\n\t */\n\tset currentLocation(curr) {\n\t\tthis.setCurrent(curr);\n\t}\n\n\t/**\n\t * Locations length\n\t */\n\tlength () {\n\t\treturn this._locations.length;\n\t}\n\n\tdestroy () {\n\t\tthis.spine = undefined;\n\t\tthis.request = undefined;\n\t\tthis.pause = undefined;\n\n\t\tthis.q.stop();\n\t\tthis.q = undefined;\n\t\tthis.epubcfi = undefined;\n\n\t\tthis._locations = undefined\n\t\tthis.total = undefined;\n\n\t\tthis.break = undefined;\n\t\tthis._current = undefined;\n\n\t\tthis.currentLocation = undefined;\n\t\tthis._currentCfi = undefined;\n\t\tclearTimeout(this.processingTimeout);\n\t}\n}\n\nEventEmitter(Locations.prototype);\n\nexport default Locations;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}